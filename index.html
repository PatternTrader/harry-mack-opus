<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harry Mack Omegle Bars - Community Hub</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🎤</text></svg>">
  
    <style>
        /* General Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Body Styling */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }

        /* Container for main content */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header Section */
        .header {
            text-align: center;
            margin-bottom: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            color: white;
            position: relative;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        /* User Info Section */
        .user-section {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .user-info {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        /* Google Sign-in Button */
        .auth-button {
            display: inline-flex;
            align-items: center;
            background: white;
            color: #3c4043;
            border: 1px solid #dadce0;
            border-radius: 24px;
            padding: 10px 16px;
            font-family: 'Google Sans', 'Roboto', Arial, sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px 0 rgba(60,64,67,0.30), 0 1px 3px 1px rgba(60,64,67,0.15);
            gap: 12px;
            min-height: 40px;
        }
        
        .auth-button:hover {
            background: #f8f9fa;
            border-color: #c1c7cd;
            box-shadow: 0 1px 3px 1px rgba(60,64,67,0.15), 0 1px 2px 0 rgba(60,64,67,0.30);
        }
        
        .auth-button:active {
            background: #f1f3f4;
            box-shadow: 0 1px 2px 0 rgba(60,64,67,0.30);
        }
        
        .google-icon {
            width: 18px;
            height: 18px;
            display: block;
        }
        
        /* Connection Status Indicator */
        .connection-status {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
            z-index: 1000;
        }

        .status-connected {
            background: #27ae60;
            color: white;
        }

        .status-disconnected {
            background: #e74c3c;
            color: white;
        }

        .status-demo {
            background: #f39c12;
            color: white;
        }

        .status-connecting {
            background: #f39c12;
            color: white;
        }
 
        /* Video Card Hover Effect */
        .video-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
        }
  

        /* Segments Section */
        .segments-section {
            margin-bottom: 20px;
        }

        .segments-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .segments-header h4 {
            color: #8e44ad;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .expand-toggle {
            background: #8e44ad;
            color: white;
            border: none;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .expand-toggle:hover {
            background: #7d3c98;
        }

        /* Individual Segment Styling */
        .segment {
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 2px;
            border-left: 4px solid #e74c3c;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .segment-header {
            padding: 10px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #fff;
            border-bottom: 1px solid #eee;
        }

        .segment-header:hover {
            background: #f8f9fa;
        }

        .segment-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .segment-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
        }

        .segment-rating-summary {
            font-size: 0.75rem;
            color: #7f8c8d;
        }

        .segment-expand-icon {
            color: #8e44ad;
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }

        .segment.expanded .segment-expand-icon {
            transform: rotate(90deg);
        }

        .segment-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .segment.expanded .segment-content {
            max-height: 800px; /* Increased to allow for more content */
        }

        .segment-details {
            padding: 12px;
        }

        .words-management {
            margin-bottom: 12px;
        }

        .words-management h5 {
            color: #2c3e50;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }
   
  
        .segment-ratings {
            border-top: 1px solid #eee;
            padding-top: 10px;
        }

        .rating-category {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .rating-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .rating-label {
            font-weight: 600;
            color: #34495e;
            font-size: 0.85rem;
        }

        .rating-stats {
            font-size: 0.7rem;
            color: #7f8c8d;
            margin-top: 2px;
        }

        .rating-controls {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
        }

        .stars {
            display: flex;
            gap: 3px;
        }

        .star {
            width: 20px;
            height: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #ddd;
            user-select: none;
        }

        .star:hover,
        .star.active,
        .star.active-hover {
            color: #f39c12;
            transform: scale(1.1);
        }

        .star.user-rated {
            color: #e74c3c;
        }

        .user-rating-indicator {
            font-size: 0.65rem;
            color: #e74c3c;
            font-weight: bold;
        }

        .stats-bar {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            color: white;
            text-align: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .stat-item {
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .filter-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            color: white;
        }

        .filter-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-controls select,
        .filter-controls input {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            background: white;
            color: #333;
        }

        .loading {
            text-align: center;
            color: white;
            font-size: 1.2rem;
            margin: 50px 0;
        }

        .error-message {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        /* Notification Popups */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 10px;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: slideIn 0.3s ease;
        }

        .notification.success {
            background: #27ae60;
            color: white;
        }

        .notification.error {
            background: #e74c3c;
            color: white;
        }

        .notification.info {
            background: #3498db;
            color: white;
        }

        .segment-label {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .debug-info {
            background: #ffeb3b;
            color: #333;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 0.8rem;
            font-family: monospace;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .video-grid {
                grid-template-columns: 1fr;
            }
            .header h1 {
                font-size: 2rem;
            }
            .user-section {
                position: static;
                justify-content: center;
                margin-top: 15px;
            }
            .filter-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
		
		/* Notes Section Styles */
		.notes-section {
			border-top: 1px solid #eee;
			padding-top: 15px;
			margin-top: 15px;
		}

		.notes-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 10px;
			cursor: pointer;
			padding: 8px;
			border-radius: 8px;
			transition: background 0.2s ease;
		}

		.notes-header:hover {
			background: #f8f9fa;
		}

		.notes-title {
			font-weight: 600;
			color: #2c3e50;
			font-size: 0.85rem;
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.notes-expand-icon {
			color: #8e44ad;
			font-size: 1rem;
			transition: transform 0.3s ease;
		}

		.notes-section.expanded .notes-expand-icon {
			transform: rotate(90deg);
		}

		.notes-content {
			max-height: 0;
			overflow: hidden;
			transition: max-height 0.3s ease;
		}

		.notes-section.expanded .notes-content {
			max-height: 400px;
		}

		.notes-textarea {
			width: 100%;
			min-height: 80px;
			max-height: 200px;
			padding: 10px;
			border: 1px solid #ddd;
			border-radius: 8px;
			font-size: 0.85rem;
			font-family: inherit;
			resize: vertical;
			transition: border-color 0.2s ease;
		}

		.notes-textarea:focus {
			outline: none;
			border-color: #8e44ad;
			box-shadow: 0 0 0 2px rgba(142, 68, 173, 0.1);
		}

		.notes-actions {
			display: flex;
			gap: 8px;
			margin-top: 10px;
			justify-content: flex-end;
		}

		.notes-save-btn {
			background: #27ae60;
			color: white;
			border: none;
			padding: 6px 12px;
			border-radius: 6px;
			font-size: 0.8rem;
			cursor: pointer;
			transition: background 0.2s ease;
		}

		.notes-save-btn:hover {
			background: #229954;
		}

		.notes-save-btn:disabled {
			background: #bdc3c7;
			cursor: not-allowed;
		}

		.notes-cancel-btn {
			background: #95a5a6;
			color: white;
			border: none;
			padding: 6px 12px;
			border-radius: 6px;
			font-size: 0.8rem;
			cursor: pointer;
			transition: background 0.2s ease;
		}

		.notes-cancel-btn:hover {
			background: #7f8c8d;
		}

		.notes-display {
			background: #f8f9fa;
			border: 1px solid #e9ecef;
			border-radius: 8px;
			padding: 12px;
			font-size: 0.85rem;
			line-height: 1.4;
			white-space: pre-wrap;
			word-wrap: break-word;
			min-height: 40px;
		}

		.notes-display.empty {
			color: #6c757d;
			font-style: italic;
		}

		.notes-edit-btn {
			background: #3498db;
			color: white;
			border: none;
			padding: 4px 8px;
			border-radius: 4px;
			font-size: 0.75rem;
			cursor: pointer;
			transition: background 0.2s ease;
			margin-top: 8px;
		}

		.notes-edit-btn:hover {
			background: #2980b9;
		}

		.notes-char-count {
			font-size: 0.7rem;
			color: #6c757d;
			text-align: right;
			margin-top: 4px;
		}

		.notes-char-count.warning {
			color: #f39c12;
		}

		.notes-char-count.error {
			color: #e74c3c;
		}
		/* ===== END NOTES CSS ===== */
		
		/* Segment Summary Header */
        .segments-summary h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

		/* Segment Preview Labels */
        .segment-preview-label {
            font-weight: 600;
        }

		/* Segment Preview Rating */
        .segment-preview-rating {
            background: rgba(255, 255, 255, 0.3);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
        }

		/* No Segments Preview */
        .no-segments-preview {
            color: #7f8c8d;
            font-style: italic;
            font-size: 0.9rem;
        }
        /* ===== END SEGMENT SUMMARY CSS ===== */

	 
		/* ===== PLATFORM INTRO BANNER ===== */
		.platform-intro {
			background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
			border-radius: 20px;
			padding: 40px 30px;
			margin-bottom: 30px;
			color: white;
			text-align: center;
			position: relative;
			overflow: hidden;
			box-shadow: 0 15px 35px rgba(102, 126, 234, 0.3);
		}

		.platform-intro::before {
			content: '';
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="25" cy="25" r="1" fill="white" opacity="0.1"/><circle cx="75" cy="75" r="1" fill="white" opacity="0.1"/><circle cx="50" cy="10" r="1" fill="white" opacity="0.05"/><circle cx="90" cy="40" r="1" fill="white" opacity="0.1"/><circle cx="10" cy="80" r="1" fill="white" opacity="0.05"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
			pointer-events: none;
		}

		.intro-content {
			position: relative;
			z-index: 1;
			max-width: 800px;
			margin: 0 auto;
		}

		.intro-badge {
			display: inline-flex;
			align-items: center;
			background: rgba(255, 255, 255, 0.2);
			backdrop-filter: blur(10px);
			border: 1px solid rgba(255, 255, 255, 0.3);
			padding: 8px 20px;
			border-radius: 50px;
			font-size: 0.85rem;
			font-weight: 600;
			margin-bottom: 20px;
			gap: 8px;
			animation: fadeInUp 0.6s ease;
		}

		.intro-badge span {
			background: linear-gradient(45deg, #fff, #f0f0f0);
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			background-clip: text;
			font-weight: 700;
			letter-spacing: 1px;
		}

		.intro-title {
			font-size: 2.2rem;
			font-weight: 700;
			margin-bottom: 15px;
			text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
			animation: fadeInUp 0.6s ease 0.1s backwards;
			line-height: 1.2;
		}

		.intro-description {
			font-size: 1.1rem;
			margin-bottom: 30px;
			opacity: 0.95;
			line-height: 1.4;
			animation: fadeInUp 0.6s ease 0.2s backwards;
		}

		.intro-features {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
			gap: 20px;
			margin-top: 30px;
		}

		.feature-item {
			display: flex;
			align-items: center;
			background: rgba(255, 255, 255, 0.15);
			backdrop-filter: blur(10px);
			border: 1px solid rgba(255, 255, 255, 0.2);
			padding: 15px 20px;
			border-radius: 15px;
			text-align: left;
			transition: all 0.3s ease;
			animation: fadeInUp 0.6s ease 0.3s backwards;
		}

		.feature-item:hover {
			transform: translateY(-2px);
			background: rgba(255, 255, 255, 0.2);
			box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
		}

		.feature-icon {
			font-size: 1.5rem;
			margin-right: 15px;
			flex-shrink: 0;
		}

		.feature-item span {
			font-size: 0.95rem;
			line-height: 1.3;
		}

		@keyframes fadeInUp {
			from {
				opacity: 0;
				transform: translateY(30px);
			}
			to {
				opacity: 1;
				transform: translateY(0);
			}
		}

		@media (max-width: 768px) {
			.platform-intro {
				padding: 30px 20px;
				margin-bottom: 20px;
			}
			
			.intro-title {
				font-size: 1.8rem;
			}
			
			.intro-description {
				font-size: 1rem;
			}
			
			.intro-features {
				grid-template-columns: 1fr;
				gap: 15px;
			}
			
			.feature-item {
				padding: 12px 15px;
			}
			
			.feature-icon {
				font-size: 1.2rem;
				margin-right: 12px;
			}
		}
		/* ===== END PLATFORM INTRO BANNER ===== */

		/* ===== DISCLAIMER BANNER ===== */
		.disclaimer-banner {
			background: #fff3cd;
			border: 1px solid #ffeaa7;
			color: #856404;
			padding: 12px 20px;
			margin-bottom: 20px;
			border-radius: 8px;
			font-size: 0.9rem;
			text-align: center;
			box-shadow: 0 2px 4px rgba(0,0,0,0.1);
		}

		.disclaimer-banner strong {
			color: #664d03;
		}
		/* ===== END DISCLAIMER BANNER ===== */


		/* ===== HORIZONTAL WORDS DISPLAY ===== */
		.words-horizontal-container {
			background: #f8f9fa;
			border-radius: 10px;
			padding: 15px;
			border-left: 4px solid #3498db;
		}

		.words-horizontal {
			display: flex;
			gap: 12px;
			flex-wrap: wrap;
			align-items: center;
		}

		.word-display {
			display: inline-flex;
			align-items: center;
			background: linear-gradient(45deg, #3498db, #2980b9);
			color: white;
			padding: 8px 16px;
			border-radius: 25px;
			font-size: 0.9rem;
			font-weight: 600;
			box-shadow: 0 2px 4px rgba(0,0,0,0.1);
			transition: all 0.2s ease;
			min-width: 80px;
			justify-content: center;
		}

		.word-display:hover {
			transform: translateY(-1px);
			box-shadow: 0 4px 8px rgba(0,0,0,0.15);
		}

		.word-text {
			font-weight: 700;
			letter-spacing: 0.3px;
		}

		/* ===== FILL-IN LINK STYLES ===== */
		.word-missing {
			display: inline-flex;
			align-items: center;
			min-width: 80px;
			justify-content: center;
		}
		/* Enhanced fill-in button styling */
		.fill-in-link {
			display: inline-flex;
			align-items: center;
			background: linear-gradient(45deg, #e74c3c, #c0392b) !important;
			color: white !important;
			padding: 8px 16px;
			border-radius: 25px;
			font-size: 0.85rem;
			font-weight: 600;
			text-decoration: none;
			box-shadow: 0 2px 4px rgba(0,0,0,0.1);
			transition: all 0.2s ease;
			cursor: pointer;
			border: 2px dashed rgba(255,255,255,0.3);
			min-width: 80px;
			justify-content: center;
		}

		.fill-in-link:hover {
			background: linear-gradient(45deg, #c0392b, #a93226) !important;
			transform: translateY(-1px);
			box-shadow: 0 4px 8px rgba(0,0,0,0.2);
			text-decoration: none;
			color: white !important;
			border: 2px dashed rgba(255,255,255,0.6);
		}

		.fill-in-link-small {
			display: inline-flex;
			align-items: center;
			background: linear-gradient(45deg, #e74c3c, #c0392b) !important;
			color: white !important;
			padding: 4px 12px;
			border-radius: 15px;
			font-size: 0.75rem;
			font-weight: 600;
			text-decoration: none;
			box-shadow: 0 1px 3px rgba(0,0,0,0.1);
			transition: all 0.2s ease;
			cursor: pointer;
			border: 1px dashed rgba(255,255,255,0.3);
			min-width: 60px;
			justify-content: center;
		}
		

		/* ===== WORDS MANAGEMENT STYLES ===== */
		.words-management h5 {
			color: #2c3e50;
			margin-bottom: 10px;
			font-size: 0.85rem;
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.words-management h5::before {
			content: '🎵';
			font-size: 1rem;
		}

		.words-help-text {
			font-size: 0.75rem;
			color: #7f8c8d;
			margin-top: 8px;
			font-style: italic;
		}

		/* ===== GENERAL STYLES ===== */
		.segment-label {
			font-size: 0.8rem;
			color: #666;
			margin-bottom: 5px;
			font-weight: 600;
		}

		.no-words {
			color: #7f8c8d;
			font-style: italic;
			font-size: 0.9rem;
			padding: 8px;
			text-align: center;
		}

		/* ===== RESPONSIVE DESIGN ===== */
		@media (max-width: 768px) {
			.words-horizontal {
				flex-direction: column;
				gap: 8px;
				align-items: stretch;
			}
			
			.word-display,
			.word-missing {
				min-width: auto;
				width: 100%;
			}
			
			.fill-in-link {
				width: 100%;
				justify-content: center;
			}
		}
		/* ===== END HORIZONTAL WORDS CSS ===== */


		/* ===== INLINE SEGMENT HEADER WORDS ===== */
		.segment-info-with-words {
			display: flex;
			flex-direction: column;
			gap: 4px;
			flex: 1;
		}

		.segment-title-and-rating {
			display: flex;
			flex-direction: column;
			gap: 5px;
		}

		.segment-words-inline {
			display: flex;
			gap: 8px;
			flex-wrap: wrap;
			align-items: center;
			width: 100%;
		}

		.segment-words-inline .word-display {
			padding: 4px 12px;
			font-size: 0.8rem;
			min-width: 60px;
			border-radius: 15px;
		}

		.word-missing-inline {
			display: inline-flex;
			align-items: center;
		}

		.fill-in-link-small {
			display: inline-flex;
			align-items: center;
			background: linear-gradient(45deg, #e74c3c, #c0392b);
			color: white;
			padding: 4px 12px;
			border-radius: 15px;
			font-size: 0.75rem;
			font-weight: 600;
			text-decoration: none;
			box-shadow: 0 1px 3px rgba(0,0,0,0.1);
			transition: all 0.2s ease;
			cursor: pointer;
			border: 1px dashed rgba(255,255,255,0.3);
			min-width: 60px;
			justify-content: center;
		}

		.fill-in-link-small:hover {
			background: linear-gradient(45deg, #c0392b, #a93226);
			transform: translateY(-1px);
			box-shadow: 0 2px 4px rgba(0,0,0,0.2);
			text-decoration: none;
			color: white;
			border: 1px dashed rgba(255,255,255,0.6);
		}


		/* ===== RESPONSIVE FOR INLINE WORDS ===== */
		@media (max-width: 768px) {
			.segment-words-inline {
				flex-direction: column;
				gap: 4px;
				align-items: stretch;
			}
			
			.segment-words-inline .word-display,
			.fill-in-link-small {
				width: 100%;
				min-width: auto;
			}
			
			.segment-right-controls {
				gap: 6px;
			}
			
			.rate-this-btn {
				font-size: 0.7rem;
				padding: 5px 10px;
			}
			
			.segment-rating-display {
				font-size: 0.75rem;
				padding: 3px 6px;
			}
		}



		/* ===== ADAPTIVE HEIGHT VIDEO CARDS (OPTION 5) ===== */

		/* Adaptive video grid - natural heights */
		.video-grid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
			gap: 20px;
			margin-bottom: 40px;
			align-items: start; /* Align cards to top, allow natural heights */
		}

		/* OPTION 2A: All Cards Same Height */
		.video-card {
			height: 800px; /* Fixed height for ALL cards */
			display: flex;
			flex-direction: column;
			background: white;
			border-radius: 15px;
			overflow: hidden;
			box-shadow: 0 6px 20px rgba(0,0,0,0.1);
			transition: transform 0.3s ease, box-shadow 0.3s ease;
		}

		.video-card:hover {
			transform: translateY(-5px);
			box-shadow: 0 15px 35px rgba(0,0,0,0.2);
		}


		.video-card:hover {
			transform: translateY(-5px);
			box-shadow: 0 15px 35px rgba(0,0,0,0.2);
		}

		/* Fixed video embed height */
		.video-embed {
			height: 180px;
			flex-shrink: 0;
			position: relative;
			width: 100%;
			background: #f0f0f0;
			display: flex;
			align-items: center;
			justify-content: center;
			color: #666;
			font-size: 14px;
		}

		/* Video content area */
		.video-content {
			padding: 20px;
			flex: 1;
			display: flex;
			flex-direction: column;
			overflow: hidden;
		}

		/* Fixed height video title */
		.video-title {
			font-size: 1.1rem;
			font-weight: bold;
			color: #2c3e50;
			line-height: 1.3;
			margin-bottom: 15px;
		}





		 
			 
		/* Always scrollable segments section */
		.segments-section {
			flex: 1;
			margin-bottom: 0;
			overflow-y: auto; /* ALL cards are scrollable */
			overflow-x: hidden;
			padding-right: 8px; /* Space for scrollbar */
		}
			 
		/* Universal custom scrollbar for all cards */
		.segments-section::-webkit-scrollbar {
			width: 6px;
		}

		.segments-section::-webkit-scrollbar-track {
			background: #f1f1f1;
			border-radius: 3px;
		}

		.segments-section::-webkit-scrollbar-thumb {
			background: #c1c1c1;
			border-radius: 3px;
		}

		.segments-section::-webkit-scrollbar-thumb:hover {
			background: #a1a1a1;
		}

		/* Subtle scroll hint for all cards */
		.segments-section::before {
			content: "📋 Scroll to see all segments and ratings";
			display: block;
			text-align: center;
			font-size: 0.7rem;
			color: #888;
			background: #f8f9fa;
			padding: 5px 10px;
			border-radius: 4px;
			margin-bottom: 10px;
			border: 1px solid #e9ecef;
			position: sticky;
			top: 0;
			z-index: 10;
		}

		/* Mobile responsive for Option 2A */
		@media (max-width: 768px) {
			.video-card {
				height: 600px; /* Shorter on mobile */
			}
			
			.video-embed {
				height: 150px;
			}
			
			.video-content {
				padding: 15px;
			}

			.video-title {
				font-size: 1rem;
			}
			
			.segments-section::before {
				font-size: 0.65rem;
				padding: 4px 8px;
			}
		}

		@media (min-width: 1200px) {
			.video-card {
				height: 900px; /* Taller on large screens */
			}
		}





		.segments-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 15px;
		}

		.segments-header h4 {
			color: #8e44ad;
			font-size: 0.9rem;
			text-transform: uppercase;
			letter-spacing: 1px;
			font-weight: 600;
		}

		/* Hide expand toggle since everything is always visible */
		.expand-toggle {
			display: none;
		}

		/* Always show segment content */
		.segment {
			background: #f8f9fa;
			border-radius: 10px;
			margin-bottom: 8px;
			border-left: 4px solid #e74c3c;
			overflow: visible; /* Always show content */
		}

		.segment-header {
			padding: 10px;
			background: #fff;
			border-bottom: 1px solid #eee;
			cursor: default; /* Remove pointer cursor since no clicking needed */
		}

		.segment-content {
			max-height: none; /* Remove height restriction */
			overflow: visible; /* Always show content */
			display: block; /* Always visible */
		}

		/* Remove expand/collapse visual indicators */
		.segment-expand-icon {
			display: none; /* Hide expand arrows since everything is always open */
		}

		/* Responsive updates for mobile */
		@media (max-width: 768px) {
			.video-grid {
				grid-template-columns: 1fr; /* Single column on mobile */
				gap: 15px;
			}
			
			.video-embed {
				height: 150px;
			}
			
			.video-content {
				padding: 15px;
			}
			
			.video-title {
				font-size: 1rem;
			}
		}

		@media (min-width: 1200px) {
			.video-grid {
				grid-template-columns: repeat(3, 1fr); /* 3 columns on larger screens */
			}
		}




		/* Remove any duplicate information styling */
		.user-rating-indicator {
			font-size: 0.6rem; /* Reduced from 0.65rem */
			color: #e74c3c;
			font-weight: bold;
			margin-top: 2px;
		}

		/* Inline segment title and rating */
		.segment-title-inline {
			display: flex;
			justify-content: space-between;
			align-items: center;
			width: 100%;
		}

		.segment-name {
			font-weight: 600;
			color: #2c3e50;
			font-size: 0.9rem;
		}

		.segment-rating-inline {
			font-size: 0.75rem;
			color: #7f8c8d;
			font-weight: 600;
			background: rgba(52, 152, 219, 0.1);
			padding: 2px 6px;
			border-radius: 8px;
			flex-shrink: 0;
		}


		/* Real words from database - BLUE */
		.word-real {
			background: linear-gradient(45deg, #3498db, #2980b9) !important;
		}

		.word-real .word-text {
			color: white;
		}

		/* Small inline real words - BLUE */
		.segment-words-inline .word-real {
			background: linear-gradient(45deg, #3498db, #2980b9) !important;
		}

		/* Missing words (fill-in) - ORANGE */
		.fill-in-link {
			background: linear-gradient(45deg, #f39c12, #e67e22) !important;
		}

		.fill-in-link-small {
			background: linear-gradient(45deg, #f39c12, #e67e22) !important;
		}

		.fill-in-link:hover {
			background: linear-gradient(45deg, #e67e22, #d35400) !important;
		}

		.fill-in-link-small:hover {
			background: linear-gradient(45deg, #e67e22, #d35400) !important;
		}


		/* ===== ADMIN MODAL STYLES ===== */
		.admin-modal {
			display: none;
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.7);
			z-index: 2000;
			overflow-y: auto;
		}

		.admin-modal-content {
			background: white;
			margin: 50px auto;
			padding: 30px;
			width: 90%;
			max-width: 800px; /* Increased max-width for more content */
			border-radius: 15px;
			box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
			animation: slideDown 0.3s ease;
		}

		@keyframes slideDown {
			from {
				transform: translateY(-50px);
				opacity: 0;
			}
			to {
				transform: translateY(0);
				opacity: 1;
			}
		}

		.admin-modal-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 25px;
			padding-bottom: 15px;
			border-bottom: 2px solid #e9ecef;
		}

		.admin-modal-title {
			font-size: 1.5rem;
			color: #2c3e50;
			font-weight: 700;
			display: flex;
			align-items: center;
			gap: 10px;
		}

		.admin-close-btn {
			background: none;
			border: none;
			font-size: 1.8rem;
			color: #6c757d;
			cursor: pointer;
			transition: color 0.2s ease;
			padding: 0;
			width: 35px;
			height: 35px;
			display: flex;
			align-items: center;
			justify-content: center;
			border-radius: 50%;
		}

		.admin-close-btn:hover {
			color: #e74c3c;
			background: rgba(231, 76, 60, 0.1);
		}

		.admin-form-group {
			margin-bottom: 20px;
		}

		.admin-form-group label {
			display: block;
			margin-bottom: 8px;
			color: #34495e;
			font-weight: 600;
			font-size: 0.9rem;
		}

		.admin-form-control {
			width: 100%;
			padding: 10px 15px;
			border: 2px solid #e9ecef;
			border-radius: 8px;
			font-size: 1rem;
			transition: border-color 0.2s ease;
			background: #f8f9fa;
		}

		.admin-form-control:focus {
			outline: none;
			border-color: #667eea;
			background: white;
			box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
		}

		.admin-episode-segment-row {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 15px;
		}

		.admin-segment-block {
			background: #f8f9fa;
			border-radius: 10px;
			padding: 20px;
			margin-bottom: 20px;
			border: 2px solid #e9ecef;
		}
		
		.admin-words-title {
			font-size: 1rem;
			color: #2c3e50;
			font-weight: 600;
			margin-bottom: 15px;
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.admin-word-input {
			position: relative;
		}

		.admin-word-number {
			position: absolute;
			left: 12px;
			top: 50%;
			transform: translateY(-50%);
			background: #667eea;
			color: white;
			width: 24px;
			height: 24px;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 0.8rem;
			font-weight: 700;
		}

		.admin-word-input input {
			padding-left: 45px;
		}

		.admin-form-actions {
			display: flex;
			gap: 10px;
			margin-top: 25px;
			padding-top: 20px;
			border-top: 2px solid #e9ecef;
			flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
		}

		.admin-btn {
			padding: 12px 24px;
			border: none;
			border-radius: 8px;
			font-size: 1rem;
			font-weight: 600;
			cursor: pointer;
			transition: all 0.2s ease;
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.admin-btn-primary {
			background: linear-gradient(135deg, #667eea, #764ba2);
			color: white;
			flex: 1;
		}

		.admin-btn-primary:hover {
			transform: translateY(-2px);
			box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
		}

		.admin-btn-primary:disabled {
			background: #95a5a6;
			cursor: not-allowed;
			transform: none;
		}

		.admin-btn-secondary {
			background: #e9ecef;
			color: #495057;
		}

		.admin-btn-secondary:hover {
			background: #dee2e6;
		}

		.admin-preview-section {
			background: #e8f4f8;
			border-radius: 10px;
			padding: 15px;
			margin-top: 15px;
			border: 2px solid #3498db;
		}

		.admin-preview-title {
			font-size: 0.9rem;
			color: #2c3e50;
			font-weight: 600;
			margin-bottom: 10px;
		}

		.admin-preview-content {
			display: flex;
			gap: 10px;
			flex-wrap: wrap;
		}

		.admin-preview-word {
			background: linear-gradient(45deg, #3498db, #2980b9);
			color: white;
			padding: 6px 14px;
			border-radius: 20px;
			font-size: 0.85rem;
			font-weight: 600;
		}

		.admin-success-message {
			background: #d4edda;
			color: #155724;
			padding: 15px;
			border-radius: 8px;
			margin-bottom: 20px;
			display: none;
			align-items: center;
			gap: 10px;
		}

		.admin-error-message {
			background: #f8d7da;
			color: #721c24;
			padding: 15px;
			border-radius: 8px;
			margin-bottom: 20px;
			display: none;
			align-items: center;
			gap: 10px;
		}

		.admin-info-message { /* Added new info message style */
			background: #e0f2f7;
			color: #0c5460;
			padding: 15px;
			border-radius: 8px;
			margin-bottom: 20px;
			display: none;
			align-items: center;
			gap: 10px;
		}


		/* Styles for dynamically added word/segment buttons */
		.admin-btn-remove-word {
			margin-left: 10px; /* Space out remove button */
		}
		.admin-btn-remove-word:hover {
			color: #c0392b;
		}

		/* Adjust form-actions for better button alignment */
		.admin-form-actions button {
			flex-grow: 1;
			min-width: 120px; /* Ensure buttons have a minimum width */
		}

		/* Responsive adjustments for admin modal */
		@media (max-width: 600px) {
			.admin-modal-content {
				margin: 20px auto;
				padding: 20px;
			}
			.admin-modal-title {
				font-size: 1.2rem;
			}
			.admin-close-btn {
				font-size: 1.5rem;
			}
			.admin-form-actions {
				flex-direction: column;
			}
			.admin-form-actions button {
				width: 100%; /* Full width buttons on small screens */
			}
			.admin-segment-block .admin-form-group {
				grid-template-columns: 1fr; /* Stack word inputs on mobile */
			}
			.admin-word-input input {
				padding-left: 15px; /* Adjust padding if word number is removed on mobile */
			}
			.admin-word-number {
				display: none; /* Hide word number on small screens */
			}
		}
 

		.segments-container {
			/* Allow natural number of segments */
		}

		/* Handle 4+ word displays */
		.words-horizontal {
			display: flex;
			gap: 12px;
			flex-wrap: wrap;
			align-items: center;
			justify-content: flex-start;
		}

		/* Responsive handling for many words */
		@media (max-width: 768px) {
			.segment-words-inline {
				flex-direction: column;
				gap: 4px;
				align-items: stretch;
			}
		}

	 
		/* Default Compact Layout - Words Focused */
		.video-grid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
			gap: 20px;
			margin-bottom: 40px;
			align-items: start;
		}

		.video-card {
			height: auto !important;
			min-height: 300px;
			display: flex;
			flex-direction: column;
			background: white;
			border-radius: 15px;
			overflow: hidden;
			box-shadow: 0 6px 20px rgba(0,0,0,0.1);
			transition: transform 0.3s ease, box-shadow 0.3s ease;
		}

		.video-card:hover {
			transform: translateY(-5px);
			box-shadow: 0 15px 35px rgba(0,0,0,0.2);
		}

		.video-embed {
			height: 120px;
			flex-shrink: 0;
			position: relative;
			width: 100%;
			background: #f0f0f0;
			display: flex;
			align-items: center;
			justify-content: center;
			color: #666;
			font-size: 14px;
		}

		.video-content {
			flex: 1;
			display: flex;
			flex-direction: column;
			overflow: hidden;
			padding: 20px;
		}

		.video-title {
			height: auto;
			font-size: 1rem;
			margin-bottom: 15px;
			min-height: auto;
			flex-shrink: 0;
			font-weight: bold;
			color: #2c3e50;
			line-height: 1.3;
			display: flex;
			align-items: center;
		}

		.segments-section {
			flex: 1;
			margin-bottom: 0;
			overflow: visible;
		}

		.segments-section::before {
			display: none; /* No scroll indicators needed */
		}

		.segments-header {
			margin-bottom: 12px;
			display: flex;
			justify-content: space-between;
			align-items: center;
		}

		.segments-header h4 {
			font-size: 0.85rem;
			margin-bottom: 8px;
			color: #8e44ad;
			text-transform: uppercase;
			letter-spacing: 1px;
			font-weight: 600;
		}

	

		/* Segment display - compact by default */
		.segment {
			margin-bottom: 12px;
			border-left: 3px solid #e74c3c;
			background: #f8f9fa;
			border-radius: 10px;
			overflow: hidden;
			transition: all 0.3s ease;
		}

		.segment-header {
			padding: 12px 15px;
			cursor: default;
			background: #fff;
			border-bottom: 1px solid #eee;
			display: flex;
			flex-direction: column;
		}

		.segment-info-with-words {
			width: 100%;
		}

		.segment-title-and-rating {
			margin-bottom: 4px;
		}



		/* Segment header layout */
		.segment-title-row {
			display: flex;
			align-items: center;
			gap: 12px;
			margin-bottom: 12px;
			width: 100%;
		}

		.segment-name {
			font-size: 0.85rem;
			font-weight: 600;
			color: #2c3e50;
			flex-shrink: 0;
		}

		.rate-this-btn {
			background: linear-gradient(135deg, #667eea, #764ba2);
			color: white;
			border: none;
			padding: 6px 12px;
			border-radius: 6px;
			font-size: 0.75rem;
			font-weight: 600;
			cursor: pointer;
			transition: all 0.2s ease;
			flex-shrink: 0;
		}

		.rate-this-btn:hover {
			background: linear-gradient(135deg, #5a6fd8, #6a4190);
			transform: translateY(-1px);
		}

		.rate-this-btn.expanded {
			background: linear-gradient(135deg, #27ae60, #2ecc71);
		}

		.rate-this-btn.expanded:hover {
			background: linear-gradient(135deg, #229954, #27ae60);
		}

		.segment-rating-display {
			font-size: 0.8rem;
			background: rgba(52, 152, 219, 0.15);
			padding: 4px 8px;
			border-radius: 6px;
			color: #2980b9;
			font-weight: 600;
			flex-shrink: 0;
			margin-left: auto;
		}

		/* Words section - clearly separated */
		.segment-words-inline {
			display: flex;
			gap: 8px;
			flex-wrap: wrap;
			align-items: center;
			width: 100%;
		}

		.segment-header {
			padding: 12px 15px;
			cursor: default;
			background: #fff;
			border-bottom: 1px solid #eee;
			display: flex;
			flex-direction: column;
		}

		/* Segment header layout */
		.segment-title-row {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 12px;
			width: 100%;
		}

		.segment-name {
			font-size: 0.85rem;
			font-weight: 600;
			color: #2c3e50;
			flex-shrink: 0;
		}

		.segment-right-controls {
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.rate-this-btn {
			background: linear-gradient(135deg, #667eea, #764ba2);
			color: white;
			border: none;
			padding: 6px 12px;
			border-radius: 6px;
			font-size: 0.75rem;
			font-weight: 600;
			cursor: pointer;
			transition: all 0.2s ease;
			flex-shrink: 0;
		}

		.rate-this-btn:hover {
			background: linear-gradient(135deg, #5a6fd8, #6a4190);
			transform: translateY(-1px);
		}

		.rate-this-btn.expanded {
			background: linear-gradient(135deg, #27ae60, #2ecc71);
		}

		.rate-this-btn.expanded:hover {
			background: linear-gradient(135deg, #229954, #27ae60);
		}

		.segment-rating-display {
			font-size: 0.8rem;
			background: rgba(52, 152, 219, 0.15);
			padding: 4px 8px;
			border-radius: 6px;
			color: #2980b9;
			font-weight: 600;
			flex-shrink: 0;
		}
	
	
	
	
	

		.word-display {
			padding: 6px 12px;
			font-size: 0.8rem;
			border-radius: 15px;
			min-width: 60px;
			margin-bottom: 4px;
			background: linear-gradient(45deg, #3498db, #2980b9);
			color: white;
			font-weight: 600;
			text-align: center;
		}

		.fill-in-link-small {
			padding: 6px 12px;
			font-size: 0.75rem;
			border-radius: 15px;
			min-width: 60px;
			margin-bottom: 4px;
			background: linear-gradient(45deg, #f39c12, #e67e22);
			color: white;
			text-decoration: none;
			font-weight: 600;
			text-align: center;
			transition: all 0.2s ease;
		}

		.fill-in-link-small:hover {
			background: linear-gradient(45deg, #e67e22, #d35400);
			transform: translateY(-1px);
			text-decoration: none;
			color: white;
		}

		/* Hidden detailed content by default */
		.segment-content {
			display: none; /* Hidden by default */
			max-height: 0;
			overflow: hidden;
			transition: all 0.3s ease;
		}


		/* Show detailed content when segment is expanded */
		.segment.expanded .segment-content {
			display: block;
			max-height: 800px;
		}


		/* Responsive design */
		@media (max-width: 768px) {
			.video-grid {
				grid-template-columns: 1fr;
				gap: 15px;
			}
			
			.video-card {
				min-height: 250px;
			}
			
			.video-embed {
				height: 100px;
			}
			
			.segment-words-inline {
				flex-direction: column;
				gap: 6px;
				align-items: stretch;
			}
			
			.word-display,
			.fill-in-link-small {
				width: 100%;
				text-align: center;
				margin-bottom: 2px;
			}
		}

		@media (min-width: 1200px) {
			.video-grid {
				grid-template-columns: repeat(3, 1fr);
			}
		}
	
	
	
	
	
	
	</style>
</head>

<body>
    <div class="connection-status" id="connectionStatus">
        <span id="statusText">Connecting...</span>
    </div>

    <div class="container">
        <div class="header">
            <div class="user-section">
                <div class="user-info" id="userInfo" style="display: none;">
                    Welcome, <span id="userName"></span>!
                </div>
                <button class="auth-button" id="authButton">
                    <img class="google-icon" src="https://developers.google.com/identity/images/g-logo.png" alt="Google logo">
                    Sign in with Google
                </button>
            </div>
         
			<!-- Admin button to open the modal -->
			<button id="adminUpdateButton" 
					style="display: none; position: fixed; top: 100px; right: 20px; background: #e74c3c; color: white; padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; z-index: 1001; font-weight: bold;">
				🔧 Admin: Add Words
			</button>
			
            <h1>🎤 Harry Mack Ratings Central</h1>
            <p>Rate Omegle Bars episodes with the global Harry Mack fan community!</p>
            <p style="font-size: 0.9rem; margin-top: 10px; opacity: 0.8;">
                ✨ Rate individual segments of Omegle Bars • View episode words • Add personal notes ✨
            </p>
        </div>


		<!-- ADMIN MODAL - UPDATED DYNAMIC STRUCTURE -->
		<div id="adminWordsModal" class="admin-modal">
			<div class="admin-modal-content">
				<div class="admin-modal-header">
					<h2 class="admin-modal-title">
						<span>🛠️</span>
						Add Words to Episode
					</h2>
					<button class="admin-close-btn" onclick="closeAdminModal()">&times;</button>
				</div>

				<div class="admin-success-message" id="adminSuccessMessage">
					<span>✅</span>
					<span id="successText">Words added successfully!</span>
				</div>

				<div class="admin-error-message" id="adminErrorMessage">
					<span>❌</span>
					<span id="errorText">Error adding words</span>
				</div>

				<div class="admin-info-message" id="adminInfoMessage">
					<span>ℹ️</span>
					<span id="infoText">Info message.</span>
				</div>


				<form id="adminWordsForm" onsubmit="submitAdminWords(event)">
				
				
				 
					<div class="admin-form-group" style="margin-bottom: 30px;">
						<label for="adminEpisode" style="font-size: 1.1rem; font-weight: 700;">Episode Number</label>
						<select class="admin-form-control" id="adminEpisode" required onchange="loadExistingWords()">
							<option value="">Select Episode...</option>
						</select>
						<div style="font-size: 0.8rem; color: #6c757d; margin-top: 5px;">
							💡 Selecting an episode will pre-fill existing words from the database
						</div>
					</div>


					<!-- Dynamic Segment Blocks will be inserted here by JavaScript -->
					<div id="adminSegmentsContainer">
						<!-- Content will be rendered by renderAdminForm() -->
					</div>

					<!-- Global Add/Remove Segment Buttons -->
					<div style="display: flex; gap: 10px; justify-content: center; margin-bottom: 20px;">
						<button type="button" class="admin-btn" style="background: #3498db; color: white; padding: 10px 20px; border-radius: 8px;" onclick="addSegment()">
							+ Add Segment
						</button>
						<button type="button" class="admin-btn" style="background: #e74c3c; color: white; padding: 10px 20px; border-radius: 8px;" onclick="removeLastSegment()">
							- Remove Last Segment
						</button>
					</div>

					<div class="admin-form-actions" style="margin-top: 30px;">
						<button type="button" class="admin-btn admin-btn-secondary" onclick="clearForm()">
							🗑️ Clear All
						</button>
						<button type="button" class="admin-btn admin-btn-secondary" onclick="closeAdminModal()">
							❌ Close
						</button>
						<button type="submit" class="admin-btn admin-btn-primary" id="adminSubmitBtn" style="flex: 1;">
							<span>💾</span>
							Save All Words
						</button>
					</div>
					
					<div style="margin-top: 15px; text-align: center;">
						<button type="button" class="admin-btn" style="background: #9b59b6; color: white;" onclick="goToNextEpisode()">
							➡️ Save & Go to Next Episode
						</button>
					</div>
				</form>
			</div>
		</div>
	
	
	
		<div class="platform-intro">
			<div class="intro-content">
				<div class="intro-badge">
					🎉 <span>WORLD'S FIRST</span>
				</div>
				<h2 class="intro-title">Centralized Harry Mack Rating Platform</h2>
				<p class="intro-description">
					Starting with the Omegle Bars series! 
				</p>
				<div class="intro-features">
					<div class="feature-item">
						<div class="feature-icon">⭐</div>
						<span>Discover the best episodes through community ratings</span>
					</div>
					<div class="feature-item">
						<div class="feature-icon">🔍</div>
						<span>Find episodes by improvised words</span>
					</div>
					<div class="feature-item">
						<div class="feature-icon">💬</div>
						<span>Rate your favorites</span>
					</div>
					<div class="feature-item">
						<div class="feature-icon">🏗️</div>
						<span>Help fill out the words database</span>
					</div>
				</div>
			</div>
		</div>

 
		
		<div class="filter-section">
			<div class="filter-controls">
				<label>Sort by:</label>
				<select id="sortFilter">
					<option value="episode">Episode Number</option>
					<option value="overall">Overall Rating</option>
					<option value="lyrics">Lyrics Rating</option>
					<option value="beats">Beats Rating</option>
					<option value="reaction">Reaction Rating</option>
				</select>
				
				<label>Min Rating:</label>
				<select id="ratingFilter">
					<option value="0">All Videos</option>
					<option value="3">3+ Stars</option>
					<option value="4">4+ Stars</option>
					<option value="5">5 Stars Only</option>
				</select>

				<input type="text" id="searchFilter" placeholder="Search by words or episode...">

			</div>
		</div>

		

        <div id="loadingMessage" class="loading">
            Loading Harry Mack videos and community ratings...
        </div>

        <div class="video-grid" id="videoGrid" style="display: none;">
        </div>

        <div class="stats-bar" id="statsBar" style="display: none;">
            <h3 style="margin-bottom: 20px;">Global Community Stats</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-number" id="totalRatings">0</div>
                    <div class="stat-label">Total Ratings</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="avgOverall">0.0</div>
                    <div class="stat-label">Avg Overall Rating</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="activeUsers">0</div>
                    <div class="stat-label">Community Members</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="topEpisode">#--</div>
                    <div class="stat-label">Highest Rated Episode</div>
                </div>
            </div>
        </div>
    </div>

	<div class="disclaimer-banner">
		<p><strong>Disclaimer:</strong> This is an independent fan-created rating platform. We are not affiliated with, endorsed by, or connected to Harry Mack or his representatives. All content is for educational and commentary purposes under Fair Use.</p>
	</div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-app-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-auth-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-firestore-compat.min.js"></script>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBUtq7jUntXqH0C0V2fDR1fwh2yPoZJAls",
            authDomain: "harry-mack-community.firebaseapp.com",
            projectId: "harry-mack-community",
            storageBucket: "harry-mack-community.firebasestorage.app",
            messagingSenderId: "1035009511388",
            appId: "1:1035009511388:web:23b2e932da2ac74466c919"
        };

        let app, auth, db;
        let currentUser = null;
        let isSigningIn = false;
        let videos = [];
        let userRatings = {};


        let realtimeUpdateTimeout = null; // Add this to debounce real-time updates
		let userNotes = {};
		let isSavingNote = false;
		let editingNotes = {};
		let isSubmittingRating = false; 
		let isCompactView = false;
		
		// Note configuration
		const MAX_NOTE_LENGTH = 1000;
				
        // Default ratings structure
        const defaultRatings = {
            lyrics: { average: 3.0, count: 0 },
            beats: { average: 3.0, count: 0 },
            reaction: { average: 3.0, count: 0 },
            overall: { average: 3.0, count: 0 }
        };

        // Debug mode flag
        const DEBUG_EPISODE_2 = true;

        // Global array to hold the mutable segment data for the admin form
        let currentEpisodeSegmentsForAdmin = [];
		
		
		// Individual segment expansion functionality
		function toggleSegment(videoId, segmentId) {
			if (!currentUser) {
				showSignInPrompt('rate segments', 0);
				return;
			}

			const segment = document.querySelector(`[data-segment="${segmentId}"]`);
			const button = segment.querySelector('.rate-this-btn');
			
			// Check if this segment is currently expanded
			const isExpanded = segment.classList.contains('expanded');
			
			// First, collapse all segments in this video
			const videoContainer = document.querySelector(`[data-video="${videoId}"]`);
			if (videoContainer) {
				videoContainer.querySelectorAll('.segment').forEach(seg => {
					seg.classList.remove('expanded');
					const btn = seg.querySelector('.rate-this-btn');
					if (btn) {
						btn.textContent = '📊 Rate this!';
						btn.classList.remove('expanded');
					}
				});
			}
			
			// If the clicked segment wasn't expanded, expand it
			if (!isExpanded) {
				segment.classList.add('expanded');
				button.textContent = '📋 Hide ratings';
				button.classList.add('expanded');
				console.log(`📊 Expanded Segment ${videoId}-${segmentId}`);
				
				// Re-attach event listeners for rating stars in this segment
				setTimeout(() => {
					const stars = segment.querySelectorAll('.stars .star');
					stars.forEach(star => {
						star.addEventListener('click', handleStarClick);
						star.addEventListener('mouseenter', handleStarHover);
						star.addEventListener('mouseleave', handleStarLeave);
					});
					updateUserRatingDisplay();
				}, 100);
			} else {
				console.log(`📦 Collapsed Segment ${videoId}-${segmentId}`);
			}
		}

	

		function convertWordsObjectToArray(wordsData) {
			console.log('🔍 Converting words data for display:', JSON.stringify(wordsData, null, 2));
			
			if (!wordsData) {
				return [
					[{word: 'word1', votes: 5, voters: []}],
					[{word: 'word2', votes: 5, voters: []}],
					[{word: 'word3', votes: 5, voters: []}]
				];
			}

			// If it's already the correct format (array of arrays), return as-is
			if (Array.isArray(wordsData) && wordsData.length > 0 && Array.isArray(wordsData[0])) {
				console.log('✅ Already in correct array format for display');
				return wordsData;
			}

			// Handle Firebase object format (e.g., { "0": [{...}], "1": [{...}] })
			if (typeof wordsData === 'object' && !Array.isArray(wordsData)) {
				console.log('🔄 Converting from Firebase object format for display');
				const result = [];
				
				// ✅ FIXED: Sort object keys numerically to maintain word order
				const sortedKeys = Object.keys(wordsData).sort((a, b) => parseInt(a) - parseInt(b));
				
				sortedKeys.forEach(positionKey => {
					const wordPosition = wordsData[positionKey];
					const candidates = [];
					
					if (Array.isArray(wordPosition)) { // Expecting an array of candidates
						wordPosition.forEach(candidate => {
							if (candidate && candidate.word && typeof candidate.word === 'string') {
								candidates.push({
									word: candidate.word,
									votes: candidate.votes || 1,
									voters: []
								});
							}
						});
					} else if (wordPosition && typeof wordPosition === 'object' && wordPosition.word) {
						// Fallback for single candidate object (less common but good to handle)
						candidates.push({
							word: wordPosition.word,
							votes: wordPosition.votes || 1,
							voters: []
						});
					}
					
					// Ensure at least one candidate for the word position if none were found
					if (candidates.length === 0) {
						candidates.push({word: `word${result.length + 1}`, votes: 1, voters: []});
					}
					
					result.push(candidates);
				});
				
				console.log(`✅ Converted to array format showing ${result.length} words in correct order`);
				return result;
			}

			// Fallback for completely unknown format
			console.log('⚠️ Unknown format, creating defaults for display');
			return [
				[{word: 'word1', votes: 5, voters: []}],
				[{word: 'word2', votes: 5, voters: []}],
				[{word: 'word3', votes: 5, voters: []}]
			];
		}


		function sanitizeSegmentData(segment, videoId, segmentIndex) {
			console.log(`🔧 Sanitizing segment data for ${videoId}-${segmentIndex} (for display):`, segment);
			
			const sanitized = {
				id: segment?.id || `segment_${videoId}_${segmentIndex + 1}`,
				ratings: segment?.ratings || { ...defaultRatings },
				words: []
			};

			if (segment?.words) {
				console.log(`🔄 Processing words for ${videoId}-${segmentIndex} (for display)`);
				try {
					sanitized.words = convertWordsObjectToArray(segment.words);
					

					// Show all words (no artificial limit)
					console.log(`✅ Words processed for ${videoId}-${segmentIndex}, showing ${sanitized.words.length} words`);
					
					
				} catch (conversionError) {
					console.warn(`⚠️ Error converting words for ${videoId}-${segmentIndex} (for display):`, conversionError);
					sanitized.words = [
						[{word: 'word1', votes: 5, voters: []}],
						[{word: 'word2', votes: 5, voters: []}],
						[{word: 'word3', votes: 5, voters: []}]
					];
				}
			} else {
				console.warn(`⚠️ No words found for ${videoId}-${segmentIndex}, creating default for display`);
				sanitized.words = [
					[{word: 'word1', votes: 5, voters: []}],
					[{word: 'word2', votes: 5, voters: []}],
					[{word: 'word3', votes: 5, voters: []}]
				];
			}

			console.log(`✅ Sanitized segment for ${videoId}-${segmentIndex} (for display):`, sanitized);
			return sanitized;
		}


      

        // NEW: Calculate weighted video ratings from segment ratings
        function calculateVideoOverallRating(video) {
            console.log(`🧮 Calculating weighted video rating for Episode ${video.episodeNumber}`);
            
            if (!video.segments || video.segments.length === 0) {
                console.log('⚠️ No segments found, using default ratings');
                return { ...defaultRatings };
            }

            const categories = ['lyrics', 'beats', 'reaction', 'overall'];
            const videoRatings = {};

            categories.forEach(category => {
                let totalWeightedScore = 0;
                let totalRatingCount = 0;

                // Sum up weighted scores from all segments
                video.segments.forEach(segment => {
                    if (segment.ratings && segment.ratings[category]) {
                        const segmentRating = segment.ratings[category];
                        const average = segmentRating.average || 0;
                        const count = segmentRating.count || 0;
                        
                        totalWeightedScore += (average * count);
                        totalRatingCount += count;
                    }
                });

                // Calculate weighted average
                const weightedAverage = totalRatingCount > 0 ? totalWeightedScore / totalRatingCount : 0;
                
                videoRatings[category] = {
                    average: Math.max(0, Math.min(5, weightedAverage)), // Clamp between 0-5
                    count: totalRatingCount
                };

                console.log(`📊 ${category}: ${weightedAverage.toFixed(2)}★ (${totalRatingCount} total ratings)`);
            });

            return videoRatings;
        }

        // NEW: Update video rating and refresh UI
        function updateVideoRatingDisplay(video) {
            console.log(`🎨 Updating video rating display for Episode ${video.episodeNumber}`);
            
            // Find the video card in the DOM
            const videoCards = document.querySelectorAll('.video-card');
            let targetCard = null;
            
            videoCards.forEach(card => {
                const starsElement = card.querySelector(`[data-video="${video.episodeNumber}"]`);
                if (starsElement && starsElement.dataset.video === video.episodeNumber.toString()) {
                    targetCard = card;
                }
            });

            if (!targetCard) {
                console.log('⚠️ Video card not found in DOM');
                return;
            }

            // Update the overall rating display
            // This section was causing issues, simplified it to find by data-category and data-video
            ['lyrics', 'beats', 'reaction', 'overall'].forEach(category => {
                const ratingCategoryDiv = targetCard.querySelector(`.overall-rating .rating-category .stars[data-category="${category}"]`);
                if (ratingCategoryDiv) {
                    const videoRating = video.ratings[category]?.average || 0;
                    const videoCount = video.ratings[category]?.count || 0;

                    // Update the average/count text
                    const ratingStatsSpan = ratingCategoryDiv.closest('.rating-controls').previousElementSibling.querySelector('.rating-stats');
                    if (ratingStatsSpan) {
                        ratingStatsSpan.textContent = `${videoRating.toFixed(1)}★ (${videoCount} ratings)`;
                    }

                    // Update the star display
                    updateStarDisplay(ratingCategoryDiv, videoRating, false); // false because this is overall video rating
                }
            });

            console.log(`✅ Updated display: ${video.ratings.overall.average.toFixed(1)}★ (${video.ratings.overall.count} ratings)`);
        }


		function generateDefaultSegments() {
			console.log('🔧 Generating exactly 3 default segments...');
			const wordBank = ["pizza", "galaxy", "thunderstorm", "basketball", "dragon", "coffee"];
			const segments = [];
			
			// Always create exactly 3 segments
			for (let j = 0; j < 3; j++) {
				const segmentWords = [];
				
				// Always generate exactly 3 words per segment
				for (let k = 0; k < 3; k++) {
					const candidateWords = [];
					const baseWord = wordBank[Math.floor(Math.random() * wordBank.length)];
					
					candidateWords.push({
						word: baseWord,
						votes: Math.floor(Math.random() * 10) + 5,
						voters: []
					});
					
					segmentWords.push(candidateWords);
				}
				
				segments.push({
					id: `default_segment_${j + 1}`,
					words: segmentWords,
					ratings: { ...defaultRatings }
				});
			}
			
			console.log(`✅ Generated exactly ${segments.length} segments`);
			return segments;
		}

		function ensureProperSegments(segments, episodeNumber) {
			console.log(`🔧 Processing ${segments.length} segments for Episode ${episodeNumber} (showing all)`);
			
			// Don't truncate - return all segments as-is
			return segments;
		}



		// NEW FUNCTION: Generates empty segments for display, if an episode has no segments in DB
		function generateEmptySegments(episodeNumber) {
			const segments = [];
			
			// Create exactly 3 empty segments for display
			for (let j = 0; j < 3; j++) {
				const segmentWords = [];
				
				// Create exactly 3 empty word slots per segment for display
				for (let k = 0; k < 3; k++) {
					segmentWords.push([]); // Empty array = no words = will show fill-in
				}
				
				segments.push({
					id: `segment_${episodeNumber}_${j + 1}`,
					words: segmentWords,
					ratings: { ...defaultRatings }
				});
			}
			
			return segments;
		}
 
        async function initializeFirebase() {
            try {
                console.log('🔥 Initializing Firebase...');
                app = firebase.initializeApp(firebaseConfig);
                auth = firebase.auth();
                db = firebase.firestore();
                
                console.log('✅ Firebase services initialized');
                console.log('🔒 Setting auth persistence...');
                
                await auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);
                console.log('✅ Auth persistence set');
                
                console.log('🔄 Checking for redirect result...');
                try {
                    const result = await auth.getRedirectResult();
                    console.log('🔄 Redirect result:', result);
                    
                    if (result.user) {
                        console.log('👤 User signed in via redirect:', result.user.email);
                        showNotification(`Welcome ${result.user.displayName || result.user.email}! You're now signed in.`, 'success');
                        handleAuthStateChange(result.user);
                    } else if (result.credential) {
                        console.log('🔑 Got credential but no user - possible error');
                    } else {
                        console.log('ℹ️ No redirect result - normal page load');
                    }
                } catch (redirectError) {
                    console.error('❌ Redirect error:', redirectError);
                    console.error('❌ Error code:', redirectError.code);
                    console.error('❌ Error message:', redirectError.message);
                    
                    if (redirectError.code === 'auth/unauthorized-domain') {
                        showNotification('This domain is not authorized. Please add it to Firebase.', 'error');
                    } else if (redirectError.code !== 'auth/redirect-cancelled-by-user') {
                        showNotification(`Sign in failed: ${redirectError.message}`, 'error');
                    }
                }

                auth.onAuthStateChanged((user) => {
                    console.log('🔄 Auth state changed:', user ? user.email : 'No user');
                    if (user) {
                        isSigningIn = false;
                    }
                    handleAuthStateChange(user);
                });
                
                const currentUser = auth.currentUser;
                console.log('👤 Current user on init:', currentUser ? currentUser.email : 'None');
                
                // Test Firestore permissions
                console.log('🧪 Testing Firestore read permissions...');
                try {
                    await db.collection('videos').limit(1).get();
                    console.log('✅ Firestore read permission confirmed');
                } catch (permError) {
                    console.error('❌ Firestore permission error:', permError);
                    throw permError;
                }
                
                console.log('📊 Starting to load videos data...');
                loadVideosData();
                updateConnectionStatus('connected');
                
            } catch (error) {
                console.error('❌ Firebase initialization failed:', error);
                console.error('❌ Error details:', error.message, error.code);
                handleFirebaseError();
            }
        }

        function handleFirebaseError() {
            updateConnectionStatus('demo');
            showNotification('Running in demo mode.  Log in to rate videos!', 'info');
            initializeDemoMode();
        }

        function initializeDemoMode() {
            generateSampleVideos();
            renderVideos();
            updateStats();
            
            document.getElementById('loadingMessage').style.display = 'none';
            document.getElementById('videoGrid').style.display = 'grid';
            document.getElementById('statsBar').style.display = 'block';
        }

        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            
            statusElement.className = 'connection-status status-' + status;
            
            switch(status) {
                case 'connected':
                    statusText.textContent = '🟢 Live';
                    break;
                case 'disconnected':
                    statusText.textContent = '🔴 Offline';
                    break;
                case 'demo':
                    statusText.textContent = '🟡 Demo Mode';
                    break;
                case 'connecting':
                    statusText.textContent = '🟡 Loading...';
                    break;
            }
        }

 
		function handleAuthStateChange(user) {
			currentUser = user;
			
			const userInfo = document.getElementById('userInfo');
			const userName = document.getElementById('userName');
			const authButton = document.getElementById('authButton');

			if (user) {
				userInfo.style.display = 'block';
				userName.textContent = user.displayName || user.email;
				authButton.innerHTML = 'Sign Out';
				authButton.onclick = signOut;
				
				loadUserRatings();
				loadUserNotes(); 
				
				if (db) updateConnectionStatus('connected');
				
				checkAdminAccess();
				
				// ADD THIS: Force re-render when user signs in to show real vs demo data
				if (videos.length > 0) {
					console.log('🔄 User signed in - refreshing video display');
					renderVideos(); // This will re-evaluate word display logic
				}
				
			} else {
				userInfo.style.display = 'none';
				authButton.innerHTML = '<img class="google-icon" src="https://developers.google.com/identity/images/g-logo.png" alt="Google logo">Sign in with Google';
				authButton.onclick = signIn;
				userRatings = {};
				userNotes = {};
				editingNotes = {};
				
				checkAdminAccess();
				
				// Also refresh when user signs out
				if (videos.length > 0) {
					console.log('🔄 User signed out - refreshing video display');
					renderVideos();
				}
			}
		}

 

        async function signIn() {
            if (!auth) {
                showNotification('Authentication not available in demo mode', 'info');
                return;
            }
            
            if (isSigningIn) {
                console.log('Sign-in already in progress');
                return;
            }
            
            console.log('Sign in button clicked');
            console.log('Current URL:', window.location.href);
            console.log('Auth domain:', firebaseConfig.authDomain);
            
            const provider = new firebase.auth.GoogleAuthProvider();
            provider.addScope('profile');
            provider.addScope('email');
            
            try {
                isSigningIn = true;
                console.log('Starting popup sign in...');
                showNotification('Opening Google sign-in popup...', 'info');
                
                const result = await auth.signInWithPopup(provider);
                
                console.log('Sign in successful:', result.user);
                showNotification('Successfully signed in!', 'success');
                
            } catch (error) {
                console.error('Sign in error:', error);
                
                if (error.code === 'auth/operation-not-allowed') {
                    showNotification('Google sign-in is not enabled in Firebase Console', 'error');
                } else if (error.code === 'auth/unauthorized-domain') {
                    showNotification('This domain is not authorized in Firebase', 'error');
                } else if (error.code === 'auth/popup-closed-by-user') {
                    showNotification('Sign-in popup was closed. Please try again.', 'info');
                } else if (error.code === 'auth/popup-blocked') {
                    showNotification('Sign-in popup was blocked by browser. Please allow popups and try again.', 'error');
                } else if (error.code === 'auth/cancelled-popup-request') {
                    showNotification('Another sign-in popup is already open. Please complete that first.', 'info');
                } else {
                    showNotification(`Sign in failed: ${error.message}`, 'error');
                }
            } finally {
                isSigningIn = false;
            }
        }

        async function signOut() {
            if (auth) {
                try {
                    await auth.signOut();
                    showNotification('You have been signed out.', 'info');
                } catch (error) {
                    console.error('Sign out error:', error);
                    showNotification('Error signing out. Please try again.', 'error');
                }
            }
        }

		async function loadVideosData() {
			try {

				if (!db) {
					console.error('❌ DEBUGGING: db is null/undefined');
					console.error('❌ auth state:', auth ? 'exists' : 'null');
					console.error('❌ app state:', app ? 'exists' : 'null');
					console.log('No database connection - using demo mode');
					initializeDemoMode();
					return;
				}
				console.log('✅ Database connected, loading videos from Firebase...');
				console.log('📊 Querying videos collection...');
				
				const videosSnapshot = await db.collection('videos').orderBy('episodeNumber').get();
				console.log('📋 Query completed. Documents found:', videosSnapshot.size);
				
				if (videosSnapshot.empty) {
					console.log('📝 No videos found - creating empty structure...');
					// Create minimal structure without demo words for all users
					videos = [];
					for (let i = 1; i <= 110; i++) {
						videos.push({
							episodeNumber: i,
							title: `Omegle Bars Episode #${i}`,
							youtubeId: getYouTubeId(i),
							segments: generateEmptySegments(i), // No demo words for display
							ratings: { ...defaultRatings }
						});
					}
				} else {
					console.log('📖 Loading existing videos from Firebase...');
					videos = [];
					
					videosSnapshot.docs.forEach(doc => {
						const data = doc.data();
						console.log(`📄 Processing video: Episode ${data.episodeNumber}`);
						
						if (data.episodeNumber === 2 && DEBUG_EPISODE_2) {
							console.log('🔍 EPISODE 2 DEBUG - Raw data:', JSON.stringify(data, null, 2));
						}

						let processedSegments = [];
 
						// Handle all episodes the same way regardless of user auth
						if (data.segments && Array.isArray(data.segments)) {
							console.log(`✅ Valid segments array with ${data.segments.length} items`);
							let tempSegments = data.segments.map((segment, idx) => 
								sanitizeSegmentData(segment, data.episodeNumber, idx)
							);

							processedSegments = ensureProperSegments(tempSegments, data.episodeNumber);
						} else if (data.segments && typeof data.segments === 'object') {
							console.log(`🔄 Converting segments object to array`);
							
							// ✅ FIXED: Sort segments by their ID to maintain proper order
							const sortedSegmentEntries = Object.entries(data.segments).sort((a, b) => {
								// Extract segment numbers from IDs like "segment_1_1", "segment_1_2", etc.
								const aNum = parseInt(a[0].split('_').pop());
								const bNum = parseInt(b[0].split('_').pop());
								return aNum - bNum;
							});
							
							// Now map the sorted segments
							let tempSegments = sortedSegmentEntries.map(([segmentId, segment], idx) => 
								sanitizeSegmentData(segment, data.episodeNumber, idx)
							);

							processedSegments = ensureProperSegments(tempSegments, data.episodeNumber);
							
						} else {
							console.log(`⚠️ No valid segments found for Episode ${data.episodeNumber}`);
							// Always create empty segments (no demo words for anyone) for display
							processedSegments = generateEmptySegments(data.episodeNumber);
						}		

						const processedVideo = {
							id: doc.id,
							episodeNumber: data.episodeNumber,
							title: data.title || `Omegle Bars Episode #${data.episodeNumber}`,
							youtubeId: getYouTubeId(data.episodeNumber),
							segments: processedSegments,
							ratings: data.ratings || { ...defaultRatings }
						};
						
						// 🔥 NEW: Recalculate video ratings from segments (in case stored ratings are outdated)
						if (processedSegments.length > 0) {
							console.log(`🔄 Recalculating video ratings for Episode ${data.episodeNumber}`);
							processedVideo.ratings = calculateVideoOverallRating(processedVideo);
						}
						
						videos.push(processedVideo);
						console.log(`✅ Processed Episode ${data.episodeNumber} with ${processedSegments.length} segments for display`);
					});
					
					console.log(`✅ Successfully loaded ${videos.length} videos`);
				}
				
				console.log('🎨 Starting to render videos...');
				try {
					renderVideos();
					updateStats();
					document.getElementById('loadingMessage').style.display = 'none';
					document.getElementById('videoGrid').style.display = 'grid';
					document.getElementById('statsBar').style.display = 'block';
					updateConnectionStatus('connected');
					console.log('✅ Videos loaded and rendered successfully!');
				} catch (renderError) {
					console.error('❌ Error during rendering (keeping loaded data):', renderError);
					showNotification('Error rendering videos. Data loaded but display may be incomplete.', 'error');
					
					document.getElementById('loadingMessage').style.display = 'none';
					document.getElementById('videoGrid').style.display = 'grid';
					document.getElementById('statsBar').style.display = 'block';
					updateConnectionStatus('connected');
				}
				
			} catch (error) {
				console.error('❌ Error loading videos:', error);
				showNotification('Error loading videos. Using demo data.', 'error');
				initializeDemoMode();
			}
		}
		
		
		
		
		
        async function initializeFirebaseData() {
            console.log('🚀 Starting to generate sample videos...');
            const sampleVideos = generateSampleVideos();
            console.log(`📊 Generated ${sampleVideos.length} sample videos`);
            
            if (db) {
                try {
                    console.log('💾 Saving sample data to Firebase...');
                    const batch = db.batch();
                    sampleVideos.forEach((video, index) => {
                        const docRef = db.collection('videos').doc(`episode_${video.episodeNumber}`);
                        // Convert segments to Firestore object format for saving
                        const segmentsObject = {};
                        video.segments.forEach(seg => {
                            const wordsObject = {};
                            seg.words.forEach((wordCandidates, idx) => {
                                wordsObject[idx.toString()] = wordCandidates;
                            });
                            segmentsObject[seg.id] = { ...seg, words: wordsObject };
                        });
                        batch.set(docRef, { ...video, segments: segmentsObject });
                        if (index < 3) {
                            console.log(`📄 Preparing to save Episode ${video.episodeNumber}:`, video.title);
                        }
                    });
                    
                    console.log('⏳ Committing batch write to Firebase...');
                    await batch.commit();
                    console.log('✅ Sample data saved to Firebase successfully!');
                } catch (batchError) {
                    console.error('❌ Error saving to Firebase:', batchError);
                    throw batchError;
                }
            } else {
                console.log('⚠️ No database connection - keeping data in memory only');
            }
            
            videos = sampleVideos;
            console.log(`✅ Videos array populated with ${videos.length} items`);
        }

        function getYouTubeId(episodeNumber) {
            const youtubeIds = [
                'NPdKxsSE5JQ',  // Episode 1
                'BgCUCg9aMyA',  // Episode 2
                '37duQAUSYXo',  // Episode 3
                'jrNapeXr3TY',  // Episode 4
                'Gh7Wbix9UwY',  // Episode 5
                'dwFhTq5x0Tc',  // Episode 6
                '75j7pEjRAIQ',  // Episode 7
                'O6ve-5b_x5U',  // Episode 8
                'oxuUDgOdoRw',  // Episode 9
                '7GAuu0Ro9PM',  // Episode 10
                'Rqv6oiyddn8',  // Episode 11
                'hZcpRm80EBk',  // Episode 12
                '6c5Y47TYQWQ',  // Episode 13
                'Ap4dVD_CRm8',  // Episode 14
                'lt0r0JNDeeo',  // Episode 15
                'XTfaaoBRjvs',  // Episode 16
                'QwnqI4dyPI8',  // Episode 17
                'VBBMfHGMs7I',  // Episode 18
                'EWThDBgYj9U',  // Episode 19
                'Tf84L54lSTE',  // Episode 20
                're1sJCcYZy4',  // Episode 21
                '3Y-0TUj1amk',  // Episode 22
                'JeRZWJ7NMGU',  // Episode 23
                'ZC6kl6ohAjo',  // Episode 24
                '1kN6LAf_7eg',  // Episode 25
                'U6dbmuCfdyk',  // Episode 26
                'dlnQOB15Sq8',  // Episode 27
                'ZOhE4fUduUU',  // Episode 28
                '2JHSSISCVww',  // Episode 29
                'vtjdWxFcOc4',  // Episode 30
                'fP4SftKI4LQ',  // Episode 31
                'Z3FjhBuFKyM',  // Episode 32
                'p-GYLYqpTP8',  // Episode 33
                'PPS8RLQkw04',  // Episode 34
                'YPLX5YpSMfI',  // Episode 35
                'QaD5-e6hjmY',  // Episode 36
                '1XZJKKNopEw',  // Episode 37
                'eStSbs0PklY',  // Episode 38
                'dkcnYy_VjRc',  // Episode 39
                '4dMm3q1rldE',  // Episode 40
                '25ceuw4CuK8',  // Episode 41
                'wy6qazFc2FQ',  // Episode 42
                'oXI3ysg3s3s',  // Episode 43
                'UlIzq76NZJA',  // Episode 44
                'OBM1UVnsQQo',  // Episode 45
                'KSc0UuBLRhg',  // Episode 46
                'n1K9P5Dtph4',  // Episode 47
                '5yTm4j6KaBQ',  // Episode 48
                '1dfh0G8Ik1c',  // Episode 49
                '-pRhkKkM2Ms',  // Episode 50
                'mwWw-1t3hyw',  // Episode 51
                '3ZhcM7-bh4c',  // Episode 52
                'Js2Q8tJLgig',  // Episode 53
                'eX9uZQoXAdY',  // Episode 54
                'AYc7Q6CSeGE',  // Episode 55
                'Djm0fwEX9ls',  // Episode 56
                'UI2qbARbQEw',  // Episode 57
                'sfFpAz8ZHVg',  // Episode 58
                'CKnUOb6My5Y',  // Episode 59
                'BbcTwW_aKxI',  // Episode 60
                'I0ng6LIjAOg',  // Episode 61
                'g25N4i6leas',  // Episode 62
                'abuAR-yoWSU',  // Episode 63
                'izM7RQctoPc',  // Episode 64
                'BNC68gQluSE',  // Episode 65
                'TJk3eDFwiaY',  // Episode 66
                'FxLKfWt3Kq4',  // Episode 67
                'QaRkdWCTKkM',  // Episode 68
                'O9AxmMO9xKw',  // Episode 69
                'AO0yvg0pLiM',  // Episode 70
                'qQKgwgWzg58',  // Episode 71
                'xqCEjV48TWA',  // Episode 72
                'SnJpkJ0or5o',  // Episode 73
                '2kfaZHwzda8',  // Episode 74
                '4yeyJVkbX8Y',  // Episode 75
                'Xm8Z4bGH_Ok',  // Episode 76
                'yxb2mb4wkF4',  // Episode 77
                'NKtwLntS4Pg',  // Episode 78
                'MiU7GJYeTas',  // Episode 79
                'TwRATtm76cI',  // Episode 80
                'bt0DLDPVE1M',  // Episode 81
                '6Phbw1vg5Wc',  // Episode 82
                '16xwgMHig-A',  // Episode 83
                'REllMQ6EQi8',  // Episode 84
                '6mfIBMQMYTw',  // Episode 85
                'gBgJRYcIcWA',  // Episode 86
                'WG0ZmvMYVrM',  // Episode 87
                'cXKJ3uv_XIk',  // Episode 88
                '_SZbXNGBWGk',  // Episode 89 
                'uhiwj4ho4V4',  // Episode 90
                'qG37EIdryFo',  // Episode 91
                'hr6sqlk73AI',  // Episode 92
                'rjBtpTI0MAc',  // Episode 93
                'bJgAtUirT7I',  // Episode 94
                '1suTTTUn7iA',  // Episode 95
                'TFaKz7SQsgg',  // Episode 96
                'qlfHCE9nl34',  // Episode 97
                'vL4W6n--r5A',  // Episode 98
                '-70WqAfeEYE',  // Episode 99
                'ijVGIcVRIbk',  // Episode 100
                '6sYh6iuMUA8',  // Episode 101
                'elpFOcnxTZY',  // Episode 102
                'sfAjqVYDISQ',  // Episode 103
                'BXFq6Y1iW7k',  // Episode 104
                'E6dqj45rjlE',  // Episode 105
                '2bMkeJ6Vu2s',  // Episode 106
                'HuCyL-QEIhQ',  // Episode 107
                '6u8Yt12uZnk',  // Episode 108
                'dfAQMcKqxM0',  // Episode 109
                'jSZmrM-1qpw'   // Episode 110
            ];
            
            const index = episodeNumber - 1;
            
            if (index >= 0 && index < youtubeIds.length) {
                return youtubeIds[index];
            }
            
            return youtubeIds[index % youtubeIds.length];
        }


		function generateSampleVideos() {
			const wordBank = [
				"pizza", "galaxy", "thunderstorm", "basketball", "dragon", "coffee",
				"telephone", "rainbow", "adventure", "elephant", "computer", "sunshine",
				"bicycle", "ocean", "chocolate", "butterfly", "mountain", "music",
				"spaceship", "burger", "lightning", "guitar", "forest", "diamond",
				"robot", "sunset", "library", "airplane", "wizard", "sandwich",
				"telescope", "volcano", "penguin", "keyboard", "tornado", "ice cream"
			];

			const sampleVideos = [];
			
			for (let i = 1; i <= 100; i++) {
				const segments = [];
				
				
				
				// Always create exactly 3 segments per video for sample data
				for (let j = 0; j < 3; j++) {
					const segmentWords = [];
					
					// Always create exactly 3 words per segment for sample data
					for (let k = 0; k < 3; k++) {
						const candidateWords = [];
						
						const baseWordIndex = Math.floor(Math.random() * wordBank.length);
						const baseWord = wordBank[baseWordIndex];
						
						// Just create one word per position (no alternatives)
						candidateWords.push({
							word: baseWord,
							votes: Math.floor(Math.random() * 15) + 10,
							voters: []
						});
						
						segmentWords.push(candidateWords);
					}
					
					const lyrics = Math.random() * 2 + 3;
					const beats = Math.random() * 2 + 3;
					const reaction = Math.random() * 2 + 3;
					const overall = (lyrics + beats + reaction) / 3 + (Math.random() * 0.6 - 0.3);
					
					const baseRatingCount = Math.floor(Math.random() * 50) + 5;
					
					segments.push({
						id: `segment_${i}_${j + 1}`,
						words: segmentWords,
						ratings: {
							lyrics: { 
								average: Math.max(1, Math.min(5, lyrics)),
								count: baseRatingCount + Math.floor(Math.random() * 10) 
							},
							beats: { 
								average: Math.max(1, Math.min(5, beats)), 
								count: baseRatingCount + Math.floor(Math.random() * 12) 
							},
							reaction: { 
								average: Math.max(1, Math.min(5, reaction)), 
								count: baseRatingCount + Math.floor(Math.random() * 15) 
							},
							overall: { 
								average: Math.max(1, Math.min(5, overall)), 
								count: baseRatingCount + Math.floor(Math.random() * 8) 
							}
						}
					});
				}

				// Calculate video ratings from the 3 segments
				const videoLyrics = segments.reduce((sum, seg) => sum + seg.ratings.lyrics.average, 0) / 3;
				const videoBeats = segments.reduce((sum, seg) => sum + seg.ratings.beats.average, 0) / 3;
				const videoReaction = segments.reduce((sum, seg) => sum + seg.ratings.reaction.average, 0) / 3;
				const videoOverall = segments.reduce((sum, seg) => sum + seg.ratings.overall.average, 0) / 3;
				
				const totalSegmentRatings = segments.reduce((sum, seg) => 
					sum + seg.ratings.lyrics.count + seg.ratings.beats.count + seg.ratings.reaction.count + seg.ratings.overall.count, 0);

				const video = {
					episodeNumber: i,
					title: `Omegle Bars Episode #${i}`,
					youtubeId: getYouTubeId(i),
					segments: segments, // Always exactly 3 segments for sample data
					ratings: {
						lyrics: { 
							average: videoLyrics,
							count: Math.floor(totalSegmentRatings * 0.25) 
						},
						beats: { 
							average: videoBeats, 
							count: Math.floor(totalSegmentRatings * 0.25) 
						},
						reaction: { 
							average: videoReaction, 
							count: Math.floor(totalSegmentRatings * 0.25) 
						},
						overall: { 
							average: videoOverall, 
							count: Math.floor(totalSegmentRatings * 0.25) 
						}
					}
				};

				sampleVideos.push(video);
			}
			
			videos = sampleVideos;
			console.log(`✅ Generated ${sampleVideos.length} videos with exactly 3 segments each`);
			return sampleVideos;
		}

        

        async function loadUserRatings() {
            if (!currentUser || !db) return;

            try {
                const ratingsSnapshot = await db.collection('userRatings')
                    .where('userId', '==', currentUser.uid)
                    .get();
                
                userRatings = {};
                
                ratingsSnapshot.docs.forEach(doc => {
                    const data = doc.data();
                    if (data.segmentId) {
                        if (!userRatings[data.videoId]) {
                            userRatings[data.videoId] = { segments: {} };
                        }
                        userRatings[data.videoId].segments[data.segmentId] = data.ratings;
                    } else {
                        if (!userRatings[data.videoId]) {
                            userRatings[data.videoId] = {};
                        }
                        userRatings[data.videoId].video = data.ratings;
                    }
                });
                
                updateUserRatingDisplay();
                
            } catch (error) {
                console.error('Error loading user ratings:', error);
            }
        }
 
         
		 
		 function updateUserRatingDisplay() {
			setTimeout(() => {
				Object.keys(userRatings).forEach(videoId => {
					if (userRatings[videoId].segments) {
						Object.keys(userRatings[videoId].segments).forEach(segmentId => {
							const segmentRatings = userRatings[videoId].segments[segmentId];
							const categories = ['lyrics', 'beats', 'reaction', 'overall'];
							
							categories.forEach(category => {
								const rating = segmentRatings[category];
								const starsContainer = document.querySelector(`[data-video="${videoId}"][data-segment="${segmentId}"][data-category="${category}"]`)?.closest('.stars');
								if (starsContainer) {
									// Pass true for userRated only if they actually rated it
									updateStarDisplay(starsContainer, rating, rating > 0);
									
									const controls = starsContainer.closest('.rating-controls');
									if (controls) {
										// Remove existing indicator
										const existingIndicator = controls.querySelector('.user-rating-indicator');
										if (existingIndicator) {
											existingIndicator.remove();
										}
										
										// Add new indicator only if user has rated
										if (rating > 0) {
											const indicator = document.createElement('div');
											indicator.className = 'user-rating-indicator';
											indicator.textContent = `Your rating: ${rating}★`;
											controls.appendChild(indicator);
										}
									}
								}
							});
						});
					}
					
					if (userRatings[videoId].video) {
						const videoRatings = userRatings[videoId].video;
						const categories = ['lyrics', 'beats', 'reaction', 'overall'];
						
						categories.forEach(category => {
							const rating = videoRatings[category];
							const starsContainer = document.querySelector(`[data-video="${videoId}"][data-category="${category}"]:not([data-segment])`)?.closest('.stars');
							if (starsContainer) {
								// Pass true for userRated only if they actually rated it
								updateStarDisplay(starsContainer, rating, rating > 0);
								
								const controls = starsContainer.closest('.rating-controls');
								if (controls) {
									// Remove existing indicator
									const existingIndicator = controls.querySelector('.user-rating-indicator');
									if (existingIndicator) {
										existingIndicator.remove();
									}
									
									// Add new indicator only if user has rated
									if (rating > 0) {
										const indicator = document.createElement('div');
										indicator.className = 'user-rating-indicator';
										indicator.textContent = `Your rating: ${rating}★`;
										controls.appendChild(indicator);
									}
								}
							}
						});
					}
				});
			}, 100);
		}


		async function submitRating(videoId, category, rating, segmentId = null) {
			console.log(`🎯 Starting to submit rating: ${videoId}-${segmentId}-${category}-${rating}`);
 
			// Prevent multiple simultaneous rating submissions
			if (isSubmittingRating) {
				console.log('Already submitting a rating, please wait...');
				return;
			}
			
			isSubmittingRating = true; // SET FLAG TO PREVENT CONFLICTS
			
		
			try {
				// IMMEDIATE UI UPDATE - Update display first, before saving
				if (!userRatings[videoId]) {
					userRatings[videoId] = { segments: {} };
				}
				
				if (segmentId) {
					if (!userRatings[videoId].segments[segmentId]) {
						userRatings[videoId].segments[segmentId] = { lyrics: 0, beats: 0, reaction: 0, overall: 0 };
					}
					userRatings[videoId].segments[segmentId][category] = rating;
				} else {
					if (!userRatings[videoId].video) {
						userRatings[videoId].video = { lyrics: 0, beats: 0, reaction: 0, overall: 0 };
					}
					userRatings[videoId].video[category] = rating;
				}

				// IMMEDIATELY update the star display
				const starsContainer = segmentId ? 
					document.querySelector(`[data-video="${videoId}"][data-segment="${segmentId}"][data-category="${category}"]`)?.closest('.stars') :
					document.querySelector(`[data-video="${videoId}"][data-category="${category}"]:not([data-segment])`)?.closest('.stars');
				
				if (starsContainer) {
					updateStarDisplay(starsContainer, rating, true);
					
					// Update or add the "Your rating" indicator
					const controls = starsContainer.closest('.rating-controls');
					if (controls) {
						const existingIndicator = controls.querySelector('.user-rating-indicator');
						if (existingIndicator) {
							existingIndicator.textContent = `Your rating: ${rating}★`;
						} else {
							const indicator = document.createElement('div');
							indicator.className = 'user-rating-indicator';
							indicator.textContent = `Your rating: ${rating}★`;
							controls.appendChild(indicator);
						}
					}
				}

				// NOW save to Firebase (UI already updated)
				if (db) {
					const docId = segmentId ? 
						`${currentUser.uid}_${videoId}_${segmentId}` : 
						`${currentUser.uid}_${videoId}`;
					
					const ratingsData = {
						userId: currentUser.uid,
						videoId: videoId,
						ratings: segmentId ? userRatings[videoId].segments[segmentId] : userRatings[videoId].video,
						lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
					};
					
					if (segmentId) {
						ratingsData.segmentId = segmentId;
					}

					await db.collection('userRatings').doc(docId).set(ratingsData);
					//await updateVideoRating(videoId, category, rating, segmentId); // Removed as real-time updates will handle this
				}
				


				// Convert segment ID to display format with episode + segment letter
				let segmentText = '';
				if (segmentId) {
					// Find the video and segment to get the index
					const video = videos.find(v => v.episodeNumber.toString() === videoId);
					if (video && video.segments) {
						const segmentIndex = video.segments.findIndex(s => s.id === segmentId);
						if (segmentIndex !== -1) {
							const segmentLetter = String.fromCharCode(65 + segmentIndex); // 0→A, 1→B, 2→C
							segmentText = ` (Episode ${videoId}, Segment ${segmentLetter})`;
						} else {
							segmentText = ` (Episode ${videoId}, Segment ${segmentId})`; // Fallback to ID if not found
						}
					}
				} else {
					// For video-level ratings, just show episode
					segmentText = ` (Episode ${videoId})`;
				}

				showNotification(`Rated ${category}${segmentText}: ${rating} stars!`, 'success');
				
			} catch (error) {
				console.error('❌ RATING ERROR CAUGHT:', error);
				console.error('❌ ERROR DETAILS:', error.message);
				console.error('❌ ERROR STACK:', error.stack);
				console.error('Error submitting rating:', error);
				showNotification('Failed to save rating. Please try again.', 'error');
				
				// If save failed, revert the UI
				if (segmentId) {
					userRatings[videoId].segments[segmentId][category] = 0;
				} else {
					userRatings[videoId].video[category] = 0;
				}
				updateUserRatingDisplay();
				
			} finally {
				isSubmittingRating = false; // ALWAYS CLEAR FLAG WHEN DONE

					
			}
		}




        async function updateVideoRating(videoId, category, newRating, segmentId = null) {
            // This function is largely replaced by real-time updates from the main video collection
            // and the `calculateVideoOverallRating` function.
            // Keeping it here for reference or if a specific direct update is needed.
            console.warn("`updateVideoRating` called. This function's direct update logic is now handled by real-time updates from the main 'videos' collection.");
        }

        // NEW: handleStarClick function - captures rating and calls submitRating
        function handleStarClick(event) {
            if (!currentUser) {
                showSignInPrompt('rate videos', 0);
                return;
            }
            const star = event.target;
            const rating = parseInt(star.dataset.rating);
            const category = star.dataset.category;
            const videoId = star.dataset.video;
            const segmentId = star.dataset.segment; // This will be undefined for video-level ratings

            submitRating(videoId, category, rating, segmentId);
        }

        // NEW: handleStarHover function - visually highlights stars on hover
        function handleStarHover(event) {
            const star = event.target;
            const hoverRating = parseInt(star.dataset.rating);
            const starsContainer = star.closest('.stars');
            if (!starsContainer) return;

            starsContainer.querySelectorAll('.star').forEach((s, index) => {
                s.classList.remove('active-hover'); // Remove previous hover effects
                if (index < hoverRating) {
                    s.classList.add('active-hover');
                }
            });
        }

        // NEW: handleStarLeave function - reverts stars to show the actual rating after hover
        function handleStarLeave(event) {
            const starsContainer = event.target.closest('.stars');
            if (!starsContainer) return;
            starsContainer.querySelectorAll('.star').forEach(s => s.classList.remove('active-hover'));
            // Reapply the actual rating visual state
            const category = starsContainer.dataset.category;
            const videoId = starsContainer.dataset.video;
            const segmentId = starsContainer.dataset.segment;
            
            // Get the current displayed rating (either user's or community average)
            let currentDisplayRating = 0;
            const userRatedValue = segmentId ?
                (userRatings[videoId]?.segments?.[segmentId]?.[category] || 0) :
                (userRatings[videoId]?.video?.[category] || 0);

            if (currentUser && userRatedValue !== undefined && userRatedValue > 0) {
                currentDisplayRating = userRatedValue;
            } else {
                // Find the video and segment/video rating to get the community average
                const video = videos.find(v => v.episodeNumber.toString() === videoId);
                if (video) {
                    if (segmentId) {
                        const segment = video.segments.find(s => s.id === segmentId);
                        currentDisplayRating = segment?.ratings?.[category]?.average || 0;
                    } else {
                        currentDisplayRating = video.ratings?.[category]?.average || 0;
                    }
                }
            }
            updateStarDisplay(starsContainer, currentDisplayRating, currentUser && userRatedValue > 0);
        }
 
		// FIXED: createStarRating function - shows empty stars for unrated items when logged in
		function createStarRating(category, videoId, currentRating, ratingCount, segmentId = null) {
			let starsHtml = '';
			const userRatedValue = segmentId ? 
				(userRatings[videoId]?.segments?.[segmentId]?.[category] || 0) : 
				(userRatings[videoId]?.video?.[category] || 0);

			// Determine what rating to display visually
			let displayRating = 0;
			if (currentUser && userRatedValue > 0) {
				// User is logged in and has rated, display their rating
				displayRating = userRatedValue;
			} else {
				// User not logged in, or logged in but hasn't rated, display community average
				displayRating = currentRating;
			}

			// Create exactly 5 stars
			for (let i = 1; i <= 5; i++) {
				// For user ratings, show exact rating; for community ratings, round
				const shouldHighlight = (currentUser && userRatedValue > 0) ? 
					i <= userRatedValue : 
					i <= Math.round(displayRating);
				const activeClass = shouldHighlight ? 'active' : '';
				const userRatedClass = userRatedValue > 0 && i <= userRatedValue ? 'user-rated' : '';
				
				const dataAttrs = segmentId ? 
					`data-rating="${i}" data-category="${category}" data-video="${videoId}" data-segment="${segmentId}"` : 
					`data-rating="${i}" data-category="${category}" data-video="${videoId}"`;
					
				starsHtml += `<span class="star ${activeClass} ${userRatedClass}" ${dataAttrs}>★</span>`;
			}
			
			return starsHtml;
		}


		function createWordCandidatesHtml(wordCandidates, videoId, segmentId, wordIndex) {
			console.log(`🔍 Creating word display for ${videoId}-${segmentId}-${wordIndex}:`, wordCandidates);
			
			let validCandidates = [];
			
			// Check if we have valid word candidates
			if (Array.isArray(wordCandidates) && wordCandidates.length > 0) {
				validCandidates = wordCandidates.filter(candidate => 
					candidate && 
					candidate.word && 
					typeof candidate.word === 'string' && 
					candidate.word.trim() !== '' &&
					candidate.word.trim().toLowerCase() !== 'word1' &&
					candidate.word.trim().toLowerCase() !== 'word2' &&
					candidate.word.trim().toLowerCase() !== 'word3'
				);
			}
			
			// Sort by votes and get the top word
			validCandidates.sort((a, b) => (b.votes || 0) - (a.votes || 0));
			const topWord = validCandidates.length > 0 ? validCandidates[0] : null;
			
			if (topWord && topWord.word && topWord.word.trim() !== '') {
				console.log(`✅ Showing real word: "${topWord.word}"`);
				return `
					<div class="word-display word-real">
						<span class="word-text">${topWord.word}</span>
					</div>
				`;
			} else {
				console.log(`🔴 Showing fill-in button for missing word`);
				return `
					<div class="word-missing">
						<a href="#" class="fill-in-link" onclick="openGoogleSheet('${videoId}', '${segmentId}', ${wordIndex}); return false;">
							📝 fill-in
						</a>
					</div>
				`;
			}
		}

		function openGoogleSheet(videoId, segmentId, wordIndex) {
			console.log(`🔗 Opening Google Sheet for Episode ${videoId}, Segment ${getSegmentLetter(segmentId)}, Word ${wordIndex + 1}`);
			
			// Your Google Sheet URL - replace with your actual form URL
			const googleSheetURL = 'https://docs.google.com/spreadsheets/d/1bfHSHaBiX4pFljrVclEtwWMTXRJMoIKbpdHo1-x_ulw/edit?usp=sharing';
			
			// For better UX, you might want to create a Google Form instead of directly editing the sheet
			// const googleFormURL = 'https://docs.google.com/forms/d/e/YOUR_FORM_ID/viewform?usp=pp_url&entry.EPISODE_FIELD_ID=' + videoId + '&entry.SEGMENT_FIELD_ID=' + getSegmentLetter(segmentId) + '&entry.WORD_FIELD_ID=' + (wordIndex + 1);
			
			try {
				// Open in new tab
				window.open(googleSheetURL, '_blank');
				
				// Show detailed notification
				showNotification(
					`📝 Opening Google Sheet for Episode ${videoId}, Segment ${getSegmentLetter(segmentId)}, Word ${wordIndex + 1}. Please add the missing word!`, 
					'info'
				);
				
				// Optional: Track analytics or log usage
				console.log(`📊 Fill-in requested: Episode ${videoId}, Segment ${getSegmentLetter(segmentId)}, Word ${wordIndex + 1}`);
				
			} catch (error) {
				console.error('❌ Error opening Google Sheet:', error);
				showNotification('Error opening Google Sheet. Please try again.', 'error');
			}
		}		  

 
		

		// HELPER FUNCTION: Convert segment ID to letter (A, B, C)
		function getSegmentLetter(segmentId) {
			// Extract segment number from ID like "segment_1_1" -> 1 -> A
			const match = segmentId.match(/segment_\d+_(\d+)/);
			if (match) {
				const segmentNum = parseInt(match[1]) - 1; // Convert to 0-based index
				return String.fromCharCode(65 + segmentNum); // 0=A, 1=B, 2=C
			}
			return 'A'; // Fallback
		}

	


        // NOTES: Create the display HTML, must be placed before createSegmentHtml
        function createNoteDisplayHTML(videoId, segmentId, noteText) {
            const hasNote = noteText && noteText.trim();
            return `
                <div class="notes-display ${hasNote ? '' : 'empty'}">
                    ${hasNote ? noteText : 'Click "Add Note" to add your private notes for this segment...'}
                </div>
                <button class="notes-edit-btn" onclick="startEditingNote('${videoId}', '${segmentId}')">
                    ${hasNote ? 'Edit Note' : 'Add Note'}
                </button>
            `;
        }
		

		function createSegmentHtml(segment, videoId, segmentIndex) {
			console.log(`🔧 Creating segment HTML for ${videoId}-${segmentIndex} (for display):`, segment);
			
			try {
				const segmentId = segment.id || `fallback_segment_${segmentIndex}`;
				const segmentRatings = segment.ratings || defaultRatings;
				
				const avgRating = [
					segmentRatings.lyrics?.average || 0,
					segmentRatings.beats?.average || 0, 
					segmentRatings.reaction?.average || 0,
					segmentRatings.overall?.average || 0
				].reduce((sum, val) => sum + val, 0) / 4;
				
				// CREATE INLINE WORDS FOR HEADER (for display)
				let headerWordsHtml = '';
				if (segment.words && Array.isArray(segment.words)) {
					const wordDisplays = segment.words.map((wordCandidates, wordIndex) => {
						try {
							return createWordCandidatesHtml(wordCandidates, videoId, segmentId, wordIndex);
						} catch (wordError) {
							console.error(`❌ Error processing word ${wordIndex}:`, wordError);
							return `<div class="word-missing-inline"><a href="#" class="fill-in-link-small" onclick="openGoogleSheet('${videoId}', '${segmentId}', ${wordIndex})">📝 fill-in</a></div>`;
						}
					});
					
					headerWordsHtml = wordDisplays.join('');
				} else {
					console.log(`⚠️ No valid words array found in segment`);
					headerWordsHtml = `
						<div class="word-missing-inline"><a href="#" class="fill-in-link-small" onclick="openGoogleSheet('${videoId}', '${segmentId}', 0)">📝 fill-in</a></div>
						<div class="word-missing-inline"><a href="#" class="fill-in-link-small" onclick="openGoogleSheet('${videoId}', '${segmentId}', 1)">📝 fill-in</a></div>
						<div class="word-missing-inline"><a href="#" class="fill-in-link-small" onclick="openGoogleSheet('${videoId}', '${segmentId}', 2)">📝 fill-in</a></div>
					`;
				}

				// Get user's note for this segment
				const userNote = userNotes[videoId]?.[segmentId] || '';
				const hasNote = userNote && userNote.trim();
				
				return `
					<div class="segment" data-segment="${segmentId}">

						<div class="segment-header">
							<div class="segment-title-row">
								<span class="segment-name">Segment ${videoId}-${String.fromCharCode(65 + segmentIndex)}</span>
								<div class="segment-right-controls">
									<button class="rate-this-btn" onclick="toggleSegment('${videoId}', '${segmentId}')">
										📊 Rate this!
									</button>
									<span class="segment-rating-display">${avgRating.toFixed(1)}★</span>
								</div>
							</div>
							<div class="segment-words-inline">
								${headerWordsHtml}
							</div>
						</div>
						
						
						<div class="segment-content">
							<div class="segment-details">
								<div class="segment-ratings">
									<h5 style="color: #2c3e50; margin-bottom: 15px; font-size: 0.85rem;">Rate This Segment</h5>
									${['lyrics', 'beats', 'reaction', 'overall'].map(category => `
										<div class="rating-category">
											<div class="rating-info">
												<span class="rating-label">${category.charAt(0).toUpperCase() + category.slice(1)}</span>
												<span class="rating-stats">${(segmentRatings[category]?.average || 0).toFixed(1)}★ (${segmentRatings[category]?.count || 0} ratings)</span>
											</div>
											<div class="rating-controls">
												<div class="stars" data-category="${category}" data-video="${videoId}" data-segment="${segmentId}">
													${createStarRating(category, videoId, segmentRatings[category]?.average || 0, segmentRatings[category]?.count || 0, segmentId)}
												</div>
												${userRatings[videoId]?.segments?.[segmentId]?.[category] ? `<div class="user-rating-indicator">Your rating: ${userRatings[videoId].segments[segmentId][category]}★</div>` : ''}
											</div>
										</div>
									`).join('')}
								</div>
								
								<div class="notes-section" data-video="${videoId}" data-segment="${segmentId}">
									<div class="notes-header" onclick="toggleNotesSection('${videoId}', '${segmentId}')">
										<div class="notes-title">
											📝 My Notes
											${hasNote ? '<span style="color: #27ae60; font-size: 0.7rem; margin-left: 5px;">●</span>' : ''}
										</div>
										<div class="notes-expand-icon">▶</div>
									</div>
									<div class="notes-content">
										${createNoteDisplayHTML(videoId, segmentId, userNote)}
									</div>
								</div>
							</div>
						</div>
					</div>					
				`;
				
			} catch (error) {
				console.error(`❌ Error in createSegmentHtml for ${videoId}-${segmentIndex}:`, error);
				return `
					<div class="segment segment-error">
						<div class="segment-header">
							<div class="segment-info">
								<div class="segment-title">Segment ${videoId}-${String.fromCharCode(65 + segmentIndex)} (Error)</div>								
								<div class="segment-rating-summary">Unable to load</div>
							</div>
						</div>
					</div>
				`;
			}
		}

 
        
        function renderVideos() {
			console.log('🎨 RENDERVIDEOS CALLED!');
			console.trace(); 
	
            console.log('🎨 Starting renderVideos function...');

           
            console.log(`📊 Videos to render: ${videos.length}`);
            
            const videoGrid = document.getElementById('videoGrid');
            videoGrid.innerHTML = '';

            let filteredVideos = [...videos];
            console.log(`📋 Initial video count: ${filteredVideos.length}`);

            const sortFilter = document.getElementById('sortFilter').value;
            const ratingFilter = parseFloat(document.getElementById('ratingFilter').value);
            const searchFilter = document.getElementById('searchFilter').value.toLowerCase();

            console.log(`🔍 Filters - Sort: ${sortFilter}, Rating: ${ratingFilter}, Search: "${searchFilter}"`);

            if (ratingFilter > 0) {
                const beforeCount = filteredVideos.length;
                filteredVideos = filteredVideos.filter(video => video.ratings.overall.average >= ratingFilter);
                console.log(`📊 Rating filter: ${beforeCount} → ${filteredVideos.length} videos`);
            }

            if (searchFilter) {
                const beforeCount = filteredVideos.length;
                filteredVideos = filteredVideos.filter(video => {
                    try {
                        return video.title.toLowerCase().includes(searchFilter) ||
                               video.episodeNumber.toString().includes(searchFilter) ||
                               (video.segments && video.segments.some(segment =>
                                   segment.words && segment.words.some(wordCandidates => {
                                       if (Array.isArray(wordCandidates)) {
                                           return wordCandidates.some(candidate =>
                                               candidate && candidate.word && 
                                               candidate.word.toLowerCase().includes(searchFilter)
                                           );
                                       }
                                       return false;
                                   })
                               ));
                    } catch (searchError) {
                        console.error(`❌ Search error for video ${video.episodeNumber}:`, searchError);
                        return true; // Keep the video if there's an error processing its words
                    }
                });
                console.log(`🔍 Search filter: ${beforeCount} → ${filteredVideos.length} videos`);
            }

            filteredVideos.sort((a, b) => {
                if (sortFilter === 'episode') {
                    return a.episodeNumber - b.episodeNumber;
                } else {
                    return b.ratings[sortFilter].average - a.ratings[sortFilter].average;
                }
            });
            console.log(`📊 Sorted ${filteredVideos.length} videos by ${sortFilter}`);

            let successCount = 0;
            let errorCount = 0;
            
            filteredVideos.forEach((video, index) => {
                try {
                    console.log(`🎬 Rendering video ${index + 1}/${filteredVideos.length}: Episode ${video.episodeNumber}`);
                    
                    const videoCard = document.createElement('div');
                    videoCard.className = 'video-card';
                    
                    let segmentsHtml = '';
                    // The `video.segments` here is already sanitized by `loadVideosData` for DISPLAY,
                    // ensuring 3 segments and 3 words per segment.
                    if (video.segments && Array.isArray(video.segments)) {
                        console.log(`📦 Processing ${video.segments.length} segments for Episode ${video.episodeNumber} (for display)`);
                        try {
                            segmentsHtml = video.segments.map((segment, segIndex) => {
                                try {
                                    return createSegmentHtml(segment, video.episodeNumber, segIndex);
                                } catch (segmentError) {
                                    console.error(`❌ Error rendering segment ${segIndex} for Episode ${video.episodeNumber}:`, segmentError);
                                    return `<div class="segment-error">Error loading segment ${String.fromCharCode(65 + segIndex)}</div>`;
                                }
                            }).join('');
                        } catch (segmentsError) {
                            console.error(`❌ Error processing segments for Episode ${video.episodeNumber}:`, segmentsError);
                            segmentsHtml = '<div class="segments-error">Error loading segments</div>';
                        }
                    } else {
                        console.log(`⚠️ No valid segments for Episode ${video.episodeNumber}`);
                        segmentsHtml = '<div class="no-segments">No segments available</div>';
                    }
                    
                    videoCard.innerHTML = `
                        <div class="video-embed" style="position: relative; cursor: pointer; background-image: url('https://img.youtube.com/vi/${video.youtubeId}/maxresdefault.jpg'); background-size: cover; background-position: center;" onclick="window.open('https://www.youtube.com/watch?v=${video.youtubeId}', '_blank')">
                            <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center;">
                                <div style="text-align: center; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">
                                    <div style="font-size: 4rem; margin-bottom: 10px;">▶️</div>
                                    <div style="font-size: 1.1rem; font-weight: bold;">Episode #${video.episodeNumber}</div>
                                    <div style="font-size: 0.9rem; opacity: 0.9;">Click to watch on YouTube</div>
                                </div>
                            </div>
                        </div>
   					 

						<div class="video-content">
							<h3 class="video-title">${video.title}</h3>
							
							
							<div class="segments-section">
								
                                <div class="segments-container" data-video="${video.episodeNumber}">
                                    ${segmentsHtml}
                                </div>
                            </div>
                        </div>
                    `;
                    videoGrid.appendChild(videoCard);
                    successCount++;
                    
                } catch (videoError) {
                    console.error(`❌ Error rendering video ${video.episodeNumber}:`, videoError);
                    console.error(`❌ Video error details:`, videoError.message);
                    errorCount++;
                    
                    const errorCard = document.createElement('div');
                    errorCard.className = 'video-card';
                    errorCard.innerHTML = `
                        <div class="video-content">
                            <h3 class="video-title">Episode #${video.episodeNumber} (Error)</h3>
                            <p>Error loading this episode. Please try refreshing.</p>
                        </div>
                    `;
                    videoGrid.appendChild(errorCard);
                }
            });

            console.log(`✅ Rendering complete: ${successCount} success, ${errorCount} errors`);

            try {
                document.querySelectorAll('.stars').forEach(starsContainer => { // Changed from .star to .stars
                    starsContainer.querySelectorAll('.star').forEach(star => {
                        star.addEventListener('click', handleStarClick);
                        star.addEventListener('mouseenter', handleStarHover);
                        star.addEventListener('mouseleave', handleStarLeave);
                    });
                });
                console.log('✅ Star rating event listeners attached');
            } catch (eventError) {
                console.error('❌ Error attaching event listeners:', eventError);
            }

            try {
                updateUserRatingDisplay();
                console.log('✅ User rating display updated');
            } catch (displayError) {
                console.error('❌ Error updating user rating display:', displayError);
            }
  

        }


		function updateStarDisplay(starsContainer, rating, userRated = false) {
			const stars = starsContainer.querySelectorAll('.star');
			
			// Determine what to show based on login status and user rating
			let displayRating = 0;
			const category = starsContainer.dataset.category;
			const videoId = starsContainer.dataset.video;
			const segmentId = starsContainer.dataset.segment;

			const userCurrentRating = segmentId ?
				userRatings[videoId]?.segments?.[segmentId]?.[category] :
				userRatings[videoId]?.video?.[category];

			if (currentUser && userCurrentRating !== undefined && userCurrentRating > 0) {
				// User is logged in and has rated, display their rating
				displayRating = userCurrentRating;
			} else {
				// User not logged in, or logged in but hasn't rated, display community average
				displayRating = rating;
			}
			
			stars.forEach((star, index) => {
				star.classList.remove('active', 'user-rated');
				// For user ratings, show exact rating; for community ratings, round
				const shouldHighlight = (currentUser && userCurrentRating > 0) ? 
					index < userCurrentRating : 
					index < Math.round(displayRating);
				if (shouldHighlight) {
					star.classList.add('active');
				}
				if (currentUser && userCurrentRating > 0 && index < userCurrentRating) {
					star.classList.add('user-rated');
				}
			});
		}


 
        
        function showNotification(message, type) {
            // Remove any existing notifications first
            document.querySelectorAll('.notification').forEach(n => n.remove());

            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

		// New info message function for admin modal
		function showInfoMessage(text) {
			hideMessages(); // Hide other messages first
			const infoMsg = document.getElementById('adminInfoMessage');
			document.getElementById('infoText').textContent = text;
			infoMsg.style.display = 'flex';
			setTimeout(hideMessages, 5000); // Auto-hide after 5 seconds
		}


		function updateStats() {
			let totalRatings = 0;
			let totalOverallRating = 0;
			let overallRatingCount = 0;
			let maxOverallRating = 0;
			let topEpisode = '#--';

			videos.forEach(video => {
				if (video.ratings.overall.count > 0) {
					totalOverallRating += video.ratings.overall.average * video.ratings.overall.count;
					overallRatingCount += video.ratings.overall.count;
				}

				if (video.segments) {
					video.segments.forEach(segment => {
						if (segment.ratings) {
							Object.values(segment.ratings).forEach(rating => {
								totalRatings += rating.count;
							});
						}
					});
				}
				
				if (video.ratings.overall.average > maxOverallRating) {
					maxOverallRating = video.ratings.overall.average;
					topEpisode = `#${video.episodeNumber}`;
				}
			});

			document.getElementById('totalRatings').textContent = totalRatings;
			document.getElementById('avgOverall').textContent = overallRatingCount > 0 ? (totalOverallRating / overallRatingCount).toFixed(1) : '0.0';
			document.getElementById('activeUsers').textContent = Object.keys(userRatings).length;
			document.getElementById('topEpisode').textContent = topEpisode;
		}





        function showSignInPrompt(action, delay = 0) {
            setTimeout(() => {
                showNotification(`Please sign in to ${action}.`, 'info');
            }, delay);
        }

        function init() {
            updateConnectionStatus('connecting');
            
            initializeFirebase();
            
            document.getElementById('sortFilter').addEventListener('change', applyFilters);
            document.getElementById('ratingFilter').addEventListener('change', applyFilters);
            document.getElementById('searchFilter').addEventListener('input', applyFilters);
            
            setupRealtimeUpdates();
        
            document.getElementById('authButton').addEventListener('click', () => {
                if (currentUser) {
                    signOut();
                } else {
                    signIn();
                }
            });


            // NEW: Attach event listener for the admin button after DOM is loaded
            const adminUpdateButton = document.getElementById('adminUpdateButton');
            if (adminUpdateButton) {
                adminUpdateButton.addEventListener('click', openAdminModal);
            }
        }

		function applyFilters() {
			console.log('🔄 APPLYFILTERS CALLED!');
			console.trace(); 

			renderVideos();

		}


		function setupRealtimeUpdates() {
			if (!db) return;
			
			db.collection('videos').onSnapshot((snapshot) => {
				if (realtimeUpdateTimeout) {
					clearTimeout(realtimeUpdateTimeout);
				}

				// Only process if user is not actively saving notes or submitting ratings
				if (!isSavingNote && !isSubmittingRating && snapshot.docChanges().length > 0) {
					console.log('📡 Real-time update received, processing changes...');
					

					
					let hasChanges = false;
					snapshot.docChanges().forEach((change) => {
						const updatedVideo = { id: change.doc.id, ...change.doc.data() };
						const index = videos.findIndex(v => v.episodeNumber === updatedVideo.episodeNumber);

						if (change.type === 'added') {
							if (index === -1) {
								let processedSegments = [];
								if (updatedVideo.segments && typeof updatedVideo.segments === 'object') {
									// Convert object to array for internal processing
									const segmentValues = Object.values(updatedVideo.segments);
									processedSegments = segmentValues.map((segment, idx) => sanitizeSegmentData(segment, updatedVideo.episodeNumber, idx));
								} else {
									processedSegments = generateEmptySegments(updatedVideo.episodeNumber);
								}

								updatedVideo.segments = ensureProperSegments(processedSegments, updatedVideo.episodeNumber);
								updatedVideo.ratings = calculateVideoOverallRating(updatedVideo); // Recalculate ratings
								videos.push(updatedVideo);
								hasChanges = true;
							}
						} else if (change.type === 'modified') {
							if (index !== -1) {
								let processedSegments = [];
								if (updatedVideo.segments && typeof updatedVideo.segments === 'object') {
									const segmentValues = Object.values(updatedVideo.segments);
									processedSegments = segmentValues.map((segment, idx) => sanitizeSegmentData(segment, updatedVideo.episodeNumber, idx));
								} else {
									processedSegments = generateEmptySegments(updatedVideo.episodeNumber);
								}
								updatedVideo.segments = ensureExactly3Segments(processedSegments, updatedVideo.episodeNumber);
								updatedVideo.ratings = calculateVideoOverallRating(updatedVideo); // Recalculate ratings
								videos[index] = updatedVideo;
								hasChanges = true;
							}
						} else if (change.type === 'removed') {
							if (index !== -1) {
								videos.splice(index, 1);
								hasChanges = true;
							}
						}
					});
					
					if (hasChanges) {
						realtimeUpdateTimeout = setTimeout(() => {
							console.log('🔄 Applying real-time updates to UI...');
							applyFilters();
							updateStats();
							
						
							
						}, 1000); // Reduced debounce time for faster updates
					}
				} else if (isSavingNote || isSubmittingRating) {
					console.log('⏸️ Skipping real-time update - user operation in progress');
				}
			});
		}

       // ===== ADD ALL THE NOTES FUNCTIONS HERE ===== 
        
        // NOTES: Load user notes from Firebase
        async function loadUserNotes() {
            if (!currentUser || !db) return;

            try {
                console.log('📝 Loading user notes...');
                const notesSnapshot = await db.collection('userNotes')
                    .where('userId', '==', currentUser.uid)
                    .get();
                
                userNotes = {};
                
                notesSnapshot.docs.forEach(doc => {
                    const data = doc.data();
                    if (!userNotes[data.videoId]) {
                        userNotes[data.videoId] = {};
                    }
                    userNotes[data.videoId][data.segmentId] = data.noteText;
                });
                
                console.log(`✅ Loaded ${notesSnapshot.size} notes`);
                updateNotesDisplay();
                
            } catch (error) {
                console.error('❌ Error loading user notes:', error);
            }
        }

        // NOTES: Update notes display in DOM (without re-rendering)
        function updateNotesDisplay() {
            setTimeout(() => {
                Object.keys(userNotes).forEach(videoId => {
                    Object.keys(userNotes[videoId]).forEach(segmentId => {
                        const noteText = userNotes[videoId][segmentId];
                        updateNoteInDOM(videoId, segmentId, noteText);
                    });
                });
            }, 100);
        }

        // NOTES: Update a specific note in the DOM without re-rendering
        function updateNoteInDOM(videoId, segmentId, noteText) {
            const notesDisplay = document.querySelector(
                `.segments-container[data-video="${videoId}"] .segment[data-segment="${segmentId}"] .notes-display`
            );
            
            if (notesDisplay) {
                if (noteText && noteText.trim()) {
                    notesDisplay.textContent = noteText;
                    notesDisplay.classList.remove('empty');
                } else {
                    notesDisplay.textContent = 'Click "Edit" to add your private notes for this segment...';
                    notesDisplay.classList.add('empty');
                }
				// Update the '📝 My Notes' indicator
				const notesSection = notesDisplay.closest('.notes-section');
				if (notesSection) {
					const notesTitle = notesSection.querySelector('.notes-title');
					if (notesTitle) {
						let indicator = notesTitle.querySelector('span[style*="color: #27ae60"]');
						if (noteText && noteText.trim()) {
							if (!indicator) {
								indicator = document.createElement('span');
								indicator.style.cssText = 'color: #27ae60; font-size: 0.7rem; margin-left: 5px;';
								indicator.textContent = '●';
								notesTitle.appendChild(indicator);
							}
						} else {
							if (indicator) {
								indicator.remove();
							}
						}
					}
				}
            }
        }

        // NOTES: Toggle notes section expansion
        function toggleNotesSection(videoId, segmentId) {
            const notesSection = document.querySelector(
                `.segments-container[data-video="${videoId}"] .segment[data-segment="${segmentId}"] .notes-section`
            );
            
            if (notesSection) {
                notesSection.classList.toggle('expanded');
            }
        }

        // NOTES: Start editing a note
        function startEditingNote(videoId, segmentId) {
            if (!currentUser) {
                showSignInPrompt('add notes', 0);
                return;
            }

            const editKey = `${videoId}_${segmentId}`;
            if (editingNotes[editKey]) {
                console.log('Already editing this note');
                return;
            }

            console.log(`📝 Starting to edit note for ${videoId}-${segmentId}`);
            
            const segmentElement = document.querySelector(
                `.segments-container[data-video="${videoId}"] .segment[data-segment="${segmentId}"]`
            );
            
            if (!segmentElement) return;

            const notesContent = segmentElement.querySelector('.notes-content');
            const currentNote = userNotes[videoId]?.[segmentId] || '';
            
            // Set editing flag
            editingNotes[editKey] = true;
            
            // Replace display with edit form
            notesContent.innerHTML = createNoteEditForm(videoId, segmentId, currentNote);
            
            // Focus on textarea
            const textarea = notesContent.querySelector('.notes-textarea');
            if (textarea) {
                textarea.focus();
                textarea.setSelectionRange(textarea.value.length, textarea.value.length);
                updateCharCount(videoId, segmentId); // Initialize char count
            }
        }

        // NOTES: Create the edit form HTML
        function createNoteEditForm(videoId, segmentId, currentNote) {
            return `
                <div class="notes-edit-form">
                    <textarea class="notes-textarea" placeholder="Add your private notes for this segment..." maxlength="${MAX_NOTE_LENGTH}" data-video="${videoId}" data-segment="${segmentId}" oninput="updateCharCount('${videoId}', '${segmentId}')">${currentNote}</textarea>
                    <div class="notes-char-count" id="charCount_${videoId}_${segmentId}">
                        ${currentNote.length}/${MAX_NOTE_LENGTH}
                    </div>
                    <div class="notes-actions">
                        <button class="notes-cancel-btn" onclick="cancelEditingNote('${videoId}', '${segmentId}')">
                            Cancel
                        </button>
                        <button class="notes-save-btn" onclick="saveNote('${videoId}', '${segmentId}')" id="saveBtn_${videoId}_${segmentId}">
                            Save Note
                        </button>
                    </div>
                </div>
            `;
        }



        // NOTES: Update character count
        function updateCharCount(videoId, segmentId) {
            const textarea = document.querySelector(`[data-video="${videoId}"][data-segment="${segmentId}"].notes-textarea`);
            const charCountElement = document.getElementById(`charCount_${videoId}_${segmentId}`);
            
            if (textarea && charCountElement) {
                const length = textarea.value.length;
                charCountElement.textContent = `${length}/${MAX_NOTE_LENGTH}`;
                
                // Update styling based on length
                charCountElement.classList.remove('warning', 'error');
                if (length > MAX_NOTE_LENGTH * 0.9) {
                    charCountElement.classList.add('warning');
                }
                if (length >= MAX_NOTE_LENGTH) {
                    charCountElement.classList.add('error');
                }
                
                // Enable/disable save button
                const saveBtn = document.getElementById(`saveBtn_${videoId}_${segmentId}`);
                if (saveBtn) {
                    saveBtn.disabled = length > MAX_NOTE_LENGTH;
                }
            }
        }


        // NOTES: Save note
        async function saveNote(videoId, segmentId) {
            if (!currentUser) {
                showSignInPrompt('save notes', 0);
                return;
            }
            
            if (isSavingNote) {
                console.log('Already saving a note');
                return;
            }

            const editKey = `${videoId}_${segmentId}`;
            isSavingNote = true;
            
            try {
                const textarea = document.querySelector(`[data-video="${videoId}"][data-segment="${segmentId}"].notes-textarea`);
                if (!textarea) return;
                
                const noteText = textarea.value.trim();
                const saveBtn = document.getElementById(`saveBtn_${videoId}_${segmentId}`);
                
                if (saveBtn) {
                    saveBtn.disabled = true;
                    saveBtn.textContent = 'Saving...';
                }
                
                console.log(`💾 Saving note for ${videoId}-${segmentId}:`, noteText);

                // Update local data
                if (!userNotes[videoId]) {
                    userNotes[videoId] = {};
                }
                userNotes[videoId][segmentId] = noteText;

                // Save to Firebase
                if (db) {
                    const noteDocId = `${currentUser.uid}_${videoId}_${segmentId}`;
                    
                    if (noteText) {
                        await db.collection('userNotes').doc(noteDocId).set({
                            userId: currentUser.uid,
                            videoId: videoId,
                            segmentId: segmentId,
                            noteText: noteText,
                            lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    } else {
                        // Delete empty notes
                        await db.collection('userNotes').doc(noteDocId).delete();
                    }
                }

                // Update UI to display mode
                const notesContent = document.querySelector(
                    `.segments-container[data-video="${videoId}"] .segment[data-segment="${segmentId}"] .notes-content`
                );
                
                if (notesContent) {
                    notesContent.innerHTML = createNoteDisplayHTML(videoId, segmentId, noteText);
                }

                // Clear editing flag
                delete editingNotes[editKey];

                showNotification(noteText ? 'Note saved!' : 'Note deleted!', 'success');
                
            } catch (error) {
                console.error('❌ Error saving note:', error);
                showNotification('Failed to save note. Please try again.', 'error');
            } finally {
                isSavingNote = false;
            }
        }

        // NOTES: Cancel editing
        function cancelEditingNote(videoId, segmentId) {
            const editKey = `${videoId}_${segmentId}`;
            const currentNote = userNotes[videoId]?.[segmentId] || '';
            
            const notesContent = document.querySelector(
                `.segments-container[data-video="${videoId}"] .segment[data-segment="${segmentId}"] .notes-content`
            );
            
            if (notesContent) {
                notesContent.innerHTML = createNoteDisplayHTML(videoId, segmentId, currentNote);
            }
            
            // Clear editing flag
            delete editingNotes[editKey];
        }

        // ===== END NOTES FUNCTIONS =====
		
		// This function is for bulk updating words from a predefined list,
		// not directly related to the new dynamic admin form for manual input.
		async function bulkUpdateWords() {
			if (!currentUser || !db) {
				alert('Please sign in first');
				return;
			}
			
			const wordUpdates = {
				// Example: Episode 11 - Replace these with the actual words from Harry Mack's video
				11: {
					segment_11_1: ['sandwich', 'flags', 'table'],
					segment_11_2: ['penguin', 'Philadelphia', 'Steve'], 
					segment_11_3: ['phone', 'crush', 'car']
				},
				// Add more episodes here...
			};
			
			try {
				console.log('Starting bulk word update...');
				const batch = db.batch();
				
				Object.keys(wordUpdates).forEach(episodeNum => {
					const docRef = db.collection('videos').doc(`episode_${episodeNum}`);
					const segments = {};
					
					Object.keys(wordUpdates[episodeNum]).forEach(segmentId => {
						const words = wordUpdates[episodeNum][segmentId];
						
						// Convert words array to Firebase-compatible format (object with numeric keys)
						const wordsObject = {};
						words.forEach((word, index) => {
							wordsObject[index.toString()] = [{  // Store as an array of candidates (even if just one)
								word: word,
								votes: Math.floor(Math.random() * 20) + 5,
								voters: []
							}];
						});
						
						segments[segmentId] = {
							id: segmentId,
							words: wordsObject,  // Now it's an object, not nested arrays
							ratings: {
								lyrics: { average: 3.5 + Math.random(), count: 15 },
								beats: { average: 3.8 + Math.random(), count: 18 },
								reaction: { average: 3.2 + Math.random(), count: 12 },
								overall: { average: 3.5 + Math.random(), count: 14 }
							}
						};
					});
					
					batch.update(docRef, { segments });
				});
				
				await batch.commit();
				alert('Words updated successfully!');
				console.log('Bulk update complete!');
				location.reload(); // Refresh to see changes
				
			} catch (error) {
				console.error('Error updating words:', error);
				alert('Error updating words: ' + error.message);
			}
		}


		// Check if current user is admin and show/hide admin features
		function checkAdminAccess() {
			const adminButton = document.getElementById('adminUpdateButton');
			
			if (currentUser && currentUser.email === 'mathewmit@gmail.com') { // Replace with actual admin email
				// Show admin button
				if (adminButton) {
					adminButton.style.display = 'block';
				}
				console.log('🔐 Admin access granted');
			} else {
				// Hide admin button
				if (adminButton) {
					adminButton.style.display = 'none';
				}
				console.log('🚫 Admin access denied');
			}
		}

		
		function loadExistingWords() {
			console.log('🐛 DEBUG: loadExistingWords() called!');
			const episodeNum = document.getElementById('adminEpisode').value;
			console.log('🐛 DEBUG: Selected episode:', episodeNum);

			if (!episodeNum) {
				// Reset to default 3 empty segments when no episode selected
				currentEpisodeSegmentsForAdmin = generateInitialEmptySegmentsForAdmin('TBD');
				renderAdminForm();
				return;
			}

			console.log(`📖 Loading existing words for Episode ${episodeNum}...`);

			// Find the episode in our videos array
			const episode = videos.find(v => v.episodeNumber.toString() === episodeNum);
			
			// ✅ ALWAYS start with 3 empty segments, then populate with existing data if available
			currentEpisodeSegmentsForAdmin = [];
			
			// Create exactly 3 segments for the admin form
			for (let segIndex = 0; segIndex < 3; segIndex++) {
				const adminSegment = {
					id: `segment_${episodeNum}_${segIndex + 1}`,
					words: []
				};

				// If episode exists and has this segment, try to load its words
				let existingSegment = null;
				if (episode && episode.segments && episode.segments[segIndex]) {
					existingSegment = episode.segments[segIndex];
					console.log(`🔍 Found existing segment ${segIndex}:`, existingSegment);
				}

				// Process words for this segment (3 words minimum)
				for (let wordIndex = 0; wordIndex < 3; wordIndex++) {
					let bestWord = '';
					
					// Try to get existing word from this position
					if (existingSegment && existingSegment.words && Array.isArray(existingSegment.words)) {
						const wordCandidates = existingSegment.words[wordIndex];
						if (Array.isArray(wordCandidates) && wordCandidates.length > 0) {
							// Sort by votes and take the top one
							const sortedCandidates = [...wordCandidates].sort((a, b) => (b.votes || 0) - (a.votes || 0));
							bestWord = sortedCandidates[0].word || '';
						}
					}
					
					// Add the word (or empty slot) to admin segment
					if (bestWord && bestWord.trim() !== '') {
						adminSegment.words.push([{ word: bestWord, votes: 1, voters: [] }]);
						console.log(`✅ Loaded word ${wordIndex + 1} for segment ${segIndex + 1}: "${bestWord}"`);
					} else {
						adminSegment.words.push([]);
						console.log(`📝 Empty word slot ${wordIndex + 1} for segment ${segIndex + 1}`);
					}
				}

				currentEpisodeSegmentsForAdmin.push(adminSegment);
			}

			console.log(`✅ Created admin form with exactly ${currentEpisodeSegmentsForAdmin.length} segments`);

			// Show appropriate message
			const hasExistingWords = currentEpisodeSegmentsForAdmin.some(segment => 
				segment.words.some(wordArray => wordArray.length > 0 && wordArray[0].word)
			);

			if (hasExistingWords) {
				showInfoMessage(`Loaded Episode ${episodeNum} with existing words. You can edit or add more words.`);
			} else {
				showInfoMessage(`Episode ${episodeNum} has no words yet. Starting with 3 empty segments - add words below.`);
			}

			// Re-render the form with the loaded/created data
			renderAdminForm();
			
			console.log('🐛 DEBUG: Final currentEpisodeSegmentsForAdmin:', currentEpisodeSegmentsForAdmin);
		}
		
		
		



		// Enhanced Admin Modal Functions (new dynamic logic)

		// Helper to generate initial empty segments for admin form
		function generateInitialEmptySegmentsForAdmin(episodeNum) {
			const segments = [];
			for (let i = 0; i < 3; i++) { // Start with 3 segments
				segments.push({
					id: episodeNum === 'TBD' ? `segment_TBD_${i + 1}` : `segment_${episodeNum}_${i + 1}`,
					words: generateInitialEmptyWordsForAdmin() // Each with 3 empty word slots
				});
			}
			return segments;
		}

		// Helper to generate initial empty words for admin form
		function generateInitialEmptyWordsForAdmin() {
			const words = [];
			for (let i = 0; i < 3; i++) { // Start with 3 words
				words.push([]); // Empty array means no candidates, will show blank input
			}
			return words;
		}


		function renderAdminForm() {
			const segmentsContainer = document.getElementById('adminSegmentsContainer');
			if (!segmentsContainer) {
				console.error('Admin segments container not found!');
				return;
			}
			segmentsContainer.innerHTML = ''; // Clear existing content

			const episodeNum = document.getElementById('adminEpisode').value;

			if (!episodeNum) {
				// Show helpful message when no episode is selected
				segmentsContainer.innerHTML = `
					<div style="text-align: center; padding: 40px; color: #6c757d; background: #f8f9fa; border-radius: 10px; border: 2px dashed #dee2e6;">
						<h3 style="color: #495057; margin-bottom: 15px;">📋 Select an Episode</h3>
						<p style="margin-bottom: 0;">Choose an episode from the dropdown above to load existing words or start adding new ones.</p>
					</div>
				`;
				return;
			}

			if (currentEpisodeSegmentsForAdmin.length === 0) {
				// Show loading state
				segmentsContainer.innerHTML = `
					<div style="text-align: center; padding: 40px; color: #6c757d;">
						<h3 style="color: #495057; margin-bottom: 15px;">🔄 Loading...</h3>
						<p>Loading existing words for Episode ${episodeNum}...</p>
					</div>
				`;
				return;
			}

			currentEpisodeSegmentsForAdmin.forEach((segment, segIndex) => {
				const segmentDiv = document.createElement('div');
				segmentDiv.className = 'admin-segment-block';
				segmentDiv.style.cssText = `
					background: ${segIndex % 3 === 0 ? '#f0f8ff' : (segIndex % 3 === 1 ? '#f0fff0' : '#fff0f0')};
					border-radius: 10px;
					padding: 20px;
					margin-bottom: 20px;
					border: 2px solid ${segIndex % 3 === 0 ? '#3498db' : (segIndex % 3 === 1 ? '#27ae60' : '#e74c3c')};
				`;

				const segmentLetter = String.fromCharCode(65 + segIndex);

				let wordsHtml = '';
				// Ensure segment.words is an array for iteration
				const segmentWordsArray = Array.isArray(segment.words) ? segment.words : Object.values(segment.words || {});

								   
								   
				segmentWordsArray.forEach((wordCandidates, wordIndex) => {
					const currentWord = wordCandidates[0]?.word || ''; // Get the first candidate's word
					const placeholder = currentWord ? currentWord : `Word ${wordIndex + 1}...`;
					const inputStyle = currentWord ? 'background: #e8f5e8; border-color: #27ae60;' : ''; // Highlight pre-filled words
					
					wordsHtml += `
						<div class="admin-form-group admin-word-input">
							<label>Word ${wordIndex + 1} ${currentWord ? '✓' : ''}</label>
							<div class="admin-word-number">${wordIndex + 1}</div>
							<input type="text" class="admin-form-control admin-segment-word-input" 
								   data-segment-index="${segIndex}" data-word-index="${wordIndex}"
								   placeholder="${placeholder}" value="${currentWord}" style="${inputStyle}">

				   
							<button type="button" class="admin-btn admin-btn-remove-word" onclick="removeWord(${segIndex}, ${wordIndex})" 
									style="position: absolute; right: 0px; top: 30px; background: none; border: none; color: #e74c3c; font-size: 1.2rem; cursor: pointer;">
								&times;
							</button>
						</div>
					`;
				});

				segmentDiv.innerHTML = `
					<h3 style="color: #2c3e50; margin-bottom: 15px; font-size: 1.1rem;">
						📍 Segment ${segmentLetter}
						<button type="button" class="admin-btn admin-btn-remove-segment" onclick="removeSegment(${segIndex})" 
								style="float: right; background: #e74c3c; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 0.8rem;">
							Remove Segment
						</button>
					</h3>
					<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
						${wordsHtml}
					</div>
					<div style="text-align: right; margin-top: 15px;">
						<button type="button" class="admin-btn" style="background: #27ae60; color: white; padding: 8px 15px; border-radius: 8px; font-size: 0.9rem;" 
								onclick="addWord(${segIndex})">
							+ Add Word
						</button>
					</div>
				`;
				segmentsContainer.appendChild(segmentDiv);
			});

			// Attach input listeners to update currentEpisodeSegmentsForAdmin in real-time
			document.querySelectorAll('.admin-segment-word-input').forEach(input => {
				input.addEventListener('input', (e) => {
					const segIndex = parseInt(e.target.dataset.segmentIndex);
					const wordIndex = parseInt(e.target.dataset.wordIndex);
					const value = e.target.value.trim();

					if (!currentEpisodeSegmentsForAdmin[segIndex]) {
						// This should not happen if currentEpisodeSegmentsForAdmin is properly initialized
						// but as a safeguard
						currentEpisodeSegmentsForAdmin[segIndex] = { id: `segment_${episodeNum}_${segIndex + 1}`, words: [] };
					}
					if (!currentEpisodeSegmentsForAdmin[segIndex].words[wordIndex]) {
						currentEpisodeSegmentsForAdmin[segIndex].words[wordIndex] = [];
					}
					// Always set the first candidate for simplicity in admin form
					currentEpisodeSegmentsForAdmin[segIndex].words[wordIndex][0] = { word: value, votes: 1, voters: [] };
					
					// Update input styling based on content
					if (value) {
						e.target.style.background = '#e8f5e8';
						e.target.style.borderColor = '#27ae60';
					} else {
						e.target.style.background = '';
						e.target.style.borderColor = '';
					}

				});
			});
		}

		function openAdminModal() {
			const modal = document.getElementById('adminWordsModal');
			modal.style.display = 'block';

			// Populate episode dropdown
			const episodeSelect = document.getElementById('adminEpisode');
			if (episodeSelect.options.length <= 1) { // Only populate if empty or just has placeholder
				for (let i = 1; i <= 110; i++) { // Assuming max 110 episodes
					const option = document.createElement('option');
					option.value = i;
					option.textContent = `Episode ${i}`;
					episodeSelect.appendChild(option);
				}
			}
			
			// ✅ NEW: Initialize with 3 empty segments by default
			if (currentEpisodeSegmentsForAdmin.length === 0) {
				currentEpisodeSegmentsForAdmin = generateInitialEmptySegmentsForAdmin('TBD'); // TBD = To Be Determined
			}
			
			hideMessages(); // Clear any previous messages
			renderAdminForm(); // ✅ NEW: Render the form with default segments
		}



		// Close the admin modal
		function closeAdminModal() {
			const modal = document.getElementById('adminWordsModal');
			modal.style.display = 'none';
			// Optionally clear form or reset state on close
			clearForm();
		}

		// Clear the form and reset currentEpisodeSegmentsForAdmin

		function clearForm() {
			document.getElementById('adminEpisode').value = '';
			currentEpisodeSegmentsForAdmin = []; // Reset the internal data
			renderAdminForm(); // Rerender to show empty state
			hideMessages(); // Clear messages
			showInfoMessage('Form cleared. Select an episode to load existing words or start fresh.');
		}


		function addSegment() {
			const episodeNum = document.getElementById('adminEpisode').value;
			if (!episodeNum) {
				showErrorMessage('Please select an episode first to add a segment.');
				return;
			}
			const newSegmentIndex = currentEpisodeSegmentsForAdmin.length;
			currentEpisodeSegmentsForAdmin.push({
				id: `segment_${episodeNum}_${newSegmentIndex + 1}`,
				words: generateInitialEmptyWordsForAdmin() // 3 empty words
			});
			renderAdminForm();
			showInfoMessage(`Added Segment ${String.fromCharCode(65 + newSegmentIndex)} to Episode ${episodeNum}`);
		}

 

		// Dynamically remove the last segment
		function removeLastSegment() {
			if (currentEpisodeSegmentsForAdmin.length > 0) {
				if (confirm('Are you sure you want to remove the last segment? This cannot be undone.')) {
					currentEpisodeSegmentsForAdmin.pop();
					renderAdminForm();
				}
			} else {
				showInfoMessage('No segments to remove.');
			}
		}


		// ADD THIS MISSING FUNCTION
		function removeSegment(segmentIndex) {
			if (!currentEpisodeSegmentsForAdmin[segmentIndex]) {
				showErrorMessage('Segment not found');
				return;
			}

			const segmentLetter = String.fromCharCode(65 + segmentIndex);
			const episodeNum = document.getElementById('adminEpisode').value;
			
			if (currentEpisodeSegmentsForAdmin.length <= 1) {
				showErrorMessage('Cannot remove the last segment. At least one segment is required.');
				return;
			}
			
			if (confirm(`Are you sure you want to remove Segment ${segmentLetter} from Episode ${episodeNum}? This cannot be undone.`)) {
				console.log(`🗑️ Removing segment ${segmentIndex} (${segmentLetter})`);
				
				// Remove the segment from the array
				currentEpisodeSegmentsForAdmin.splice(segmentIndex, 1);
				
				// Update IDs for remaining segments to maintain proper numbering
				currentEpisodeSegmentsForAdmin.forEach((segment, newIndex) => {
					segment.id = `segment_${episodeNum}_${newIndex + 1}`;
				});
				
				// Re-render the form
				renderAdminForm();
				
				showInfoMessage(`Removed Segment ${segmentLetter} from Episode ${episodeNum}`);
			}
		}

		// Dynamically add a new word to a specific segment

		function addWord(segmentIndex) {
			if (currentEpisodeSegmentsForAdmin[segmentIndex]) {
				const segmentLetter = String.fromCharCode(65 + segmentIndex);
				const wordNumber = currentEpisodeSegmentsForAdmin[segmentIndex].words.length + 1;
				currentEpisodeSegmentsForAdmin[segmentIndex].words.push([]); // Add an empty word slot
				renderAdminForm();
				showInfoMessage(`Added Word ${wordNumber} to Segment ${segmentLetter}`);
			}
		}


		// Dynamically remove a word from a specific segment
		function removeWord(segmentIndex, wordIndex) {
			if (currentEpisodeSegmentsForAdmin[segmentIndex] && currentEpisodeSegmentsForAdmin[segmentIndex].words[wordIndex]) {
				if (confirm(`Are you sure you want to remove word ${wordIndex + 1} from Segment ${String.fromCharCode(65 + segmentIndex)}? This cannot be undone.`)) {
					currentEpisodeSegmentsForAdmin[segmentIndex].words.splice(wordIndex, 1);
					renderAdminForm();
				}
			}
		}


		async function submitAdminWords(event) {
			event.preventDefault();

			if (!currentUser || currentUser.email !== 'mathewmit@gmail.com') { // Replace with actual admin email
				showErrorMessage('Unauthorized: Admin access required');
				return;
			}

			const episodeNum = document.getElementById('adminEpisode').value;
			if (!episodeNum) {
				showErrorMessage('Please select an episode');
				return;
			}

			const submitBtn = document.getElementById('adminSubmitBtn');
			submitBtn.disabled = true;
			submitBtn.innerHTML = '<span>⏳</span> Saving...';

			try {
				const videoRef = db.collection('videos').doc(`episode_${episodeNum}`);
				const newSegmentsData = {};

				currentEpisodeSegmentsForAdmin.forEach((segment, segIndex) => {
					// Ensure segment has a valid ID, use generated if missing
					const segmentId = segment.id || `segment_${episodeNum}_${segIndex + 1}`;
					
					const wordsForSegment = {};
					segment.words.forEach((wordCandidates, wordIndex) => {
						const wordText = wordCandidates[0]?.word?.trim() || ''; // Get the first candidate's word
						if (wordText) {
							wordsForSegment[wordIndex.toString()] = [{ // Store as an array of candidates
								word: wordText,
								votes: 1, // Default votes, can be adjusted
								voters: []
							}];
						}
					});

					newSegmentsData[segmentId] = {
						id: segmentId,
						words: wordsForSegment, // This is now an object with numeric keys, matching Firestore structure
						// Preserve existing ratings if they exist, otherwise use defaults
						ratings: segment.ratings || {
							lyrics: { average: 3.0, count: 0 },
							beats: { average: 3.0, count: 0 },
							reaction: { average: 3.0, count: 0 },
							overall: { average: 3.0, count: 0 }
						}
					};
				});

				// Update Firebase with the new segments structure
				await videoRef.update({
					segments: newSegmentsData
				});

				showSuccessMessage(`Successfully saved all words for Episode ${episodeNum}!`);

				// Refresh the main app display
				if (typeof loadVideosData === 'function') {
					loadVideosData();
				}

			} catch (error) {
				console.error('Error saving words:', error);
				showErrorMessage(`Error: ${error.message}`);
			} finally {
				submitBtn.disabled = false;
				submitBtn.innerHTML = '<span>💾</span> Save All Words';
			}
		}

		function goToNextEpisode() {
			const episodeSelect = document.getElementById('adminEpisode');
			const currentEpisode = parseInt(episodeSelect.value);
			
			if (!currentEpisode) {
				showErrorMessage('Please select an episode first');
				return;
			}
			
			// Submit the current form first
			document.getElementById('adminWordsForm').dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
			
			// Then go to next episode after a short delay, checking for success
			setTimeout(() => {
				const successMessage = document.getElementById('adminSuccessMessage');
				if (successMessage.style.display === 'flex') { // Only proceed if save was successful
					if (currentEpisode < 110) { // Max episode number
						episodeSelect.value = currentEpisode + 1;
						loadExistingWords(); // Load data for the next episode
						showSuccessMessage(`Moved to Episode ${currentEpisode + 1}`);
					} else {
						showInfoMessage('You\'ve reached the last episode!');
					}
				} else {
					showErrorMessage('Could not move to next episode. Please fix current errors.');
				}
			}, 1500); // Give some time for the save operation and notification to appear
		}

		function showSuccessMessage(message) {
			hideMessages();
			const successMsg = document.getElementById('adminSuccessMessage');
			document.getElementById('successText').textContent = message;
			successMsg.style.display = 'flex';
			setTimeout(hideMessages, 5000); // Auto-hide after 5 seconds
		}

		function showErrorMessage(message) {
			hideMessages();
			const errorMsg = document.getElementById('adminErrorMessage');
			document.getElementById('errorText').textContent = message;
			errorMsg.style.display = 'flex';
			setTimeout(hideMessages, 5000); // Auto-hide after 5 seconds
		}

		function hideMessages() {
			document.getElementById('adminSuccessMessage').style.display = 'none';
			document.getElementById('adminErrorMessage').style.display = 'none';
			document.getElementById('adminInfoMessage').style.display = 'none';
		}


        // Make functions globally available for onclick handlers
		window.handleStarClick = handleStarClick;
		window.handleStarHover = handleStarHover;
		window.handleStarLeave = handleStarLeave;

		// ADD THIS LINE:
		window.toggleSegment = toggleSegment;
		
		// Make notes functions globally available for onclick handlers
		window.toggleNotesSection = toggleNotesSection;
		window.startEditingNote = startEditingNote;
		window.saveNote = saveNote;
		window.cancelEditingNote = cancelEditingNote;
		window.updateCharCount = updateCharCount;

		// Make admin functions globally available
		window.bulkUpdateWords = bulkUpdateWords; // Still available for one-off bulk updates
		window.checkAdminAccess = checkAdminAccess;
		window.openAdminModal = openAdminModal;
		window.closeAdminModal = closeAdminModal;
		window.clearForm = clearForm;
		window.submitAdminWords = submitAdminWords;
		window.goToNextEpisode = goToNextEpisode;

		window.addSegment = addSegment; // New
		window.removeLastSegment = removeLastSegment; // New
		window.addWord = addWord; // New
		window.removeWord = removeWord; // New
		window.showInfoMessage = showInfoMessage; // New
		window.loadExistingWords = loadExistingWords; // New function
		window.removeSegment = removeSegment;		


        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harry Mack Omegle Bars - Community Hub</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🎤</text></svg>">
  
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            color: white;
            position: relative;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .user-section {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .user-info {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .auth-button {
            display: inline-flex;
            align-items: center;
            background: white;
            color: #3c4043;
            border: 1px solid #dadce0;
            border-radius: 24px;
            padding: 8px 16px;
            font-family: 'Google Sans', Roboto, Arial, sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px 0 rgba(60,64,67,0.30);
            gap: 8px;
        }
        
        .auth-button {
            display: inline-flex;
            align-items: center;
            background: white;
            color: #3c4043;
            border: 1px solid #dadce0;
            border-radius: 24px;
            padding: 10px 16px;
            font-family: 'Google Sans', 'Roboto', Arial, sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px 0 rgba(60,64,67,0.30), 0 1px 3px 1px rgba(60,64,67,0.15);
            gap: 12px;
            min-height: 40px;
        }
        
        .auth-button:hover {
            background: #f8f9fa;
            border-color: #c1c7cd;
            box-shadow: 0 1px 3px 1px rgba(60,64,67,0.15), 0 1px 2px 0 rgba(60,64,67,0.30);
        }
        
        .auth-button:active {
            background: #f1f3f4;
            box-shadow: 0 1px 2px 0 rgba(60,64,67,0.30);
        }
        
        .google-icon {
            width: 18px;
            height: 18px;
            display: block;
        }
        
        .connection-status {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
            z-index: 1000;
        }

        .status-connected {
            background: #27ae60;
            color: white;
        }

        .status-disconnected {
            background: #e74c3c;
            color: white;
        }

        .status-demo {
            background: #f39c12;
            color: white;
        }

        .status-connecting {
            background: #f39c12;
            color: white;
        }
 

		/*do i need this*/
        .video-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
        }
 
		/*do i need this*/
        .overall-rating h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }



        .segments-section {
            margin-bottom: 20px;
        }

        .segments-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .segments-header h4 {
            color: #8e44ad;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .expand-toggle {
            background: #8e44ad;
            color: white;
            border: none;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .expand-toggle:hover {
            background: #7d3c98;
        }

        .segment {
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 15px;
            border-left: 4px solid #e74c3c;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .segment-header {
            padding: 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #fff;
            border-bottom: 1px solid #eee;
        }

        .segment-header:hover {
            background: #f8f9fa;
        }

        .segment-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .segment-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
        }

        .segment-rating-summary {
            font-size: 0.75rem;
            color: #7f8c8d;
        }

        .segment-expand-icon {
            color: #8e44ad;
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }

        .segment.expanded .segment-expand-icon {
            transform: rotate(90deg);
        }

        .segment-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .segment.expanded .segment-content {
            max-height: 800px;
        }

        .segment-details {
            padding: 20px;
        }

        .words-management {
            margin-bottom: 20px;
        }

        .words-management h5 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 0.85rem;
        }
   
  
        .segment-ratings {
            border-top: 1px solid #eee;
            padding-top: 15px;
        }

        .rating-category {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .rating-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .rating-label {
            font-weight: 600;
            color: #34495e;
            font-size: 0.85rem;
        }

        .rating-stats {
            font-size: 0.7rem;
            color: #7f8c8d;
            margin-top: 2px;
        }

        .rating-controls {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
        }

        .stars {
            display: flex;
            gap: 3px;
        }

        .star {
            width: 20px;
            height: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #ddd;
            user-select: none;
        }

        .star:hover,
        .star.active {
            color: #f39c12;
            transform: scale(1.1);
        }

        .star.user-rated {
            color: #e74c3c;
        }

        .user-rating-indicator {
            font-size: 0.65rem;
            color: #e74c3c;
            font-weight: bold;
        }

        .stats-bar {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            color: white;
            text-align: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .stat-item {
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .filter-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            color: white;
        }

        .filter-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-controls select,
        .filter-controls input {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            background: white;
            color: #333;
        }

        .loading {
            text-align: center;
            color: white;
            font-size: 1.2rem;
            margin: 50px 0;
        }

        .error-message {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 10px;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: slideIn 0.3s ease;
        }

        .notification.success {
            background: #27ae60;
            color: white;
        }

        .notification.error {
            background: #e74c3c;
            color: white;
        }

        .notification.info {
            background: #3498db;
            color: white;
        }

        .segment-label {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .debug-info {
            background: #ffeb3b;
            color: #333;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 0.8rem;
            font-family: monospace;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @media (max-width: 768px) {
            .video-grid {
                grid-template-columns: 1fr;
            }
            .header h1 {
                font-size: 2rem;
            }
            .user-section {
                position: static;
                justify-content: center;
                margin-top: 15px;
            }
            .filter-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
		
		
		
		
		
		/* Add these CSS rules to your existing <style> section */
		/* Notes Section Styles */
		.notes-section {
			border-top: 1px solid #eee;
			padding-top: 15px;
			margin-top: 15px;
		}

		.notes-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 10px;
			cursor: pointer;
			padding: 8px;
			border-radius: 8px;
			transition: background 0.2s ease;
		}

		.notes-header:hover {
			background: #f8f9fa;
		}

		.notes-title {
			font-weight: 600;
			color: #2c3e50;
			font-size: 0.85rem;
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.notes-expand-icon {
			color: #8e44ad;
			font-size: 1rem;
			transition: transform 0.3s ease;
		}

		.notes-section.expanded .notes-expand-icon {
			transform: rotate(90deg);
		}

		.notes-content {
			max-height: 0;
			overflow: hidden;
			transition: max-height 0.3s ease;
		}

		.notes-section.expanded .notes-content {
			max-height: 400px;
		}

		.notes-textarea {
			width: 100%;
			min-height: 80px;
			max-height: 200px;
			padding: 10px;
			border: 1px solid #ddd;
			border-radius: 8px;
			font-size: 0.85rem;
			font-family: inherit;
			resize: vertical;
			transition: border-color 0.2s ease;
		}

		.notes-textarea:focus {
			outline: none;
			border-color: #8e44ad;
			box-shadow: 0 0 0 2px rgba(142, 68, 173, 0.1);
		}

		.notes-actions {
			display: flex;
			gap: 8px;
			margin-top: 10px;
			justify-content: flex-end;
		}

		.notes-save-btn {
			background: #27ae60;
			color: white;
			border: none;
			padding: 6px 12px;
			border-radius: 6px;
			font-size: 0.8rem;
			cursor: pointer;
			transition: background 0.2s ease;
		}

		.notes-save-btn:hover {
			background: #229954;
		}

		.notes-save-btn:disabled {
			background: #bdc3c7;
			cursor: not-allowed;
		}

		.notes-cancel-btn {
			background: #95a5a6;
			color: white;
			border: none;
			padding: 6px 12px;
			border-radius: 6px;
			font-size: 0.8rem;
			cursor: pointer;
			transition: background 0.2s ease;
		}

		.notes-cancel-btn:hover {
			background: #7f8c8d;
		}

		.notes-display {
			background: #f8f9fa;
			border: 1px solid #e9ecef;
			border-radius: 8px;
			padding: 12px;
			font-size: 0.85rem;
			line-height: 1.4;
			white-space: pre-wrap;
			word-wrap: break-word;
			min-height: 40px;
		}

		.notes-display.empty {
			color: #6c757d;
			font-style: italic;
		}

		.notes-edit-btn {
			background: #3498db;
			color: white;
			border: none;
			padding: 4px 8px;
			border-radius: 4px;
			font-size: 0.75rem;
			cursor: pointer;
			transition: background 0.2s ease;
			margin-top: 8px;
		}

		.notes-edit-btn:hover {
			background: #2980b9;
		}

		.notes-char-count {
			font-size: 0.7rem;
			color: #6c757d;
			text-align: right;
			margin-top: 4px;
		}

		.notes-char-count.warning {
			color: #f39c12;
		}

		.notes-char-count.error {
			color: #e74c3c;
		}
		/* ===== END NOTES CSS ===== */
		
		
  
		/* do i need this? */
        .segments-summary h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }
		

		/* do i need this? */
        .segment-preview-label {
            font-weight: 600;
        }

		/* do i need this? */
        .segment-preview-rating {
            background: rgba(255, 255, 255, 0.3);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
        }

		/* do i need this? */
        .no-segments-preview {
            color: #7f8c8d;
            font-style: italic;
            font-size: 0.9rem;
        }
        /* ===== END SEGMENT SUMMARY CSS ===== */

	 
		/* ===== PLATFORM INTRO BANNER ===== */
		.platform-intro {
			background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
			border-radius: 20px;
			padding: 40px 30px;
			margin-bottom: 30px;
			color: white;
			text-align: center;
			position: relative;
			overflow: hidden;
			box-shadow: 0 15px 35px rgba(102, 126, 234, 0.3);
		}

		.platform-intro::before {
			content: '';
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="25" cy="25" r="1" fill="white" opacity="0.1"/><circle cx="75" cy="75" r="1" fill="white" opacity="0.1"/><circle cx="50" cy="10" r="1" fill="white" opacity="0.05"/><circle cx="90" cy="40" r="1" fill="white" opacity="0.1"/><circle cx="10" cy="80" r="1" fill="white" opacity="0.05"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
			pointer-events: none;
		}

		.intro-content {
			position: relative;
			z-index: 1;
			max-width: 800px;
			margin: 0 auto;
		}

		.intro-badge {
			display: inline-flex;
			align-items: center;
			background: rgba(255, 255, 255, 0.2);
			backdrop-filter: blur(10px);
			border: 1px solid rgba(255, 255, 255, 0.3);
			padding: 8px 20px;
			border-radius: 50px;
			font-size: 0.85rem;
			font-weight: 600;
			margin-bottom: 20px;
			gap: 8px;
			animation: fadeInUp 0.6s ease;
		}

		.intro-badge span {
			background: linear-gradient(45deg, #fff, #f0f0f0);
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			background-clip: text;
			font-weight: 700;
			letter-spacing: 1px;
		}

		.intro-title {
			font-size: 2.2rem;
			font-weight: 700;
			margin-bottom: 15px;
			text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
			animation: fadeInUp 0.6s ease 0.1s backwards;
			line-height: 1.2;
		}

		.intro-description {
			font-size: 1.1rem;
			margin-bottom: 30px;
			opacity: 0.95;
			line-height: 1.4;
			animation: fadeInUp 0.6s ease 0.2s backwards;
		}

		.intro-features {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
			gap: 20px;
			margin-top: 30px;
		}

		.feature-item {
			display: flex;
			align-items: center;
			background: rgba(255, 255, 255, 0.15);
			backdrop-filter: blur(10px);
			border: 1px solid rgba(255, 255, 255, 0.2);
			padding: 15px 20px;
			border-radius: 15px;
			text-align: left;
			transition: all 0.3s ease;
			animation: fadeInUp 0.6s ease 0.3s backwards;
		}

		.feature-item:hover {
			transform: translateY(-2px);
			background: rgba(255, 255, 255, 0.2);
			box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
		}

		.feature-icon {
			font-size: 1.5rem;
			margin-right: 15px;
			flex-shrink: 0;
		}

		.feature-item span {
			font-size: 0.95rem;
			line-height: 1.3;
		}

		@keyframes fadeInUp {
			from {
				opacity: 0;
				transform: translateY(30px);
			}
			to {
				opacity: 1;
				transform: translateY(0);
			}
		}

		@media (max-width: 768px) {
			.platform-intro {
				padding: 30px 20px;
				margin-bottom: 20px;
			}
			
			.intro-title {
				font-size: 1.8rem;
			}
			
			.intro-description {
				font-size: 1rem;
			}
			
			.intro-features {
				grid-template-columns: 1fr;
				gap: 15px;
			}
			
			.feature-item {
				padding: 12px 15px;
			}
			
			.feature-icon {
				font-size: 1.2rem;
				margin-right: 12px;
			}
		}
		/* ===== END PLATFORM INTRO BANNER ===== */

		/* ===== DISCLAIMER BANNER ===== */
		.disclaimer-banner {
			background: #fff3cd;
			border: 1px solid #ffeaa7;
			color: #856404;
			padding: 12px 20px;
			margin-bottom: 20px;
			border-radius: 8px;
			font-size: 0.9rem;
			text-align: center;
			box-shadow: 0 2px 4px rgba(0,0,0,0.1);
		}

		.disclaimer-banner strong {
			color: #664d03;
		}
		/* ===== END DISCLAIMER BANNER ===== */


		/* ===== HORIZONTAL WORDS DISPLAY ===== */
		.words-horizontal-container {
			background: #f8f9fa;
			border-radius: 10px;
			padding: 15px;
			border-left: 4px solid #3498db;
		}

		.words-horizontal {
			display: flex;
			gap: 12px;
			flex-wrap: wrap;
			align-items: center;
		}

		.word-display {
			display: inline-flex;
			align-items: center;
			background: linear-gradient(45deg, #3498db, #2980b9);
			color: white;
			padding: 8px 16px;
			border-radius: 25px;
			font-size: 0.9rem;
			font-weight: 600;
			box-shadow: 0 2px 4px rgba(0,0,0,0.1);
			transition: all 0.2s ease;
			min-width: 80px;
			justify-content: center;
		}

		.word-display:hover {
			transform: translateY(-1px);
			box-shadow: 0 4px 8px rgba(0,0,0,0.15);
		}

		.word-text {
			font-weight: 700;
			letter-spacing: 0.3px;
		}

		/* ===== FILL-IN LINK STYLES ===== */
		.word-missing {
			display: inline-flex;
			align-items: center;
			min-width: 80px;
			justify-content: center;
		}

		.fill-in-link {
			display: inline-flex;
			align-items: center;
			background: linear-gradient(45deg, #e74c3c, #c0392b);
			color: white;
			padding: 8px 16px;
			border-radius: 25px;
			font-size: 0.85rem;
			font-weight: 600;
			text-decoration: none;
			box-shadow: 0 2px 4px rgba(0,0,0,0.1);
			transition: all 0.2s ease;
			cursor: pointer;
			border: 2px dashed rgba(255,255,255,0.3);
		}

		.fill-in-link:hover {
			background: linear-gradient(45deg, #c0392b, #a93226);
			transform: translateY(-1px);
			box-shadow: 0 4px 8px rgba(0,0,0,0.2);
			text-decoration: none;
			color: white;
			border: 2px dashed rgba(255,255,255,0.6);
		}

		.fill-in-link:active {
			transform: translateY(0);
		}

		/* ===== WORDS MANAGEMENT STYLES ===== */
		.words-management h5 {
			color: #2c3e50;
			margin-bottom: 10px;
			font-size: 0.85rem;
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.words-management h5::before {
			content: '🎵';
			font-size: 1rem;
		}

		.words-help-text {
			font-size: 0.75rem;
			color: #7f8c8d;
			margin-top: 8px;
			font-style: italic;
		}

		/* ===== GENERAL STYLES ===== */
		.segment-label {
			font-size: 0.8rem;
			color: #666;
			margin-bottom: 5px;
			font-weight: 600;
		}

		.no-words {
			color: #7f8c8d;
			font-style: italic;
			font-size: 0.9rem;
			padding: 8px;
			text-align: center;
		}

		/* ===== RESPONSIVE DESIGN ===== */
		@media (max-width: 768px) {
			.words-horizontal {
				flex-direction: column;
				gap: 8px;
				align-items: stretch;
			}
			
			.word-display,
			.word-missing {
				min-width: auto;
				width: 100%;
			}
			
			.fill-in-link {
				width: 100%;
				justify-content: center;
			}
		}
		/* ===== END HORIZONTAL WORDS CSS ===== */


		/* ===== INLINE SEGMENT HEADER WORDS ===== */
		.segment-info-with-words {
			display: flex;
			flex-direction: column;
			gap: 8px;
			flex: 1;
		}

		.segment-title-and-rating {
			display: flex;
			flex-direction: column;
			gap: 5px;
		}

		.segment-words-inline {
			display: flex;
			gap: 8px;
			flex-wrap: wrap;
			align-items: center;
		}

		.segment-words-inline .word-display {
			padding: 4px 12px;
			font-size: 0.8rem;
			min-width: 60px;
			border-radius: 15px;
		}

		.word-missing-inline {
			display: inline-flex;
			align-items: center;
		}

		.fill-in-link-small {
			display: inline-flex;
			align-items: center;
			background: linear-gradient(45deg, #e74c3c, #c0392b);
			color: white;
			padding: 4px 12px;
			border-radius: 15px;
			font-size: 0.75rem;
			font-weight: 600;
			text-decoration: none;
			box-shadow: 0 1px 3px rgba(0,0,0,0.1);
			transition: all 0.2s ease;
			cursor: pointer;
			border: 1px dashed rgba(255,255,255,0.3);
			min-width: 60px;
			justify-content: center;
		}

		.fill-in-link-small:hover {
			background: linear-gradient(45deg, #c0392b, #a93226);
			transform: translateY(-1px);
			box-shadow: 0 2px 4px rgba(0,0,0,0.2);
			text-decoration: none;
			color: white;
			border: 1px dashed rgba(255,255,255,0.6);
		}

		/* ===== RESPONSIVE FOR INLINE WORDS ===== */
		@media (max-width: 768px) {
			.segment-words-inline {
				flex-direction: column;
				gap: 4px;
				align-items: stretch;
			}
			
			.segment-words-inline .word-display,
			.fill-in-link-small {
				width: 100%;
				min-width: auto;
			}
		}



		/* ===== COMPACT VIDEO CARD UPDATES ===== */

		/* Update video grid to fit 3 cards per row */
		.video-grid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); /* Reduced from 450px */
			gap: 15px; /* Reduced from 25px */
			margin-bottom: 40px;
		}

		/* More compact video cards */
		.video-card {
			background: white;
			border-radius: 12px; /* Slightly reduced */
			overflow: hidden;
			box-shadow: 0 4px 15px rgba(0,0,0,0.1); /* Reduced shadow */
			transition: transform 0.3s ease, box-shadow 0.3s ease;
		}

		.video-card:hover {
			transform: translateY(-3px); /* Reduced from -5px */
			box-shadow: 0 8px 25px rgba(0,0,0,0.15); /* Reduced from stronger shadow */
		}

		/* Significantly reduce video embed height */
		.video-embed {
			position: relative;
			width: 100%;
			height: 140px; /* Reduced from 200px */
			background: #f0f0f0;
			display: flex;
			align-items: center;
			justify-content: center;
			color: #666;
			font-size: 14px;
		}

		/* Compact video content padding */
		.video-content {
			padding: 12px; /* Reduced from 20px */
		}

		/* Smaller video title */
		.video-title {
			font-size: 1rem; /* Reduced from 1.1rem */
			font-weight: bold;
			margin-bottom: 8px; /* Reduced from 15px */
			color: #2c3e50;
			line-height: 1.2;
		}

		/* Compact overall rating section */
		.overall-rating {
			background: #f8f9fa;
			border-radius: 8px; /* Reduced from 10px */
			padding: 8px 10px; /* Reduced from 15px */
			margin-bottom: 10px; /* Reduced from 20px */
			border-left: 3px solid #3498db; /* Reduced from 4px */
		}

		.overall-rating h4 {
			color: #2c3e50;
			margin-bottom: 6px; /* Reduced from 10px */
			font-size: 0.8rem; /* Reduced from 0.9rem */
			font-weight: 600;
		}

		/* More compact rating display */
		.rating-category {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 0; /* Removed margin */
		}

		.rating-info {
			display: flex;
			flex-direction: column;
			align-items: flex-start;
		}

		.rating-label {
			font-weight: 600;
			color: #34495e;
			font-size: 0.75rem; /* Reduced from 0.85rem */
			margin-bottom: 2px;
		}

		.rating-stats {
			font-size: 0.65rem; /* Reduced from 0.7rem */
			color: #7f8c8d;
		}

		/* Compact segments summary */
		.segments-summary {
			background: #f8f9fa;
			border-radius: 8px; /* Reduced from 10px */
			padding: 8px 10px; /* Reduced from 15px */
			margin-bottom: 10px; /* Reduced from 20px */
			border-left: 3px solid #9b59b6; /* Reduced from 4px */
		}

		.segments-summary h4 {
			color: #2c3e50;
			margin-bottom: 6px; /* Reduced from 10px */
			font-size: 0.8rem; /* Reduced from 0.9rem */
			font-weight: 600;
		}

		/* Even more compact segment previews */
		.segments-preview {
			display: flex;
			flex-wrap: nowrap;
			gap: 4px; /* Reduced from 8px */
			overflow-x: auto;
		}

		.segment-preview {
			display: flex;
			align-items: center;
			background: linear-gradient(45deg, #9b59b6, #8e44ad);
			color: white;
			padding: 4px 8px; /* Reduced from 6px 10px */
			border-radius: 15px; /* Reduced from 20px */
			font-size: 0.7rem; /* Reduced from 0.8rem */
			gap: 4px; /* Reduced from 6px */
			min-width: 85px; /* Reduced from 100px */
			justify-content: space-between;
			flex-shrink: 0;
		}

		.segment-preview-rating {
			background: rgba(255, 255, 255, 0.3);
			padding: 1px 6px; /* Reduced from 2px 8px */
			border-radius: 10px; /* Reduced from 12px */
			font-size: 0.7rem; /* Reduced from 0.8rem */
			font-weight: bold;
		}

		/* Compact segments section */
		.segments-section {
			margin-bottom: 8px; /* Reduced from 20px */
		}

		.segments-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 8px; /* Reduced from 15px */
		}

		.segments-header h4 {
			color: #8e44ad;
			font-size: 0.8rem; /* Reduced from 0.9rem */
			text-transform: uppercase;
			letter-spacing: 1px;
			font-weight: 600;
		}

		.expand-toggle {
			background: #8e44ad;
			color: white;
			border: none;
			padding: 4px 10px; /* Reduced from 5px 12px */
			border-radius: 12px; /* Reduced from 15px */
			font-size: 0.7rem; /* Reduced from 0.8rem */
			cursor: pointer;
			transition: background 0.3s ease;
			font-weight: 600;
		}



		/* Responsive updates for mobile */
		@media (max-width: 768px) {
			.video-grid {
				grid-template-columns: 1fr; /* Single column on mobile */
				gap: 12px;
			}
			
			.video-embed {
				height: 120px; /* Even smaller on mobile */
			}
			
			.video-content {
				padding: 10px;
			}
			
			.video-title {
				font-size: 0.95rem;
			}
		}

		@media (min-width: 1200px) {
			.video-grid {
				grid-template-columns: repeat(3, 1fr); /* Force exactly 3 columns on larger screens */
			}
		}

		/* Remove any duplicate information styling */
		.user-rating-indicator {
			font-size: 0.6rem; /* Reduced from 0.65rem */
			color: #e74c3c;
			font-weight: bold;
			margin-top: 2px;
		}

		/* Inline segment title and rating */
		.segment-title-inline {
			display: flex;
			justify-content: space-between;
			align-items: center;
			width: 100%;
		}

		.segment-name {
			font-weight: 600;
			color: #2c3e50;
			font-size: 0.9rem;
		}

		.segment-rating-inline {
			font-size: 0.75rem;
			color: #7f8c8d;
			font-weight: 600;
			background: rgba(52, 152, 219, 0.1);
			padding: 2px 6px;
			border-radius: 8px;
			flex-shrink: 0;
		}

    </style>
</head>

<body>
    <div class="connection-status" id="connectionStatus">
        <span id="statusText">Connecting...</span>
    </div>

    <div class="container">
        <div class="header">
            <div class="user-section">
                <div class="user-info" id="userInfo" style="display: none;">
                    Welcome, <span id="userName"></span>!
                </div>
                <button class="auth-button" id="authButton">
                    <img class="google-icon" src="https://developers.google.com/identity/images/g-logo.png" alt="Google logo">
                    Sign in with Google
                </button>
            </div>
         
			
			<!-- Admin-only button (only shows for mathewmit@gmail.com) -->
			<button id="adminUpdateButton" onclick="bulkUpdateWords()" 
					style="display: none; position: fixed; top: 100px; right: 20px; background: #e74c3c; color: white; padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; z-index: 1001; font-weight: bold;">
				🔧 Admin: Update Words
			</button>
			
			
			
			
            <h1>🎤 Harry Mack Ratings Central</h1>
            <p>Rate Omegle Bars episodes with the global Harry Mack fan community!</p>
            <p style="font-size: 0.9rem; margin-top: 10px; opacity: 0.8;">
                ✨ Rate individual segments of Omegle Bars • View episode words • Add personal notes ✨
            </p>
        </div>


		<div class="platform-intro">
			<div class="intro-content">
				<div class="intro-badge">
					🎉 <span>WORLD'S FIRST</span>
				</div>
				<h2 class="intro-title">Centralized Harry Mack Rating Platform</h2>
				<p class="intro-description">
					Starting with the Omegle Bars series! 
				</p>
				<div class="intro-features">
					<div class="feature-item">
						<div class="feature-icon">⭐</div>
						<span>Discover the best episodes through community ratings</span>
					</div>
					<div class="feature-item">
						<div class="feature-icon">🔍</div>
						<span>Find episodes by improvised words</span>
					</div>
					<div class="feature-item">
						<div class="feature-icon">💬</div>
						<span>Rate and discuss their favorites</span>
					</div>
					<div class="feature-item">
						<div class="feature-icon">🏗️</div>
						<span>Help fill out the words database</span>
					</div>
				</div>
			</div>
		</div>

        <div class="filter-section">
            <div class="filter-controls">
                <label>Sort by:</label>
                <select id="sortFilter">
                    <option value="episode">Episode Number</option>
                    <option value="overall">Overall Rating</option>
                    <option value="lyrics">Lyrics Rating</option>
                    <option value="beats">Beats Rating</option>
                    <option value="reaction">Reaction Rating</option>
                </select>
                
                <label>Min Rating:</label>
                <select id="ratingFilter">
                    <option value="0">All Videos</option>
                    <option value="3">3+ Stars</option>
                    <option value="4">4+ Stars</option>
                    <option value="5">5 Stars Only</option>
                </select>

                <input type="text" id="searchFilter" placeholder="Search by words or episode...">
            </div>
        </div>

        <div id="loadingMessage" class="loading">
            Loading Harry Mack videos and community ratings...
        </div>

        <div class="video-grid" id="videoGrid" style="display: none;">
        </div>

        <div class="stats-bar" id="statsBar" style="display: none;">
            <h3 style="margin-bottom: 20px;">Global Community Stats</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-number" id="totalRatings">0</div>
                    <div class="stat-label">Total Ratings</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="avgOverall">0.0</div>
                    <div class="stat-label">Avg Overall Rating</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="activeUsers">0</div>
                    <div class="stat-label">Community Members</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="topEpisode">#--</div>
                    <div class="stat-label">Highest Rated Episode</div>
                </div>
            </div>
        </div>
    </div>

	<div class="disclaimer-banner">
		<p><strong>Disclaimer:</strong> This is an independent fan-created rating platform. We are not affiliated with, endorsed by, or connected to Harry Mack or his representatives. All content is for educational and commentary purposes under Fair Use.</p>
	</div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-app-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-auth-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-firestore-compat.min.js"></script>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBUtq7jUntXqH0C0V2fDR1fwh2yPoZJAls",
            authDomain: "harry-mack-community.firebaseapp.com",
            projectId: "harry-mack-community",
            storageBucket: "harry-mack-community.firebasestorage.app",
            messagingSenderId: "1035009511388",
            appId: "1:1035009511388:web:23b2e932da2ac74466c919"
        };

        let app, auth, db;
        let currentUser = null;
        let isSigningIn = false;
        let videos = [];
        let userRatings = {};


        let realtimeUpdateTimeout = null; // Add this to debounce real-time updates
		let userNotes = {};
		let isSavingNote = false;
		let editingNotes = {};
		let isSubmittingRating = false; // ADD THIS LINE
		
		// Note configuration
		const MAX_NOTE_LENGTH = 1000;
				
        // Default ratings structure
        const defaultRatings = {
            lyrics: { average: 3.0, count: 0 },
            beats: { average: 3.0, count: 0 },
            reaction: { average: 3.0, count: 0 },
            overall: { average: 3.0, count: 0 }
        };

        // Debug mode flag
        const DEBUG_EPISODE_2 = true;


		function convertWordsObjectToArray(wordsData) {
			console.log('🔍 Converting words data:', JSON.stringify(wordsData, null, 2));
			
			if (!wordsData) {
				return [
					[{word: 'word1', votes: 5, voters: []}],
					[{word: 'word2', votes: 5, voters: []}],
					[{word: 'word3', votes: 5, voters: []}]
				];
			}

			// If it's already the correct format (array of arrays), return as-is
			if (Array.isArray(wordsData) && wordsData.length > 0 && Array.isArray(wordsData[0])) {
				console.log('✅ Already in correct array format');
				return wordsData;
			}

			// NEW: Handle the Firebase object format from bulkUpdateWords
			if (typeof wordsData === 'object' && !Array.isArray(wordsData)) {
				console.log('🔄 Converting from Firebase object format (bulkUpdateWords)');
				const result = [];
				
				// Convert object keys back to array positions
				Object.keys(wordsData).sort((a, b) => parseInt(a) - parseInt(b)).forEach(positionKey => {
					const wordPosition = wordsData[positionKey];
					const candidates = [];
					
					if (wordPosition && typeof wordPosition === 'object') {
						// Get the first candidate (index 0)
						if (wordPosition[0] && wordPosition[0].word) {
							candidates.push({
								word: wordPosition[0].word,
								votes: wordPosition[0].votes || 1,
								voters: wordPosition[0].voters || []
							});
						}
					}
					
					if (candidates.length === 0) {
						candidates.push({word: `word${result.length + 1}`, votes: 1, voters: []});
					}
					
					result.push(candidates);
				});
				
				// Ensure exactly 3 word positions
				while (result.length < 3) {
					result.push([{word: `word${result.length + 1}`, votes: 1, voters: []}]);
				}
				
				console.log('✅ Converted to array format:', result);
				return result;
			}

			// Convert Firebase array format (existing logic)
			if (Array.isArray(wordsData)) {
				console.log('🔄 Converting from Firebase array-of-objects format');
				
				return wordsData.map((wordPosition, positionIndex) => {
					if (typeof wordPosition === 'object' && wordPosition !== null && !Array.isArray(wordPosition)) {
						const candidates = [];
						Object.keys(wordPosition).sort((a, b) => parseInt(a) - parseInt(b)).forEach(key => {
							const candidate = wordPosition[key];
							if (candidate && candidate.word) {
								candidates.push({
									word: candidate.word,
									votes: candidate.votes || 1,
									voters: candidate.voters || []
								});
							}
						});
						return candidates.length > 0 ? candidates : [{word: `word${positionIndex + 1}`, votes: 1, voters: []}];
					} else if (Array.isArray(wordPosition)) {
						return wordPosition;
					} else {
						return [{word: `word${positionIndex + 1}`, votes: 1, voters: []}];
					}
				});
			}

			// Fallback
			console.log('⚠️ Unknown format, creating defaults');
			return [
				[{word: 'word1', votes: 5, voters: []}],
				[{word: 'word2', votes: 5, voters: []}],
				[{word: 'word3', votes: 5, voters: []}]
			];
		}



		function sanitizeSegmentData(segment, videoId, segmentIndex) {
			console.log(`🔧 Sanitizing segment data for ${videoId}-${segmentIndex}:`, segment);
			
			const sanitized = {
				id: segment?.id || `segment_${videoId}_${segmentIndex + 1}`,
				ratings: segment?.ratings || { ...defaultRatings },
				words: []
			};

			if (segment?.words) {
				console.log(`🔄 Processing words for ${videoId}-${segmentIndex}`);
				try {
					sanitized.words = convertWordsObjectToArray(segment.words);
					
					// ENSURE EXACTLY 3 WORDS PER SEGMENT
					while (sanitized.words.length < 3) {
						sanitized.words.push([{word: `word${sanitized.words.length + 1}`, votes: 5, voters: []}]);
					}
					if (sanitized.words.length > 3) {
						sanitized.words = sanitized.words.slice(0, 3);
					}
					
					console.log(`✅ Words processed for ${videoId}-${segmentIndex}, exactly ${sanitized.words.length} words`);
				} catch (conversionError) {
					console.warn(`⚠️ Error converting words for ${videoId}-${segmentIndex}:`, conversionError);
					sanitized.words = [
						[{word: 'word1', votes: 5, voters: []}],
						[{word: 'word2', votes: 5, voters: []}],
						[{word: 'word3', votes: 5, voters: []}]
					];
				}
			} else {
				console.warn(`⚠️ No words found for ${videoId}-${segmentIndex}, creating default`);
				sanitized.words = [
					[{word: 'word1', votes: 5, voters: []}],
					[{word: 'word2', votes: 5, voters: []}],
					[{word: 'word3', votes: 5, voters: []}]
				];
			}

			console.log(`✅ Sanitized segment for ${videoId}-${segmentIndex}:`, sanitized);
			return sanitized;
		}


      

        // NEW: Calculate weighted video ratings from segment ratings
        function calculateVideoOverallRating(video) {
            console.log(`🧮 Calculating weighted video rating for Episode ${video.episodeNumber}`);
            
            if (!video.segments || video.segments.length === 0) {
                console.log('⚠️ No segments found, using default ratings');
                return { ...defaultRatings };
            }

            const categories = ['lyrics', 'beats', 'reaction', 'overall'];
            const videoRatings = {};

            categories.forEach(category => {
                let totalWeightedScore = 0;
                let totalRatingCount = 0;

                // Sum up weighted scores from all segments
                video.segments.forEach(segment => {
                    if (segment.ratings && segment.ratings[category]) {
                        const segmentRating = segment.ratings[category];
                        const average = segmentRating.average || 0;
                        const count = segmentRating.count || 0;
                        
                        totalWeightedScore += (average * count);
                        totalRatingCount += count;
                    }
                });

                // Calculate weighted average
                const weightedAverage = totalRatingCount > 0 ? totalWeightedScore / totalRatingCount : 0;
                
                videoRatings[category] = {
                    average: Math.max(0, Math.min(5, weightedAverage)), // Clamp between 0-5
                    count: totalRatingCount
                };

                console.log(`📊 ${category}: ${weightedAverage.toFixed(2)}★ (${totalRatingCount} total ratings)`);
            });

            return videoRatings;
        }

        // NEW: Update video rating and refresh UI
        function updateVideoRatingDisplay(video) {
            console.log(`🎨 Updating video rating display for Episode ${video.episodeNumber}`);
            
            // Find the video card in the DOM
            const videoCards = document.querySelectorAll('.video-card');
            let targetCard = null;
            
            videoCards.forEach(card => {
                const starsElement = card.querySelector('[data-video]');
                if (starsElement && starsElement.dataset.video === video.episodeNumber.toString()) {
                    targetCard = card;
                }
            });

            if (!targetCard) {
                console.log('⚠️ Video card not found in DOM');
                return;
            }

            // Update the overall rating display
            const ratingStats = targetCard.querySelector('.overall-rating .rating-stats');
            if (ratingStats) {
                ratingStats.textContent = `${video.ratings.overall.average.toFixed(1)}★ (${video.ratings.overall.count} ratings)`;
            }

            // Update the stars display
            const starsContainer = targetCard.querySelector('.overall-rating .stars');
            if (starsContainer) {
                updateStarDisplay(starsContainer, video.ratings.overall.average, false);
            }

            console.log(`✅ Updated display: ${video.ratings.overall.average.toFixed(1)}★ (${video.ratings.overall.count} ratings)`);
        }


		function generateDefaultSegments() {
			console.log('🔧 Generating exactly 3 default segments...');
			const wordBank = ["pizza", "galaxy", "thunderstorm", "basketball", "dragon", "coffee"];
			const segments = [];
			
			// Always create exactly 3 segments
			for (let j = 0; j < 3; j++) {
				const segmentWords = [];
				
				// Always generate exactly 3 words per segment
				for (let k = 0; k < 3; k++) {
					const candidateWords = [];
					const baseWord = wordBank[Math.floor(Math.random() * wordBank.length)];
					
					candidateWords.push({
						word: baseWord,
						votes: Math.floor(Math.random() * 10) + 5,
						voters: []
					});
					
					segmentWords.push(candidateWords);
				}
				
				segments.push({
					id: `default_segment_${j + 1}`,
					words: segmentWords,
					ratings: { ...defaultRatings }
				});
			}
			
			console.log(`✅ Generated exactly ${segments.length} segments`);
			return segments;
		}


		function ensureExactly3Segments(segments, episodeNumber) {
			console.log(`🔧 Ensuring exactly 3 segments for Episode ${episodeNumber}, currently has ${segments.length}`);
			
			const result = [];
			
			// Take up to 3 existing segments
			for (let i = 0; i < 3; i++) {
				if (i < segments.length) {
					// Use existing segment
					result.push(segments[i]);
				} else {
					// Create missing segment
					const newSegment = {
						id: `segment_${episodeNumber}_${i + 1}`,
						words: [
							[{word: 'word1', votes: 5, voters: []}],
							[{word: 'word2', votes: 5, voters: []}],
							[{word: 'word3', votes: 5, voters: []}]
						],
						ratings: { ...defaultRatings }
					};
					result.push(newSegment);
					console.log(`✅ Created missing segment ${i + 1} for Episode ${episodeNumber}`);
				}
			}
			
			console.log(`✅ Episode ${episodeNumber} now has exactly ${result.length} segments`);
			return result;
		}



        async function initializeFirebase() {
            try {
                console.log('🔥 Initializing Firebase...');
                app = firebase.initializeApp(firebaseConfig);
                auth = firebase.auth();
                db = firebase.firestore();
                
                console.log('✅ Firebase services initialized');
                console.log('🔒 Setting auth persistence...');
                
                await auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);
                console.log('✅ Auth persistence set');
                
                console.log('🔄 Checking for redirect result...');
                try {
                    const result = await auth.getRedirectResult();
                    console.log('🔄 Redirect result:', result);
                    
                    if (result.user) {
                        console.log('👤 User signed in via redirect:', result.user.email);
                        showNotification(`Welcome ${result.user.displayName || result.user.email}! You're now signed in.`, 'success');
                        handleAuthStateChange(result.user);
                    } else if (result.credential) {
                        console.log('🔑 Got credential but no user - possible error');
                    } else {
                        console.log('ℹ️ No redirect result - normal page load');
                    }
                } catch (redirectError) {
                    console.error('❌ Redirect error:', redirectError);
                    console.error('❌ Error code:', redirectError.code);
                    console.error('❌ Error message:', redirectError.message);
                    
                    if (redirectError.code === 'auth/unauthorized-domain') {
                        showNotification('This domain is not authorized. Please add it to Firebase.', 'error');
                    } else if (redirectError.code !== 'auth/redirect-cancelled-by-user') {
                        showNotification(`Sign in failed: ${redirectError.message}`, 'error');
                    }
                }

                auth.onAuthStateChanged((user) => {
                    console.log('🔄 Auth state changed:', user ? user.email : 'No user');
                    if (user) {
                        isSigningIn = false;
                    }
                    handleAuthStateChange(user);
                });
                
                const currentUser = auth.currentUser;
                console.log('👤 Current user on init:', currentUser ? currentUser.email : 'None');
                
                // Test Firestore permissions
                console.log('🧪 Testing Firestore read permissions...');
                try {
                    await db.collection('videos').limit(1).get();
                    console.log('✅ Firestore read permission confirmed');
                } catch (permError) {
                    console.error('❌ Firestore permission error:', permError);
                    throw permError;
                }
                
                console.log('📊 Starting to load videos data...');
                loadVideosData();
                updateConnectionStatus('connected');
                
            } catch (error) {
                console.error('❌ Firebase initialization failed:', error);
                console.error('❌ Error details:', error.message, error.code);
                handleFirebaseError();
            }
        }

        function handleFirebaseError() {
            updateConnectionStatus('demo');
            showNotification('Running in demo mode.  Log in to rate videos!', 'info');
            initializeDemoMode();
        }

        function initializeDemoMode() {
            generateSampleVideos();
            renderVideos();
            updateStats();
            
            document.getElementById('loadingMessage').style.display = 'none';
            document.getElementById('videoGrid').style.display = 'grid';
            document.getElementById('statsBar').style.display = 'block';
        }

        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            
            statusElement.className = 'connection-status status-' + status;
            
            switch(status) {
                case 'connected':
                    statusText.textContent = '🟢 Live';
                    break;
                case 'disconnected':
                    statusText.textContent = '🔴 Offline';
                    break;
                case 'demo':
                    statusText.textContent = '🟡 Demo Mode';
                    break;
                case 'connecting':
                    statusText.textContent = '🟡 Loading...';
                    break;
            }
        }

 

		function handleAuthStateChange(user) {
			currentUser = user;
			
			const userInfo = document.getElementById('userInfo');
			const userName = document.getElementById('userName');
			const authButton = document.getElementById('authButton');

			if (user) {
				userInfo.style.display = 'block';
				userName.textContent = user.displayName || user.email;
				authButton.innerHTML = 'Sign Out';
				authButton.onclick = signOut;
				
				loadUserRatings();
				loadUserNotes(); 
				
				if (db) updateConnectionStatus('connected');
				
				// ADD THIS LINE - Check admin access
				checkAdminAccess();
				
			} else {
				userInfo.style.display = 'none';
				authButton.innerHTML = '<img class="google-icon" src="https://developers.google.com/identity/images/g-logo.png" alt="Google logo">Sign in with Google';
				authButton.onclick = signIn;
				userRatings = {};
				userNotes = {};
				editingNotes = {};
				
				// ADD THIS LINE - Hide admin features when signed out
				checkAdminAccess();
			}
		}



        async function signIn() {
            if (!auth) {
                showNotification('Authentication not available in demo mode', 'info');
                return;
            }
            
            if (isSigningIn) {
                console.log('Sign-in already in progress');
                return;
            }
            
            console.log('Sign in button clicked');
            console.log('Current URL:', window.location.href);
            console.log('Auth domain:', firebaseConfig.authDomain);
            
            const provider = new firebase.auth.GoogleAuthProvider();
            provider.addScope('profile');
            provider.addScope('email');
            
            try {
                isSigningIn = true;
                console.log('Starting popup sign in...');
                showNotification('Opening Google sign-in popup...', 'info');
                
                const result = await auth.signInWithPopup(provider);
                
                console.log('Sign in successful:', result.user);
                showNotification('Successfully signed in!', 'success');
                
            } catch (error) {
                console.error('Sign in error:', error);
                
                if (error.code === 'auth/operation-not-allowed') {
                    showNotification('Google sign-in is not enabled in Firebase Console', 'error');
                } else if (error.code === 'auth/unauthorized-domain') {
                    showNotification('This domain is not authorized in Firebase', 'error');
                } else if (error.code === 'auth/popup-closed-by-user') {
                    showNotification('Sign-in popup was closed. Please try again.', 'info');
                } else if (error.code === 'auth/popup-blocked') {
                    showNotification('Sign-in popup was blocked by browser. Please allow popups and try again.', 'error');
                } else if (error.code === 'auth/cancelled-popup-request') {
                    showNotification('Another sign-in popup is already open. Please complete that first.', 'info');
                } else {
                    showNotification(`Sign in failed: ${error.message}`, 'error');
                }
            } finally {
                isSigningIn = false;
            }
        }

        async function signOut() {
            if (auth) {
                try {
                    await auth.signOut();
                    showNotification('You have been signed out.', 'info');
                } catch (error) {
                    console.error('Sign out error:', error);
                    showNotification('Error signing out. Please try again.', 'error');
                }
            }
        }

        async function loadVideosData() {
            try {
                if (!db) {
                    console.log('No database connection - using demo mode');
                    initializeDemoMode();
                    return;
                }

                console.log('✅ Database connected, loading videos from Firebase...');
                console.log('📊 Querying videos collection...');
                
                const videosSnapshot = await db.collection('videos').orderBy('episodeNumber').get();
                console.log('📋 Query completed. Documents found:', videosSnapshot.size);
                
                if (videosSnapshot.empty) {
                    console.log('📝 No videos found - initializing sample data...');
                    await initializeFirebaseData();
                    console.log('✅ Sample data initialized successfully');
                } else {
                    console.log('📖 Loading existing videos from Firebase...');
                    videos = [];
                    
                    videosSnapshot.docs.forEach(doc => {
                        const data = doc.data();
                        console.log(`📄 Processing video: Episode ${data.episodeNumber}`);
                        
                        if (data.episodeNumber === 2 && DEBUG_EPISODE_2) {
                            console.log('🔍 EPISODE 2 DEBUG - Raw data:', JSON.stringify(data, null, 2));
                        }

                        let processedSegments = [];

                        if (data.episodeNumber === 2) {
                            console.log('🔧 FIXING EPISODE 2 DATA - Detected incomplete structure');
                            
                            const isCorrupted = !data.segments || 
                                               Object.keys(data.segments).length < 2 || 
                                               !Object.values(data.segments).some(seg => seg.words);
                            
                            if (isCorrupted) {
                                console.log('⚠️ Episode 2 data is corrupted, regenerating...');
                                
                                const wordBank = ["freestyle", "microphone", "talent", "creativity", "improvise", "rhythm"];
                                const newSegments = [];
                                
                                for (let j = 0; j < 3; j++) {
                                    const segmentWords = [];
                                    
                                    for (let k = 0; k < 3; k++) {
                                        const candidateWords = [];
                                        const baseWord = wordBank[Math.floor(Math.random() * wordBank.length)];
                                        
                                        candidateWords.push({
                                            word: baseWord,
                                            votes: Math.floor(Math.random() * 10) + 5,
                                            voters: []
                                        });
                                        
                                        segmentWords.push(candidateWords);
                                    }
                                    
                                    newSegments.push({
                                        id: `segment_2_${j + 1}`,
                                        words: segmentWords,
                                        ratings: {
                                            lyrics: { average: 3.5 + Math.random(), count: 15 + Math.floor(Math.random() * 10) },
                                            beats: { average: 3.8 + Math.random(), count: 18 + Math.floor(Math.random() * 12) },
                                            reaction: { average: 3.2 + Math.random(), count: 12 + Math.floor(Math.random() * 8) },
                                            overall: { average: 3.5 + Math.random(), count: 14 + Math.floor(Math.random() * 6) }
                                        }
                                    });
                                }
                                
                                processedSegments = newSegments;
                                console.log('✅ Episode 2 data regenerated with', processedSegments.length, 'segments');
                                console.log('ℹ️ Episode 2 fixed locally only - skipping Firebase save');
                                
                            } else {
                                const segmentValues = Object.values(data.segments);
                                processedSegments = segmentValues.map((segment, idx) => 
                                    sanitizeSegmentData(segment, data.episodeNumber, idx)
                                );
                            }
							
                        
						//added this on June 8, 2025
						} else if (data.segments && Array.isArray(data.segments)) {
					console.log(`✅ Valid segments array with ${data.segments.length} items`);
					let tempSegments = data.segments.map((segment, idx) => 
						sanitizeSegmentData(segment, data.episodeNumber, idx)
					);
					
					// FORCE EXACTLY 3 SEGMENTS
					processedSegments = ensureExactly3Segments(tempSegments, data.episodeNumber);
					
				} else if (data.segments && typeof data.segments === 'object') {
					console.log(`🔄 Converting segments object to array`);
					const segmentValues = Object.values(data.segments);
					let tempSegments = segmentValues.map((segment, idx) => 
						sanitizeSegmentData(segment, data.episodeNumber, idx)
					);
					
					// FORCE EXACTLY 3 SEGMENTS
					processedSegments = ensureExactly3Segments(tempSegments, data.episodeNumber);
					
				} else {
					console.log(`⚠️ No valid segments found for Episode ${data.episodeNumber}`);
					processedSegments = generateDefaultSegments();
				}


				
						
						
						
                        const processedVideo = {
                            id: doc.id,
                            episodeNumber: data.episodeNumber,
                            title: data.title || `Omegle Bars Episode #${data.episodeNumber}`,
                            youtubeId: getYouTubeId(data.episodeNumber),
                            segments: processedSegments,
                            ratings: data.ratings || { ...defaultRatings }
                        };
                        
                        // 🔥 NEW: Recalculate video ratings from segments (in case stored ratings are outdated)
                        if (processedSegments.length > 0) {
                            console.log(`🔄 Recalculating video ratings for Episode ${data.episodeNumber}`);
                            processedVideo.ratings = calculateVideoOverallRating(processedVideo);
                        }
                        
                        videos.push(processedVideo);
                        console.log(`✅ Processed Episode ${data.episodeNumber} with ${processedSegments.length} segments`);
                    });
                    
                    console.log(`✅ Successfully loaded ${videos.length} videos`);
                }
                
                console.log('🎨 Starting to render videos...');
                try {
                    renderVideos();
                    updateStats();
                    document.getElementById('loadingMessage').style.display = 'none';
                    document.getElementById('videoGrid').style.display = 'grid';
                    document.getElementById('statsBar').style.display = 'block';
                    updateConnectionStatus('connected');
                    console.log('✅ Videos loaded and rendered successfully!');
                } catch (renderError) {
                    console.error('❌ Error during rendering (keeping loaded data):', renderError);
                    showNotification('Error rendering videos. Data loaded but display may be incomplete.', 'error');
                    
                    document.getElementById('loadingMessage').style.display = 'none';
                    document.getElementById('videoGrid').style.display = 'grid';
                    document.getElementById('statsBar').style.display = 'block';
                    updateConnectionStatus('connected');
                }
                
            } catch (error) {
                console.error('❌ Error loading videos:', error);
                showNotification('Error loading videos. Using demo data.', 'error');
                initializeDemoMode();
            }
        }

        async function initializeFirebaseData() {
            console.log('🚀 Starting to generate sample videos...');
            const sampleVideos = generateSampleVideos();
            console.log(`📊 Generated ${sampleVideos.length} sample videos`);
            
            if (db) {
                try {
                    console.log('💾 Saving sample data to Firebase...');
                    const batch = db.batch();
                    sampleVideos.forEach((video, index) => {
                        const docRef = db.collection('videos').doc(`episode_${video.episodeNumber}`);
                        batch.set(docRef, video);
                        if (index < 3) {
                            console.log(`📄 Preparing to save Episode ${video.episodeNumber}:`, video.title);
                        }
                    });
                    
                    console.log('⏳ Committing batch write to Firebase...');
                    await batch.commit();
                    console.log('✅ Sample data saved to Firebase successfully!');
                } catch (batchError) {
                    console.error('❌ Error saving to Firebase:', batchError);
                    throw batchError;
                }
            } else {
                console.log('⚠️ No database connection - keeping data in memory only');
            }
            
            videos = sampleVideos;
            console.log(`✅ Videos array populated with ${videos.length} items`);
        }

        function getYouTubeId(episodeNumber) {
            const youtubeIds = [
                'NPdKxsSE5JQ',  // Episode 1
                'BgCUCg9aMyA',  // Episode 2
                '37duQAUSYXo',  // Episode 3
                'jrNapeXr3TY',  // Episode 4
                'Gh7Wbix9UwY',  // Episode 5
                'dwFhTq5x0Tc',  // Episode 6
                '75j7pEjRAIQ',  // Episode 7
                'O6ve-5b_x5U',  // Episode 8
                'oxuUDgOdoRw',  // Episode 9
                '7GAuu0Ro9PM',  // Episode 10
                'Rqv6oiyddn8',  // Episode 11
                'hZcpRm80EBk',  // Episode 12
                '6c5Y47TYQWQ',  // Episode 13
                'Ap4dVD_CRm8',  // Episode 14
                'lt0r0JNDeeo',  // Episode 15
                'XTfaaoBRjvs',  // Episode 16
                'QwnqI4dyPI8',  // Episode 17
                'VBBMfHGMs7I',  // Episode 18
                'EWThDBgYj9U',  // Episode 19
                'Tf84L54lSTE',  // Episode 20
                're1sJCcYZy4',  // Episode 21
                '3Y-0TUj1amk',  // Episode 22
                'JeRZWJ7NMGU',  // Episode 23
                'ZC6kl6ohAjo',  // Episode 24
                '1kN6LAf_7eg',  // Episode 25
                'U6dbmuCfdyk',  // Episode 26
                'dlnQOB15Sq8',  // Episode 27
                'ZOhE4fUduUU',  // Episode 28
                '2JHSSISCVww',  // Episode 29
                'vtjdWxFcOc4',  // Episode 30
                'fP4SftKI4LQ',  // Episode 31
                'Z3FjhBuFKyM',  // Episode 32
                'p-GYLYqpTP8',  // Episode 33
                'PPS8RLQkw04',  // Episode 34
                'YPLX5YpSMfI',  // Episode 35
                'QaD5-e6hjmY',  // Episode 36
                '1XZJKKNopEw',  // Episode 37
                'eStSbs0PklY',  // Episode 38
                'dkcnYy_VjRc',  // Episode 39
                '4dMm3q1rldE',  // Episode 40
                '25ceuw4CuK8',  // Episode 41
                'wy6qazFc2FQ',  // Episode 42
                'oXI3ysg3s3s',  // Episode 43
                'UlIzq76NZJA',  // Episode 44
                'OBM1UVnsQQo',  // Episode 45
                'KSc0UuBLRhg',  // Episode 46
                'n1K9P5Dtph4',  // Episode 47
                '5yTm4j6KaBQ',  // Episode 48
                '1dfh0G8Ik1c',  // Episode 49
                '-pRhkKkM2Ms',  // Episode 50
                'mwWw-1t3hyw',  // Episode 51
                '3ZhcM7-bh4c',  // Episode 52
                'Js2Q8tJLgig',  // Episode 53
                'eX9uZQoXAdY',  // Episode 54
                'AYc7Q6CSeGE',  // Episode 55
                'Djm0fwEX9ls',  // Episode 56
                'UI2qbARbQEw',  // Episode 57
                'sfFpAz8ZHVg',  // Episode 58
                'CKnUOb6My5Y',  // Episode 59
                'BbcTwW_aKxI',  // Episode 60
                'I0ng6LIjAOg',  // Episode 61
                'g25N4i6leas',  // Episode 62
                'abuAR-yoWSU',  // Episode 63
                'izM7RQctoPc',  // Episode 64
                'BNC68gQluSE',  // Episode 65
                'TJk3eDFwiaY',  // Episode 66
                'FxLKfWt3Kq4',  // Episode 67
                'QaRkdWCTKkM',  // Episode 68
                'O9AxmMO9xKw',  // Episode 69
                'AO0yvg0pLiM',  // Episode 70
                'qQKgwgWzg58',  // Episode 71
                'xqCEjV48TWA',  // Episode 72
                'SnJpkJ0or5o',  // Episode 73
                '2kfaZHwzda8',  // Episode 74
                '4yeyJVkbX8Y',  // Episode 75
                'Xm8Z4bGH_Ok',  // Episode 76
                'yxb2mb4wkF4',  // Episode 77
                'NKtwLntS4Pg',  // Episode 78
                'MiU7GJYeTas',  // Episode 79
                'TwRATtm76cI',  // Episode 80
                'bt0DLDPVE1M',  // Episode 81
                '6Phbw1vg5Wc',  // Episode 82
                '16xwgMHig-A',  // Episode 83
                'REllMQ6EQi8',  // Episode 84
                '6mfIBMQMYTw',  // Episode 85
                'gBgJRYcIcWA',  // Episode 86
                'WG0ZmvMYVrM',  // Episode 87
                'cXKJ3uv_XIk',  // Episode 88
                '_SZbXNGBWGk',  // Episode 89 
                'uhiwj4ho4V4',  // Episode 90
                'qG37EIdryFo',  // Episode 91
                'hr6sqlk73AI',  // Episode 92
                'rjBtpTI0MAc',  // Episode 93
                'bJgAtUirT7I',  // Episode 94
                '1suTTTUn7iA',  // Episode 95
                'TFaKz7SQsgg',  // Episode 96
                'qlfHCE9nl34',  // Episode 97
                'vL4W6n--r5A',  // Episode 98
                '-70WqAfeEYE',  // Episode 99
                'ijVGIcVRIbk',  // Episode 100
                '6sYh6iuMUA8',  // Episode 101
                'elpFOcnxTZY',  // Episode 102
                'sfAjqVYDISQ',  // Episode 103
                'BXFq6Y1iW7k',  // Episode 104
                'E6dqj45rjlE',  // Episode 105
                '2bMkeJ6Vu2s',  // Episode 106
                'HuCyL-QEIhQ',  // Episode 107
                '6u8Yt12uZnk',  // Episode 108
                'dfAQMcKqxM0',  // Episode 109
                'jSZmrM-1qpw'   // Episode 110
            ];
            
            const index = episodeNumber - 1;
            
            if (index >= 0 && index < youtubeIds.length) {
                return youtubeIds[index];
            }
            
            return youtubeIds[index % youtubeIds.length];
        }


		function generateSampleVideos() {
			const wordBank = [
				"pizza", "galaxy", "thunderstorm", "basketball", "dragon", "coffee",
				"telephone", "rainbow", "adventure", "elephant", "computer", "sunshine",
				"bicycle", "ocean", "chocolate", "butterfly", "mountain", "music",
				"spaceship", "burger", "lightning", "guitar", "forest", "diamond",
				"robot", "sunset", "library", "airplane", "wizard", "sandwich",
				"telescope", "volcano", "penguin", "keyboard", "tornado", "ice cream"
			];

			const sampleVideos = [];
			
			for (let i = 1; i <= 100; i++) {
				const segments = [];
				
				// Always create exactly 3 segments per video
				for (let j = 0; j < 3; j++) {
					const segmentWords = [];
					
					// Always create exactly 3 words per segment
					for (let k = 0; k < 3; k++) {
						const candidateWords = [];
						
						const baseWordIndex = Math.floor(Math.random() * wordBank.length);
						const baseWord = wordBank[baseWordIndex];
						
						// Just create one word per position (no alternatives)
						candidateWords.push({
							word: baseWord,
							votes: Math.floor(Math.random() * 15) + 10,
							voters: []
						});
						
						segmentWords.push(candidateWords);
					}
					
					const lyrics = Math.random() * 2 + 3;
					const beats = Math.random() * 2 + 3;
					const reaction = Math.random() * 2 + 3;
					const overall = (lyrics + beats + reaction) / 3 + (Math.random() * 0.6 - 0.3);
					
					const baseRatingCount = Math.floor(Math.random() * 50) + 5;
					
					segments.push({
						id: `segment_${i}_${j + 1}`,
						words: segmentWords,
						ratings: {
							lyrics: { 
								average: Math.max(1, Math.min(5, lyrics)),
								count: baseRatingCount + Math.floor(Math.random() * 10) 
							},
							beats: { 
								average: Math.max(1, Math.min(5, beats)), 
								count: baseRatingCount + Math.floor(Math.random() * 12) 
							},
							reaction: { 
								average: Math.max(1, Math.min(5, reaction)), 
								count: baseRatingCount + Math.floor(Math.random() * 15) 
							},
							overall: { 
								average: Math.max(1, Math.min(5, overall)), 
								count: baseRatingCount + Math.floor(Math.random() * 8) 
							}
						}
					});
				}

				// Calculate video ratings from the 3 segments
				const videoLyrics = segments.reduce((sum, seg) => sum + seg.ratings.lyrics.average, 0) / 3;
				const videoBeats = segments.reduce((sum, seg) => sum + seg.ratings.beats.average, 0) / 3;
				const videoReaction = segments.reduce((sum, seg) => sum + seg.ratings.reaction.average, 0) / 3;
				const videoOverall = segments.reduce((sum, seg) => sum + seg.ratings.overall.average, 0) / 3;
				
				const totalSegmentRatings = segments.reduce((sum, seg) => 
					sum + seg.ratings.lyrics.count + seg.ratings.beats.count + seg.ratings.reaction.count + seg.ratings.overall.count, 0);

				const video = {
					episodeNumber: i,
					title: `Omegle Bars Episode #${i}`,
					youtubeId: getYouTubeId(i),
					segments: segments, // Always exactly 3 segments
					ratings: {
						lyrics: { 
							average: videoLyrics,
							count: Math.floor(totalSegmentRatings * 0.25) 
						},
						beats: { 
							average: videoBeats, 
							count: Math.floor(totalSegmentRatings * 0.25) 
						},
						reaction: { 
							average: videoReaction, 
							count: Math.floor(totalSegmentRatings * 0.25) 
						},
						overall: { 
							average: videoOverall, 
							count: Math.floor(totalSegmentRatings * 0.25) 
						}
					}
				};

				sampleVideos.push(video);
			}
			
			videos = sampleVideos;
			console.log(`✅ Generated ${sampleVideos.length} videos with exactly 3 segments each`);
			return sampleVideos;
		}

        

        async function loadUserRatings() {
            if (!currentUser || !db) return;

            try {
                const ratingsSnapshot = await db.collection('userRatings')
                    .where('userId', '==', currentUser.uid)
                    .get();
                
                userRatings = {};
                
                ratingsSnapshot.docs.forEach(doc => {
                    const data = doc.data();
                    if (data.segmentId) {
                        if (!userRatings[data.videoId]) {
                            userRatings[data.videoId] = { segments: {} };
                        }
                        userRatings[data.videoId].segments[data.segmentId] = data.ratings;
                    } else {
                        if (!userRatings[data.videoId]) {
                            userRatings[data.videoId] = {};
                        }
                        userRatings[data.videoId].video = data.ratings;
                    }
                });
                
                updateUserRatingDisplay();
                
            } catch (error) {
                console.error('Error loading user ratings:', error);
            }
        }
 
         
		 
		 function updateUserRatingDisplay() {
			setTimeout(() => {
				Object.keys(userRatings).forEach(videoId => {
					if (userRatings[videoId].segments) {
						Object.keys(userRatings[videoId].segments).forEach(segmentId => {
							const segmentRatings = userRatings[videoId].segments[segmentId];
							const categories = ['lyrics', 'beats', 'reaction', 'overall'];
							
							categories.forEach(category => {
								const rating = segmentRatings[category];
								const starsContainer = document.querySelector(`[data-video="${videoId}"][data-segment="${segmentId}"][data-category="${category}"]`)?.closest('.stars');
								if (starsContainer) {
									// Pass true for userRated only if they actually rated it
									updateStarDisplay(starsContainer, rating, rating > 0);
									
									const controls = starsContainer.closest('.rating-controls');
									if (controls) {
										// Remove existing indicator
										const existingIndicator = controls.querySelector('.user-rating-indicator');
										if (existingIndicator) {
											existingIndicator.remove();
										}
										
										// Add new indicator only if user has rated
										if (rating > 0) {
											const indicator = document.createElement('div');
											indicator.className = 'user-rating-indicator';
											indicator.textContent = `Your rating: ${rating}★`;
											controls.appendChild(indicator);
										}
									}
								}
							});
						});
					}
					
					if (userRatings[videoId].video) {
						const videoRatings = userRatings[videoId].video;
						const categories = ['lyrics', 'beats', 'reaction', 'overall'];
						
						categories.forEach(category => {
							const rating = videoRatings[category];
							const starsContainer = document.querySelector(`[data-video="${videoId}"][data-category="${category}"]:not([data-segment])`)?.closest('.stars');
							if (starsContainer) {
								// Pass true for userRated only if they actually rated it
								updateStarDisplay(starsContainer, rating, rating > 0);
								
								const controls = starsContainer.closest('.rating-controls');
								if (controls) {
									// Remove existing indicator
									const existingIndicator = controls.querySelector('.user-rating-indicator');
									if (existingIndicator) {
										existingIndicator.remove();
									}
									
									// Add new indicator only if user has rated
									if (rating > 0) {
										const indicator = document.createElement('div');
										indicator.className = 'user-rating-indicator';
										indicator.textContent = `Your rating: ${rating}★`;
										controls.appendChild(indicator);
									}
								}
							}
						});
					}
				});
			}, 100);
		}


		async function submitRating(videoId, category, rating, segmentId = null) {
			console.log(`🎯 Starting to submit rating: ${videoId}-${segmentId}-${category}-${rating}`);
 
			// Prevent multiple simultaneous rating submissions
			if (isSubmittingRating) {
				console.log('Already submitting a rating, please wait...');
				return;
			}
			
			isSubmittingRating = true; // SET FLAG TO PREVENT CONFLICTS
			
			

			// PRESERVE THE CURRENT EXPANDED STATE
			const currentSegment = segmentId ? document.querySelector(`.segment[data-segment="${segmentId}"]`) : null;
			const wasExpanded = currentSegment ? currentSegment.classList.contains('expanded') : false;



			try {
				// IMMEDIATE UI UPDATE - Update display first, before saving
				if (!userRatings[videoId]) {
					userRatings[videoId] = { segments: {} };
				}
				
				if (segmentId) {
					if (!userRatings[videoId].segments[segmentId]) {
						userRatings[videoId].segments[segmentId] = { lyrics: 0, beats: 0, reaction: 0, overall: 0 };
					}
					userRatings[videoId].segments[segmentId][category] = rating;
				} else {
					if (!userRatings[videoId].video) {
						userRatings[videoId].video = { lyrics: 0, beats: 0, reaction: 0, overall: 0 };
					}
					userRatings[videoId].video[category] = rating;
				}

				// IMMEDIATELY update the star display
				const starsContainer = segmentId ? 
					document.querySelector(`[data-video="${videoId}"][data-segment="${segmentId}"][data-category="${category}"]`)?.closest('.stars') :
					document.querySelector(`[data-video="${videoId}"][data-category="${category}"]:not([data-segment])`)?.closest('.stars');
				
				if (starsContainer) {
					updateStarDisplay(starsContainer, rating, true);
					
					// Update or add the "Your rating" indicator
					const controls = starsContainer.closest('.rating-controls');
					if (controls) {
						const existingIndicator = controls.querySelector('.user-rating-indicator');
						if (existingIndicator) {
							existingIndicator.textContent = `Your rating: ${rating}★`;
						} else {
							const indicator = document.createElement('div');
							indicator.className = 'user-rating-indicator';
							indicator.textContent = `Your rating: ${rating}★`;
							controls.appendChild(indicator);
						}
					}
				}

				// NOW save to Firebase (UI already updated)
				if (db) {
					const docId = segmentId ? 
						`${currentUser.uid}_${videoId}_${segmentId}` : 
						`${currentUser.uid}_${videoId}`;
					
					const ratingsData = {
						userId: currentUser.uid,
						videoId: videoId,
						ratings: segmentId ? userRatings[videoId].segments[segmentId] : userRatings[videoId].video,
						lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
					};
					
					if (segmentId) {
						ratingsData.segmentId = segmentId;
					}

					await db.collection('userRatings').doc(docId).set(ratingsData);
					//await updateVideoRating(videoId, category, rating, segmentId);
				}
				


				// Convert segment ID to display format with episode + segment letter
				let segmentText = '';
				if (segmentId) {
					// Find the video and segment to get the index
					const video = videos.find(v => v.episodeNumber.toString() === videoId);
					if (video && video.segments) {
						const segmentIndex = video.segments.findIndex(s => s.id === segmentId);
						if (segmentIndex !== -1) {
							const segmentLetter = String.fromCharCode(65 + segmentIndex); // 0→A, 1→B, 2→C
							segmentText = ` (Episode ${videoId}, Segment ${segmentLetter})`;
						} else {
							segmentText = ` (Episode ${videoId}, Segment ${segmentId})`; // Fallback to ID if not found
						}
					}
				} else {
					// For video-level ratings, just show episode
					segmentText = ` (Episode ${videoId})`;
				}

				showNotification(`Rated ${category}${segmentText}: ${rating} stars!`, 'success');





				
			} catch (error) {
				console.error('❌ RATING ERROR CAUGHT:', error);
				console.error('❌ ERROR DETAILS:', error.message);
				console.error('❌ ERROR STACK:', error.stack);
				console.error('Error submitting rating:', error);
				showNotification('Failed to save rating. Please try again.', 'error');
				
				// If save failed, revert the UI
				if (segmentId) {
					userRatings[videoId].segments[segmentId][category] = 0;
				} else {
					userRatings[videoId].video[category] = 0;
				}
				updateUserRatingDisplay();
				
			} finally {
				isSubmittingRating = false; // ALWAYS CLEAR FLAG WHEN DONE

				// RESTORE EXPANDED STATE IF IT WAS EXPANDED
				if (wasExpanded && currentSegment) {
					setTimeout(() => {
						currentSegment.classList.add('expanded');
						console.log('🔓 Restored expanded state for current segment');
					}, 100);
				}
					
			}
		}




        async function updateVideoRating(videoId, category, newRating, segmentId = null) {
            if (!db) return;

            try {
                const docId = segmentId ? `${videoId}_${segmentId}_${category}` : `${videoId}_${category}`;
                const ratingsRef = db.collection(segmentId ? 'segmentRatings' : 'ratings').doc(docId);
                
                await db.runTransaction(async (transaction) => {
                    const ratingsDoc = await transaction.get(ratingsRef);
                    
                    let totalRating = newRating;
                    let count = 1;
                    
                    if (ratingsDoc.exists) {
                        const data = ratingsDoc.data();
                        totalRating = data.totalRating + newRating;
                        count = data.count + 1;
                    }
                    
                    const average = totalRating / count;
                    
                    transaction.set(ratingsRef, {
                        totalRating: totalRating,
                        count: count,
                        average: average,
                        videoId: videoId,
                        category: category
                    });
                    
                    if (segmentId) {
                        transaction.set(ratingsRef, {
                            ...ratingsRef.data,
                            segmentId: segmentId
                        });
                    }
                    
                    const videoRef = db.collection('videos').doc(`episode_${videoId}`);
                    if (segmentId) {
                        transaction.update(videoRef, {
                            [`segments.${segmentId}.ratings.${category}.average`]: average,
                            [`segments.${segmentId}.ratings.${category}.count`]: count
                        });
                    } else {
                        transaction.update(videoRef, {
                            [`ratings.${category}.average`]: average,
                            [`ratings.${category}.count`]: count
                        });
                    }
                });
                
                // Update local data and recalculate video ratings
                const video = videos.find(v => v.episodeNumber.toString() === videoId);
                if (video) {
                    if (segmentId) {
                        const segment = video.segments.find(s => s.id === segmentId);
                        if (segment && segment.ratings) {
                            const currentData = segment.ratings[category];
                            const newTotal = (currentData.average * currentData.count) + newRating;
                            const newCount = currentData.count + 1;
                            segment.ratings[category] = { average: newTotal / newCount, count: newCount };
                            
                            // 🔥 NEW: Recalculate video overall rating from segments
                            console.log('🔄 Recalculating video rating after segment update...');
                            video.ratings = calculateVideoOverallRating(video);
                            
                            // Update only the video rating display (no full re-render)
                            updateVideoRatingDisplay(video);
                            updateStats();
                            
                            console.log(`✅ Video rating updated: ${video.ratings.overall.average.toFixed(1)}★`);
                        }
                    } else {
                        const currentData = video.ratings[category];
                        const newTotal = (currentData.average * currentData.count) + newRating;
                        const newCount = currentData.count + 1;
                        video.ratings[category] = { average: newTotal / newCount, count: newCount };
                        
                        // Update display for video-level ratings (legacy)
                        updateVideoRatingDisplay(video);
                        updateStats();
                    }
                }
            } catch (error) {
                console.error('Error updating rating:', error);
            }
        }
 






		// FIXED: createStarRating function - shows empty stars for unrated items when logged in
		function createStarRating(category, videoId, currentRating, ratingCount, segmentId = null) {
			let starsHtml = '';
			const ratingKey = segmentId ? 
				(userRatings[videoId]?.segments?.[segmentId]?.[category] || 0) : 
				(userRatings[videoId]?.video?.[category] || 0);

			// Determine what rating to display
			let displayRating = 0;
			if (currentUser) {
				// User is logged in - show their rating if they've voted, otherwise show empty
				displayRating = ratingKey > 0 ? ratingKey : 0;
			} else {
				// User not logged in - show average community rating
				displayRating = currentRating;
			}

			// Create exactly 5 stars
			for (let i = 1; i <= 5; i++) {
				const activeClass = i <= Math.round(displayRating) ? 'active' : '';
				const userRatedClass = ratingKey > 0 && i <= ratingKey ? 'user-rated' : '';
				
				const dataAttrs = segmentId ? 
					`data-rating="${i}" data-category="${category}" data-video="${videoId}" data-segment="${segmentId}"` : 
					`data-rating="${i}" data-category="${category}" data-video="${videoId}"`;
					
				starsHtml += `<span class="star ${activeClass} ${userRatedClass}" ${dataAttrs}>★</span>`;
			}
			
			return starsHtml;
		}
		

		function createWordCandidatesHtml(wordCandidates, videoId, segmentId, wordIndex) {
			console.log(`🔍 Processing word candidates for ${videoId}-${segmentId}-${wordIndex}:`, wordCandidates);
			
			let validCandidates = [];
			
			if (Array.isArray(wordCandidates)) {
				validCandidates = wordCandidates.filter(candidate => 
					candidate && 
					candidate.word && 
					typeof candidate.word === 'string' && 
					candidate.word.trim() !== '' &&
					!candidate.word.toLowerCase().includes('word') // Filter out placeholder words like "word1", "word2"
				);
			}
			
			// Check if we have a real word or just placeholder
			const topWord = validCandidates.length > 0 ? validCandidates[0] : null;
			
			if (topWord && topWord.word) {
				// Display the actual word
				return `
					<div class="word-display">
						<span class="word-text">${topWord.word}</span>
					</div>
				`;
			} else {
				// Show fill-in link for missing words
				return `
					<div class="word-missing">
						<a href="#" class="fill-in-link" onclick="openGoogleSheet('${videoId}', '${segmentId}', ${wordIndex})" title="Help us fill in this word">
							📝 fill-in
						</a>
					</div>
				`;
			}
		}



		// NEW FUNCTION: Opens Google Sheet for word crowdsourcing
		function openGoogleSheet(videoId, segmentId, wordIndex) {
			// Replace this URL with your actual Google Sheet URL
			const googleSheetURL = 'https://docs.google.com/spreadsheets/d/1bfHSHaBiX4pFljrVclEtwWMTXRJMoIKbpdHo1-x_ulw/edit?usp=sharing';
			
			// You can customize this URL to include episode and segment info
			const customURL = `${googleSheetURL}&entry.episode=${videoId}&entry.segment=${getSegmentLetter(segmentId)}&entry.word=${wordIndex + 1}`;
			
			// Open in new tab
			window.open(customURL, '_blank');
			
			// Show notification
			showNotification(`Opening Google Sheet to fill in Episode ${videoId}, Segment ${getSegmentLetter(segmentId)}, Word ${wordIndex + 1}`, 'info');
		}

		// HELPER FUNCTION: Convert segment ID to letter (A, B, C)
		function getSegmentLetter(segmentId) {
			// Extract segment number from ID like "segment_1_1" -> 1 -> A
			const match = segmentId.match(/segment_\d+_(\d+)/);
			if (match) {
				const segmentNum = parseInt(match[1]) - 1; // Convert to 0-based index
				return String.fromCharCode(65 + segmentNum); // 0=A, 1=B, 2=C
			}
			return 'A'; // Fallback
		}

	


        // NOTES: Create the display HTML, must be placed before createSegmentHtml
        function createNoteDisplayHTML(videoId, segmentId, noteText) {
            const hasNote = noteText && noteText.trim();
            return `
                <div class="notes-display ${hasNote ? '' : 'empty'}">
                    ${hasNote ? noteText : 'Click "Add Note" to add your private notes for this segment...'}
                </div>
                <button class="notes-edit-btn" onclick="startEditingNote('${videoId}', '${segmentId}')">
                    ${hasNote ? 'Edit Note' : 'Add Note'}
                </button>
            `;
        }
		


		function createSegmentHtml(segment, videoId, segmentIndex) {
			console.log(`🔧 Creating segment HTML for ${videoId}-${segmentIndex}:`, segment);
			console.log('🧪 TESTING NOTES SECTION - userNotes:', userNotes);
			
			try {
				const segmentId = segment.id || `fallback_segment_${segmentIndex}`;
				const segmentRatings = segment.ratings || defaultRatings;
				
				const avgRating = [
					segmentRatings.lyrics?.average || 0,
					segmentRatings.beats?.average || 0, 
					segmentRatings.reaction?.average || 0,
					segmentRatings.overall?.average || 0
				].reduce((sum, val) => sum + val, 0) / 4;
				
				// CREATE INLINE WORDS FOR HEADER
				let headerWordsHtml = '';
				if (segment.words && Array.isArray(segment.words)) {
					const wordDisplays = segment.words.map((wordCandidates, wordIndex) => {
						try {
							return createWordCandidatesHtml(wordCandidates, videoId, segmentId, wordIndex);
						} catch (wordError) {
							console.error(`❌ Error processing word ${wordIndex}:`, wordError);
							return `<div class="word-missing-inline"><a href="#" class="fill-in-link-small" onclick="openGoogleSheet('${videoId}', '${segmentId}', ${wordIndex})">📝 fill-in</a></div>`;
						}
					});
					
					headerWordsHtml = wordDisplays.join('');
				} else {
					console.log(`⚠️ No valid words array found in segment`);
					headerWordsHtml = `
						<div class="word-missing-inline"><a href="#" class="fill-in-link-small" onclick="openGoogleSheet('${videoId}', '${segmentId}', 0)">📝 fill-in</a></div>
						<div class="word-missing-inline"><a href="#" class="fill-in-link-small" onclick="openGoogleSheet('${videoId}', '${segmentId}', 1)">📝 fill-in</a></div>
						<div class="word-missing-inline"><a href="#" class="fill-in-link-small" onclick="openGoogleSheet('${videoId}', '${segmentId}', 2)">📝 fill-in</a></div>
					`;
				}

				// Get user's note for this segment
				const userNote = userNotes[videoId]?.[segmentId] || '';
				const hasNote = userNote && userNote.trim();

				console.log('🧪 NOTES DEBUG:', { videoId, segmentId, userNote, hasNote });
				
				return `
					<div class="segment" data-segment="${segmentId}">
						<div class="segment-header" onclick="toggleSegment('${videoId}', '${segmentId}')">
							<div class="segment-info-with-words">
								<div class="segment-title-and-rating">
									
									<div class="segment-title-and-rating">
										<div class="segment-title-inline">
											<span class="segment-name">Segment ${videoId}-${String.fromCharCode(65 + segmentIndex)}</span>
											<span class="segment-rating-inline">${avgRating.toFixed(1)}★</span>
										</div>
									</div>


								</div>
								<div class="segment-words-inline">
									${headerWordsHtml}
								</div>
							</div>
							<div class="segment-expand-icon">▶</div>
						</div>
						<div class="segment-content">
							<div class="segment-details">
								<div class="segment-ratings">
									<h5 style="color: #2c3e50; margin-bottom: 15px; font-size: 0.85rem;">Rate This Segment</h5>
									${['lyrics', 'beats', 'reaction', 'overall'].map(category => `
										<div class="rating-category">
											<div class="rating-info">
												<span class="rating-label">${category.charAt(0).toUpperCase() + category.slice(1)}</span>
												<span class="rating-stats">${(segmentRatings[category]?.average || 0).toFixed(1)}★ (${segmentRatings[category]?.count || 0} ratings)</span>
											</div>
											<div class="rating-controls">
												<div class="stars" data-category="${category}" data-video="${videoId}" data-segment="${segmentId}">
													${createStarRating(category, videoId, segmentRatings[category]?.average || 0, segmentRatings[category]?.count || 0, segmentId)}
												</div>
												${userRatings[videoId]?.segments?.[segmentId]?.[category] ? `<div class="user-rating-indicator">Your rating: ${userRatings[videoId].segments[segmentId][category]}★</div>` : ''}
											</div>
										</div>
									`).join('')}
								</div>
								
								<div class="notes-section" data-video="${videoId}" data-segment="${segmentId}">
									<div class="notes-header" onclick="toggleNotesSection('${videoId}', '${segmentId}')">
										<div class="notes-title">
											📝 My Notes
											${hasNote ? '<span style="color: #27ae60; font-size: 0.7rem; margin-left: 5px;">●</span>' : ''}
										</div>
										<div class="notes-expand-icon">▶</div>
									</div>
									<div class="notes-content">
										${createNoteDisplayHTML(videoId, segmentId, userNote)}
									</div>
								</div>
							</div>
						</div>
					</div>					
				`;
				
			} catch (error) {
				console.error(`❌ Error in createSegmentHtml for ${videoId}-${segmentIndex}:`, error);
				return `
					<div class="segment segment-error">
						<div class="segment-header">
							<div class="segment-info">
								<div class="segment-title">Segment ${videoId}-${String.fromCharCode(65 + segmentIndex)} (Error)</div>								
								<div class="segment-rating-summary">Unable to load</div>
							</div>
						</div>
					</div>
				`;
			}
		}


		
		
		
        function preserveExpandedState() {
            const expandedSegments = [];
            document.querySelectorAll('.segment.expanded').forEach(segment => {
                const videoId = segment.closest('.segments-container').dataset.video;
                const segmentId = segment.dataset.segment;
                expandedSegments.push(`${videoId}_${segmentId}`);
            });
            return expandedSegments;
        }
        
        function restoreExpandedState(expandedSegments) {
            setTimeout(() => {
                expandedSegments.forEach(segmentKey => {
                    const [videoId, segmentId] = segmentKey.split('_', 2);
                    const segmentElement = document.querySelector(
                        `.segments-container[data-video="${videoId}"] .segment[data-segment="${segmentId}"]`
                    );
                    if (segmentElement) {
                        segmentElement.classList.add('expanded');
                    }
                });
            }, 100);
        }
        
        function renderVideos() {
			console.log('🎨 RENDERVIDEOS CALLED!');
			console.log('🎨 Call stack:');
			console.trace(); // This shows exactly what called renderVideos
	
            console.log('🎨 Starting renderVideos function...');

            const expandedSegments = preserveExpandedState();
            
            console.log(`📊 Videos to render: ${videos.length}`);
            
            const videoGrid = document.getElementById('videoGrid');
            videoGrid.innerHTML = '';

            let filteredVideos = [...videos];
            console.log(`📋 Initial video count: ${filteredVideos.length}`);

            const sortFilter = document.getElementById('sortFilter').value;
            const ratingFilter = parseFloat(document.getElementById('ratingFilter').value);
            const searchFilter = document.getElementById('searchFilter').value.toLowerCase();

            console.log(`🔍 Filters - Sort: ${sortFilter}, Rating: ${ratingFilter}, Search: "${searchFilter}"`);

            if (ratingFilter > 0) {
                const beforeCount = filteredVideos.length;
                filteredVideos = filteredVideos.filter(video => video.ratings.overall.average >= ratingFilter);
                console.log(`📊 Rating filter: ${beforeCount} → ${filteredVideos.length} videos`);
            }

            if (searchFilter) {
                const beforeCount = filteredVideos.length;
                filteredVideos = filteredVideos.filter(video => {
                    try {
                        return video.title.toLowerCase().includes(searchFilter) ||
                               video.episodeNumber.toString().includes(searchFilter) ||
                               (video.segments && video.segments.some(segment =>
                                   segment.words && segment.words.some(wordCandidates => {
                                       if (Array.isArray(wordCandidates)) {
                                           return wordCandidates.some(candidate =>
                                               candidate && candidate.word && 
                                               candidate.word.toLowerCase().includes(searchFilter)
                                           );
                                       }
                                       return false;
                                   })
                               ));
                    } catch (searchError) {
                        console.error(`❌ Search error for video ${video.episodeNumber}:`, searchError);
                        return true;
                    }
                });
                console.log(`🔍 Search filter: ${beforeCount} → ${filteredVideos.length} videos`);
            }

            filteredVideos.sort((a, b) => {
                if (sortFilter === 'episode') {
                    return a.episodeNumber - b.episodeNumber;
                } else {
                    return b.ratings[sortFilter].average - a.ratings[sortFilter].average;
                }
            });
            console.log(`📊 Sorted ${filteredVideos.length} videos by ${sortFilter}`);

            let successCount = 0;
            let errorCount = 0;
            
            filteredVideos.forEach((video, index) => {
                try {
                    console.log(`🎬 Rendering video ${index + 1}/${filteredVideos.length}: Episode ${video.episodeNumber}`);
                    
                    const videoCard = document.createElement('div');
                    videoCard.className = 'video-card';
                    
                    let segmentsHtml = '';
                    if (video.segments && Array.isArray(video.segments)) {
                        console.log(`📦 Processing ${video.segments.length} segments for Episode ${video.episodeNumber}`);
                        try {
                            segmentsHtml = video.segments.map((segment, segIndex) => {
                                try {
                                    return createSegmentHtml(segment, video.episodeNumber, segIndex);
                                } catch (segmentError) {
                                    console.error(`❌ Error rendering segment ${segIndex} for Episode ${video.episodeNumber}:`, segmentError);
                                    return `<div class="segment-error">Error loading segment ${String.fromCharCode(65 + segIndex)}</div>`;
                                }
                            }).join('');
                        } catch (segmentsError) {
                            console.error(`❌ Error processing segments for Episode ${video.episodeNumber}:`, segmentsError);
                            segmentsHtml = '<div class="segments-error">Error loading segments</div>';
                        }
                    } else {
                        console.log(`⚠️ No valid segments for Episode ${video.episodeNumber}`);
                        segmentsHtml = '<div class="no-segments">No segments available</div>';
                    }
                    
                    videoCard.innerHTML = `
                        <div class="video-embed" style="position: relative; cursor: pointer; background-image: url('https://img.youtube.com/vi/${video.youtubeId}/maxresdefault.jpg'); background-size: cover; background-position: center;" onclick="window.open('https://www.youtube.com/watch?v=${video.youtubeId}', '_blank')">
                            <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center;">
                                <div style="text-align: center; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">
                                    <div style="font-size: 4rem; margin-bottom: 10px;">▶️</div>
                                    <div style="font-size: 1.1rem; font-weight: bold;">Episode #${video.episodeNumber}</div>
                                    <div style="font-size: 0.9rem; opacity: 0.9;">Click to watch on YouTube</div>
                                </div>
                            </div>
                        </div>
                        <div class="video-content">
                            <h3 class="video-title">${video.title}</h3>
                           
 
							<div class="segments-section">
								<div class="segments-header">
									<h4>Detailed Segments (${video.segments ? video.segments.length : 0})</h4>
		
                                    <button class="expand-toggle" onclick="toggleAllSegments('${video.episodeNumber}')">Show Ratings</button>
                                </div>
                                <div class="segments-container" data-video="${video.episodeNumber}">
                                    ${segmentsHtml}
                                </div>
                            </div>
                        </div>
                    `;
                    videoGrid.appendChild(videoCard);
                    successCount++;
                    
                } catch (videoError) {
                    console.error(`❌ Error rendering video ${video.episodeNumber}:`, videoError);
                    console.error(`❌ Video error details:`, videoError.message);
                    errorCount++;
                    
                    const errorCard = document.createElement('div');
                    errorCard.className = 'video-card';
                    errorCard.innerHTML = `
                        <div class="video-content">
                            <h3 class="video-title">Episode #${video.episodeNumber} (Error)</h3>
                            <p>Error loading this episode. Please try refreshing.</p>
                        </div>
                    `;
                    videoGrid.appendChild(errorCard);
                }
            });

            console.log(`✅ Rendering complete: ${successCount} success, ${errorCount} errors`);

            try {
                document.querySelectorAll('.star').forEach(star => {
                    star.onclick = function() {
                        const rating = parseInt(this.dataset.rating);
                        const category = this.dataset.category;
                        const videoId = this.dataset.video;
                        const segmentId = this.dataset.segment || null;
                        if (currentUser) {
                            submitRating(videoId, category, rating, segmentId);
                        } else {
                            showSignInPrompt('rate segments', 0);
                        }
                    };
                });
                console.log('✅ Star rating event listeners attached');
            } catch (eventError) {
                console.error('❌ Error attaching event listeners:', eventError);
            }

            try {
                updateUserRatingDisplay();
                console.log('✅ User rating display updated');
            } catch (displayError) {
                console.error('❌ Error updating user rating display:', displayError);
            }
             
            restoreExpandedState(expandedSegments);
        }


		function updateStarDisplay(starsContainer, rating, userRated = false) {
			const stars = starsContainer.querySelectorAll('.star');
			
			// Determine what to show based on login status and user rating
			let displayRating = 0;
			if (currentUser) {
				// User is logged in - show their rating if they've rated, otherwise show empty
				displayRating = userRated ? rating : 0;
			} else {
				// User not logged in - show community average
				displayRating = rating;
			}
			
			stars.forEach((star, index) => {
				star.classList.remove('active', 'user-rated');
				if (index < displayRating) {
					star.classList.add('active');
				}
				if (userRated && index < rating) {
					star.classList.add('user-rated');
				}
			});
		}



        function toggleSegment(videoId, segmentId) {
            const videoContainer = document.querySelector(`.segments-container[data-video="${videoId}"]`);
            if (videoContainer) {
                const segmentElement = videoContainer.querySelector(`.segment[data-segment="${segmentId}"]`);
                if (segmentElement) {
                    segmentElement.classList.toggle('expanded');
                }
            }
        }

        function toggleAllSegments(videoId) {
            const container = document.querySelector(`.segments-container[data-video="${videoId}"]`);
            if (container) {
                const segments = container.querySelectorAll('.segment');
                let allExpanded = true;
                segments.forEach(segment => {
                    if (!segment.classList.contains('expanded')) {
                        allExpanded = false;
                    }
                });

                segments.forEach(segment => {
                    if (allExpanded) {
                        segment.classList.remove('expanded');
                    } else {
                        segment.classList.add('expanded');
                    }
                });
                
                const button = container.closest('.video-card').querySelector('.expand-toggle');
                if (button) {
                    button.textContent = allExpanded ? 'Show Ratings' : 'Hide Ratings';
                }
            }
        }

        
        function showNotification(message, type) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }




		function updateStats() {
			let totalRatings = 0;
			let totalOverallRating = 0;
			let overallRatingCount = 0;
			let maxOverallRating = 0;
			let topEpisode = '#--';

			videos.forEach(video => {
				if (video.ratings.overall.count > 0) {
					totalOverallRating += video.ratings.overall.average * video.ratings.overall.count;
					overallRatingCount += video.ratings.overall.count;
				}

				if (video.segments) {
					video.segments.forEach(segment => {
						if (segment.ratings) {
							Object.values(segment.ratings).forEach(rating => {
								totalRatings += rating.count;
							});
						}
					});
				}
				
				if (video.ratings.overall.average > maxOverallRating) {
					maxOverallRating = video.ratings.overall.average;
					topEpisode = `#${video.episodeNumber}`;
				}
			});

			document.getElementById('totalRatings').textContent = totalRatings;
			document.getElementById('avgOverall').textContent = overallRatingCount > 0 ? (totalOverallRating / overallRatingCount).toFixed(1) : '0.0';
			document.getElementById('activeUsers').textContent = Object.keys(userRatings).length;
			document.getElementById('topEpisode').textContent = topEpisode;
		}





        function showSignInPrompt(action, delay = 0) {
            setTimeout(() => {
                showNotification(`Please sign in to ${action}.`, 'info');
            }, delay);
        }

        function init() {
            updateConnectionStatus('connecting');
            
            initializeFirebase();
            
            document.getElementById('sortFilter').addEventListener('change', applyFilters);
            document.getElementById('ratingFilter').addEventListener('change', applyFilters);
            document.getElementById('searchFilter').addEventListener('input', applyFilters);
            
            setupRealtimeUpdates();
        
            document.getElementById('authButton').addEventListener('click', () => {
                if (currentUser) {
                    signOut();
                } else {
                    signIn();
                }
            });
        }

        function applyFilters() {
			console.log('🔄 APPLYFILTERS CALLED!');
			console.log('🔄 Call stack:');
			console.trace(); // This shows exactly what called applyFilters
	
            renderVideos();
        }


		function setupRealtimeUpdates() {
			if (!db) return;
			
			db.collection('videos').onSnapshot((snapshot) => {
				if (realtimeUpdateTimeout) {
					clearTimeout(realtimeUpdateTimeout);
				}

				// UPDATED: Remove isVotingOnWord and isAddingWord checks
				if (!isSavingNote && !isSubmittingRating && snapshot.docChanges().length > 0) {
					console.log('📡 Real-time update received, processing changes...');
					
					const expandedSegments = preserveExpandedState();
					
					let hasChanges = false;
					snapshot.docChanges().forEach((change) => {
						if (change.type === 'modified') {
							const updatedVideo = { id: change.doc.id, ...change.doc.data() };
							const index = videos.findIndex(v => v.episodeNumber === updatedVideo.episodeNumber);
							if (index !== -1) {
								let processedSegments = [];
								if (updatedVideo.segments && Array.isArray(updatedVideo.segments)) {
									processedSegments = updatedVideo.segments.map((segment, idx) => 
										sanitizeSegmentData(segment, updatedVideo.episodeNumber, idx)
									);
								} else if (updatedVideo.segments && typeof updatedVideo.segments === 'object') {
									const segmentValues = Object.values(updatedVideo.segments);
									processedSegments = segmentValues.map((segment, idx) => 
										sanitizeSegmentData(segment, updatedVideo.episodeNumber, idx)
									);
								}
								
								videos[index] = {
									...updatedVideo,
									segments: processedSegments
								};
								hasChanges = true;
							}
						}
					});
					
					if (hasChanges) {
						realtimeUpdateTimeout = setTimeout(() => {
							console.log('🔄 Applying real-time updates to UI...');
							applyFilters();
							updateStats();
							
							setTimeout(() => {
								console.log('🔓 Restoring expanded state after real-time update');
								restoreExpandedState(expandedSegments);
							}, 100);
							
						}, 3000);
					}
				} else if (isSavingNote || isSubmittingRating) {
					console.log('⏸️ Skipping real-time update - user operation in progress');
				}
			});
		}









       // ===== ADD ALL THE NOTES FUNCTIONS HERE ===== 
        
        // NOTES: Load user notes from Firebase
        async function loadUserNotes() {
            if (!currentUser || !db) return;

            try {
                console.log('📝 Loading user notes...');
                const notesSnapshot = await db.collection('userNotes')
                    .where('userId', '==', currentUser.uid)
                    .get();
                
                userNotes = {};
                
                notesSnapshot.docs.forEach(doc => {
                    const data = doc.data();
                    if (!userNotes[data.videoId]) {
                        userNotes[data.videoId] = {};
                    }
                    userNotes[data.videoId][data.segmentId] = data.noteText;
                });
                
                console.log(`✅ Loaded ${notesSnapshot.size} notes`);
                updateNotesDisplay();
                
            } catch (error) {
                console.error('❌ Error loading user notes:', error);
            }
        }

        // NOTES: Update notes display in DOM (without re-rendering)
        function updateNotesDisplay() {
            setTimeout(() => {
                Object.keys(userNotes).forEach(videoId => {
                    Object.keys(userNotes[videoId]).forEach(segmentId => {
                        const noteText = userNotes[videoId][segmentId];
                        updateNoteInDOM(videoId, segmentId, noteText);
                    });
                });
            }, 100);
        }

        // NOTES: Update a specific note in the DOM without re-rendering
        function updateNoteInDOM(videoId, segmentId, noteText) {
            const notesDisplay = document.querySelector(
                `.segments-container[data-video="${videoId}"] .segment[data-segment="${segmentId}"] .notes-display`
            );
            
            if (notesDisplay) {
                if (noteText && noteText.trim()) {
                    notesDisplay.textContent = noteText;
                    notesDisplay.classList.remove('empty');
                } else {
                    notesDisplay.textContent = 'Click "Edit" to add your private notes for this segment...';
                    notesDisplay.classList.add('empty');
                }
            }
        }

        // NOTES: Toggle notes section expansion
        function toggleNotesSection(videoId, segmentId) {
            const notesSection = document.querySelector(
                `.segments-container[data-video="${videoId}"] .segment[data-segment="${segmentId}"] .notes-section`
            );
            
            if (notesSection) {
                notesSection.classList.toggle('expanded');
            }
        }

        // NOTES: Start editing a note
        function startEditingNote(videoId, segmentId) {
            if (!currentUser) {
                showSignInPrompt('add notes', 0);
                return;
            }

            const editKey = `${videoId}_${segmentId}`;
            if (editingNotes[editKey]) {
                console.log('Already editing this note');
                return;
            }

            console.log(`📝 Starting to edit note for ${videoId}-${segmentId}`);
            
            const segmentElement = document.querySelector(
                `.segments-container[data-video="${videoId}"] .segment[data-segment="${segmentId}"]`
            );
            
            if (!segmentElement) return;

            const notesContent = segmentElement.querySelector('.notes-content');
            const currentNote = userNotes[videoId]?.[segmentId] || '';
            
            // Set editing flag
            editingNotes[editKey] = true;
            
            // Replace display with edit form
            notesContent.innerHTML = createNoteEditForm(videoId, segmentId, currentNote);
            
            // Focus on textarea
            const textarea = notesContent.querySelector('.notes-textarea');
            if (textarea) {
                textarea.focus();
                textarea.setSelectionRange(textarea.value.length, textarea.value.length);
            }
        }

        // NOTES: Create the edit form HTML
        function createNoteEditForm(videoId, segmentId, currentNote) {
            return `
                <div class="notes-edit-form">
                    <textarea class="notes-textarea" placeholder="Add your private notes for this segment..." maxlength="${MAX_NOTE_LENGTH}" data-video="${videoId}" data-segment="${segmentId}" oninput="updateCharCount('${videoId}', '${segmentId}')">${currentNote}</textarea>
                    <div class="notes-char-count" id="charCount_${videoId}_${segmentId}">
                        ${currentNote.length}/${MAX_NOTE_LENGTH}
                    </div>
                    <div class="notes-actions">
                        <button class="notes-cancel-btn" onclick="cancelEditingNote('${videoId}', '${segmentId}')">
                            Cancel
                        </button>
                        <button class="notes-save-btn" onclick="saveNote('${videoId}', '${segmentId}')" id="saveBtn_${videoId}_${segmentId}">
                            Save Note
                        </button>
                    </div>
                </div>
            `;
        }



        // NOTES: Update character count
        function updateCharCount(videoId, segmentId) {
            const textarea = document.querySelector(`[data-video="${videoId}"][data-segment="${segmentId}"].notes-textarea`);
            const charCountElement = document.getElementById(`charCount_${videoId}_${segmentId}`);
            
            if (textarea && charCountElement) {
                const length = textarea.value.length;
                charCountElement.textContent = `${length}/${MAX_NOTE_LENGTH}`;
                
                // Update styling based on length
                charCountElement.classList.remove('warning', 'error');
                if (length > MAX_NOTE_LENGTH * 0.9) {
                    charCountElement.classList.add('warning');
                }
                if (length >= MAX_NOTE_LENGTH) {
                    charCountElement.classList.add('error');
                }
                
                // Enable/disable save button
                const saveBtn = document.getElementById(`saveBtn_${videoId}_${segmentId}`);
                if (saveBtn) {
                    saveBtn.disabled = length > MAX_NOTE_LENGTH;
                }
            }
        }


        // NOTES: Save note
        async function saveNote(videoId, segmentId) {
            if (!currentUser) {
                showSignInPrompt('save notes', 0);
                return;
            }
            
            if (isSavingNote) {
                console.log('Already saving a note');
                return;
            }

            const editKey = `${videoId}_${segmentId}`;
            isSavingNote = true;
            
            try {
                const textarea = document.querySelector(`[data-video="${videoId}"][data-segment="${segmentId}"].notes-textarea`);
                if (!textarea) return;
                
                const noteText = textarea.value.trim();
                const saveBtn = document.getElementById(`saveBtn_${videoId}_${segmentId}`);
                
                if (saveBtn) {
                    saveBtn.disabled = true;
                    saveBtn.textContent = 'Saving...';
                }
                
                console.log(`💾 Saving note for ${videoId}-${segmentId}:`, noteText);

                // Update local data
                if (!userNotes[videoId]) {
                    userNotes[videoId] = {};
                }
                userNotes[videoId][segmentId] = noteText;

                // Save to Firebase
                if (db) {
                    const noteDocId = `${currentUser.uid}_${videoId}_${segmentId}`;
                    
                    if (noteText) {
                        await db.collection('userNotes').doc(noteDocId).set({
                            userId: currentUser.uid,
                            videoId: videoId,
                            segmentId: segmentId,
                            noteText: noteText,
                            lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    } else {
                        // Delete empty notes
                        await db.collection('userNotes').doc(noteDocId).delete();
                    }
                }

                // Update UI to display mode
                const notesContent = document.querySelector(
                    `.segments-container[data-video="${videoId}"] .segment[data-segment="${segmentId}"] .notes-content`
                );
                
                if (notesContent) {
                    notesContent.innerHTML = createNoteDisplayHTML(videoId, segmentId, noteText);
                }

                // Clear editing flag
                delete editingNotes[editKey];

                showNotification(noteText ? 'Note saved!' : 'Note deleted!', 'success');
                
            } catch (error) {
                console.error('❌ Error saving note:', error);
                showNotification('Failed to save note. Please try again.', 'error');
            } finally {
                isSavingNote = false;
            }
        }

        // NOTES: Cancel editing
        function cancelEditingNote(videoId, segmentId) {
            const editKey = `${videoId}_${segmentId}`;
            const currentNote = userNotes[videoId]?.[segmentId] || '';
            
            const notesContent = document.querySelector(
                `.segments-container[data-video="${videoId}"] .segment[data-segment="${segmentId}"] .notes-content`
            );
            
            if (notesContent) {
                notesContent.innerHTML = createNoteDisplayHTML(videoId, segmentId, currentNote);
            }
            
            // Clear editing flag
            delete editingNotes[editKey];
        }

        // ===== END NOTES FUNCTIONS =====
		
		
		async function bulkUpdateWords() {
			if (!currentUser || !db) {
				alert('Please sign in first');
				return;
			}
			
			// Define your word updates here
			const wordUpdates = {
				// Episode 11 - Replace these with the actual words from Harry Mack's video
				11: {
					segment_11_1: ['sandwich', 'flags', 'table'],
					segment_11_2: ['penguin', 'Philadelphia', 'Steve'], 
					segment_11_3: ['phone', 'crush', 'car']
				},
				// Episode 14 - Add more episodes as needed
				14: {
					segment_14_1: ['California', 'language', 'enemy'],
					segment_14_2: ['chocolate', 'cake', 'dinosaur'],
					segment_14_3: ['TBD', 'TBD', 'TBD'],
				},
				// Add more episodes here...
			};
			
			try {
				console.log('Starting bulk word update...');
				const batch = db.batch();
				
				Object.keys(wordUpdates).forEach(episodeNum => {
					const docRef = db.collection('videos').doc(`episode_${episodeNum}`);
					const segments = {};
					
					Object.keys(wordUpdates[episodeNum]).forEach(segmentId => {
						const words = wordUpdates[episodeNum][segmentId];
						
						// Convert words array to Firebase-compatible format (objects, not nested arrays)
						const wordsObject = {};
						words.forEach((word, index) => {
							wordsObject[index] = {
								0: {  // First candidate for this word position
									word: word,
									votes: Math.floor(Math.random() * 20) + 5,
									voters: []
								}
							};
						});
						
						segments[segmentId] = {
							id: segmentId,
							words: wordsObject,  // Now it's an object, not nested arrays
							ratings: {
								lyrics: { average: 3.5 + Math.random(), count: 15 },
								beats: { average: 3.8 + Math.random(), count: 18 },
								reaction: { average: 3.2 + Math.random(), count: 12 },
								overall: { average: 3.5 + Math.random(), count: 14 }
							}
						};
					});
					
					batch.update(docRef, { segments });
				});
				
				await batch.commit();
				alert('Words updated successfully!');
				console.log('Bulk update complete!');
				location.reload(); // Refresh to see changes
				
			} catch (error) {
				console.error('Error updating words:', error);
				alert('Error updating words: ' + error.message);
			}
		}


		// Check if current user is admin and show/hide admin features
		function checkAdminAccess() {
			const adminButton = document.getElementById('adminUpdateButton');
			
			if (currentUser && currentUser.email === 'mathewmit@gmail.com') {
				// Show admin button
				if (adminButton) {
					adminButton.style.display = 'block';
				}
				console.log('🔐 Admin access granted');
			} else {
				// Hide admin button
				if (adminButton) {
					adminButton.style.display = 'none';
				}
			}
		}



        // Make functions globally available for onclick handlers

        window.toggleSegment = toggleSegment;
        window.toggleAllSegments = toggleAllSegments;
		
		// Make notes functions globally available for onclick handlers
		window.toggleNotesSection = toggleNotesSection;
		window.startEditingNote = startEditingNote;
		window.saveNote = saveNote;
		window.cancelEditingNote = cancelEditingNote;
		window.updateCharCount = updateCharCount;

		// Make it globally available
		window.bulkUpdateWords = bulkUpdateWords;
		window.checkAdminAccess = checkAdminAccess;

		
 
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>

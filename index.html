<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harry Mack Omegle Bars - Community Hub</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            color: white;
            position: relative;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .user-section {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .user-info {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .auth-button {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s ease;
        }

        .auth-button:hover {
            background: #c0392b;
        }

        .connection-status {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
            z-index: 1000;
        }

        .status-connected {
            background: #27ae60;
            color: white;
        }

        .status-disconnected {
            background: #e74c3c;
            color: white;
        }

        .status-demo {
            background: #f39c12;
            color: white;
        }

        .status-connecting {
            background: #f39c12;
            color: white;
        }

        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
        }

        .video-card {
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .video-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
        }

        .video-embed {
            position: relative;
            width: 100%;
            height: 200px;
            background: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 14px;
        }

        .video-content {
            padding: 20px;
        }

        .video-title {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .overall-rating {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border-left: 4px solid #3498db;
        }

        .overall-rating h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .segments-section {
            margin-bottom: 20px;
        }

        .segments-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .segments-header h4 {
            color: #8e44ad;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .expand-toggle {
            background: #8e44ad;
            color: white;
            border: none;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .expand-toggle:hover {
            background: #7d3c98;
        }

        .segment {
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 15px;
            border-left: 4px solid #e74c3c;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .segment-header {
            padding: 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #fff;
            border-bottom: 1px solid #eee;
        }

        .segment-header:hover {
            background: #f8f9fa;
        }

        .segment-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .segment-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
        }

        .segment-rating-summary {
            font-size: 0.75rem;
            color: #7f8c8d;
        }

        .segment-expand-icon {
            color: #8e44ad;
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }

        .segment.expanded .segment-expand-icon {
            transform: rotate(90deg);
        }

        .segment-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .segment.expanded .segment-content {
            max-height: 600px;
        }

        .segment-details {
            padding: 20px;
        }

        .words-management {
            margin-bottom: 20px;
        }

        .words-management h5 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 0.85rem;
        }

        .word-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }

        .word-item {
            display: flex;
            align-items: center;
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 0.8rem;
            gap: 5px;
        }

        .word-votes {
            background: rgba(255, 255, 255, 0.3);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
        }

        .vote-buttons {
            display: flex;
            gap: 2px;
        }

        .vote-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.7rem;
            transition: background 0.2s ease;
        }

        .vote-btn:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        .vote-btn.voted {
            background: rgba(255, 255, 255, 0.8);
            color: #333;
        }

        .add-word-form {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .add-word-input {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 0.8rem;
        }

        .add-word-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background 0.3s ease;
        }

        .add-word-btn:hover {
            background: #229954;
        }

        .segment-ratings {
            border-top: 1px solid #eee;
            padding-top: 15px;
        }

        .rating-category {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .rating-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .rating-label {
            font-weight: 600;
            color: #34495e;
            font-size: 0.85rem;
        }

        .rating-stats {
            font-size: 0.7rem;
            color: #7f8c8d;
            margin-top: 2px;
        }

        .rating-controls {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
        }

        .stars {
            display: flex;
            gap: 3px;
        }

        .star {
            width: 20px;
            height: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #ddd;
            user-select: none;
        }

        .star:hover,
        .star.active {
            color: #f39c12;
            transform: scale(1.1);
        }

        .star.user-rated {
            color: #e74c3c;
        }

        .user-rating-indicator {
            font-size: 0.65rem;
            color: #e74c3c;
            font-weight: bold;
        }

        .stats-bar {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            color: white;
            text-align: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .stat-item {
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .filter-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            color: white;
        }

        .filter-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-controls select,
        .filter-controls input {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            background: white;
            color: #333;
        }

        .loading {
            text-align: center;
            color: white;
            font-size: 1.2rem;
            margin: 50px 0;
        }

        .error-message {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 10px;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: slideIn 0.3s ease;
        }

        .notification.success {
            background: #27ae60;
            color: white;
        }

        .notification.error {
            background: #e74c3c;
            color: white;
        }

        .notification.info {
            background: #3498db;
            color: white;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @media (max-width: 768px) {
            .video-grid {
                grid-template-columns: 1fr;
            }
            .header h1 {
                font-size: 2rem;
            }
            .user-section {
                position: static;
                justify-content: center;
                margin-top: 15px;
            }
            .filter-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>

<body>
    <div class="connection-status" id="connectionStatus">
        <span id="statusText">Connecting...</span>
    </div>

    <div class="container">
        <div class="header">
            <div class="user-section">
                <div class="user-info" id="userInfo" style="display: none;">
                    Welcome, <span id="userName"></span>!
                </div>
                <button class="auth-button" id="authButton">Sign In with Google</button>
            </div>
            
            <h1>ðŸŽ¤ Harry Mack Community Hub</h1>
            <p>Rate each segment and crowdsource words with the global Harry Mack fan community!</p>
            <p style="font-size: 0.9rem; margin-top: 10px; opacity: 0.8;">
                âœ¨ Rate individual segments â€¢ Add missing words â€¢ Vote on word accuracy âœ¨
            </p>
        </div>

        <div class="filter-section">
            <div class="filter-controls">
                <label>Sort by:</label>
                <select id="sortFilter">
                    <option value="episode">Episode Number</option>
                    <option value="overall">Overall Rating</option>
                    <option value="lyrics">Lyrics Rating</option>
                    <option value="beats">Beats Rating</option>
                    <option value="reaction">Reaction Rating</option>
                </select>
                
                <label>Min Rating:</label>
                <select id="ratingFilter">
                    <option value="0">All Videos</option>
                    <option value="3">3+ Stars</option>
                    <option value="4">4+ Stars</option>
                    <option value="5">5 Stars Only</option>
                </select>

                <input type="text" id="searchFilter" placeholder="Search by words or episode...">
            </div>
        </div>

        <div id="loadingMessage" class="loading">
            Loading Harry Mack videos and community ratings...
        </div>

        <div class="video-grid" id="videoGrid" style="display: none;">
        </div>

        <div class="stats-bar" id="statsBar" style="display: none;">
            <h3 style="margin-bottom: 20px;">Global Community Stats</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-number" id="totalRatings">0</div>
                    <div class="stat-label">Total Ratings</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="avgOverall">0.0</div>
                    <div class="stat-label">Avg Overall Rating</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="activeUsers">0</div>
                    <div class="stat-label">Community Members</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="topEpisode">#--</div>
                    <div class="stat-label">Highest Rated Episode</div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-app-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-auth-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-firestore-compat.min.js"></script>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBUtq7jUntXqH0C0V2fDR1fwh2yPoZJAls",
            authDomain: "harry-mack-community.firebaseapp.com",
            projectId: "harry-mack-community",
            storageBucket: "harry-mack-community.firebasestorage.app",
            messagingSenderId: "1035009511388",
            appId: "1:1035009511388:web:23b2e932da2ac74466c919"
        };

        let app, auth, db;
        let currentUser = null;
        let isSigningIn = false;
        let videos = [];
        let userRatings = {};
        let userWordVotes = {};

        // Default ratings structure
        const defaultRatings = {
            lyrics: { average: 3.0, count: 0 },
            beats: { average: 3.0, count: 0 },
            reaction: { average: 3.0, count: 0 },
            overall: { average: 3.0, count: 0 }
        };

        function generateDefaultSegments() {
            console.log('ðŸ”§ Generating default segments...');
            const wordBank = ["pizza", "galaxy", "thunderstorm", "basketball", "dragon", "coffee"];
            const numSegments = 3; // Default to 3 segments
            const segments = [];
            
            for (let j = 0; j < numSegments; j++) {
                const segmentWords = [];
                
                // Generate 3 words per segment
                for (let k = 0; k < 3; k++) {
                    const candidateWords = [];
                    const baseWord = wordBank[Math.floor(Math.random() * wordBank.length)];
                    
                    candidateWords.push({
                        word: baseWord,
                        votes: Math.floor(Math.random() * 10) + 5,
                        voters: []
                    });
                    
                    segmentWords.push(candidateWords);
                }
                
                segments.push({
                    id: `default_segment_${j + 1}`,
                    words: segmentWords,
                    ratings: { ...defaultRatings }
                });
            }
            
            console.log(`âœ… Generated ${segments.length} default segments`);
            return segments;
        }

        async function initializeFirebase() {
            try {
                console.log('ðŸ”¥ Initializing Firebase...');
                app = firebase.initializeApp(firebaseConfig);
                auth = firebase.auth();
                db = firebase.firestore();
                
                console.log('âœ… Firebase services initialized');
                console.log('ðŸ”’ Setting auth persistence...');
                
                await auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);
                console.log('âœ… Auth persistence set');
                
                console.log('ðŸ”„ Checking for redirect result...');
                try {
                    const result = await auth.getRedirectResult();
                    console.log('ðŸ”„ Redirect result:', result);
                    
                    if (result.user) {
                        console.log('ðŸ‘¤ User signed in via redirect:', result.user.email);
                        showNotification(`Welcome ${result.user.displayName || result.user.email}! You're now signed in.`, 'success');
                        handleAuthStateChange(result.user);
                    } else if (result.credential) {
                        console.log('ðŸ”‘ Got credential but no user - possible error');
                    } else {
                        console.log('â„¹ï¸ No redirect result - normal page load');
                    }
                } catch (redirectError) {
                    console.error('âŒ Redirect error:', redirectError);
                    console.error('âŒ Error code:', redirectError.code);
                    console.error('âŒ Error message:', redirectError.message);
                    
                    if (redirectError.code === 'auth/unauthorized-domain') {
                        showNotification('This domain is not authorized. Please add it to Firebase.', 'error');
                    } else if (redirectError.code !== 'auth/redirect-cancelled-by-user') {
                        showNotification(`Sign in failed: ${redirectError.message}`, 'error');
                    }
                }

                auth.onAuthStateChanged((user) => {
                    console.log('ðŸ”„ Auth state changed:', user ? user.email : 'No user');
                    if (user) {
                        isSigningIn = false;
                    }
                    handleAuthStateChange(user);
                });
                
                const currentUser = auth.currentUser;
                console.log('ðŸ‘¤ Current user on init:', currentUser ? currentUser.email : 'None');
                
                // Test Firestore permissions
                console.log('ðŸ§ª Testing Firestore read permissions...');
                try {
                    await db.collection('videos').limit(1).get();
                    console.log('âœ… Firestore read permission confirmed');
                } catch (permError) {
                    console.error('âŒ Firestore permission error:', permError);
                    throw permError;
                }
                
                console.log('ðŸ“Š Starting to load videos data...');
                loadVideosData();
                updateConnectionStatus('connected');
                
            } catch (error) {
                console.error('âŒ Firebase initialization failed:', error);
                console.error('âŒ Error details:', error.message, error.code);
                handleFirebaseError();
            }
        }

        function handleFirebaseError() {
            updateConnectionStatus('demo');
            showNotification('Running in demo mode - all features work except saving ratings!', 'info');
            initializeDemoMode();
        }

        function initializeDemoMode() {
            generateSampleVideos();
            renderVideos();
            updateStats();
            
            document.getElementById('loadingMessage').style.display = 'none';
            document.getElementById('videoGrid').style.display = 'grid';
            document.getElementById('statsBar').style.display = 'block';
        }

        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            
            statusElement.className = 'connection-status status-' + status;
            
            switch(status) {
                case 'connected':
                    statusText.textContent = 'ðŸŸ¢ Live';
                    break;
                case 'disconnected':
                    statusText.textContent = 'ðŸ”´ Offline';
                    break;
                case 'demo':
                    statusText.textContent = 'ðŸŸ¡ Demo Mode';
                    break;
                case 'connecting':
                    statusText.textContent = 'ðŸŸ¡ Connecting...';
                    break;
            }
        }

        function handleAuthStateChange(user) {
            currentUser = user;
            
            const userInfo = document.getElementById('userInfo');
            const userName = document.getElementById('userName');
            const authButton = document.getElementById('authButton');

            if (user) {
                userInfo.style.display = 'block';
                userName.textContent = user.displayName || user.email;
                authButton.textContent = 'Sign Out';
                authButton.onclick = signOut;
                
                loadUserRatings();
                loadUserWordVotes();
                
            } else {
                userInfo.style.display = 'none';
                authButton.textContent = 'Sign In with Google';
                authButton.onclick = signIn;
                userRatings = {};
                userWordVotes = {};
            }
        }

        async function signIn() {
            if (!auth) {
                showNotification('Authentication not available in demo mode', 'info');
                return;
            }
            
            if (isSigningIn) {
                console.log('Sign-in already in progress');
                return;
            }
            
            console.log('Sign in button clicked');
            console.log('Current URL:', window.location.href);
            console.log('Auth domain:', firebaseConfig.authDomain);
            
            const provider = new firebase.auth.GoogleAuthProvider();
            provider.addScope('profile');
            provider.addScope('email');
            
            try {
                isSigningIn = true;
                console.log('Starting popup sign in...');
                showNotification('Opening Google sign-in popup...', 'info');
                
                const result = await auth.signInWithPopup(provider);
                
                console.log('Sign in successful:', result.user);
                showNotification('Successfully signed in!', 'success');
                
            } catch (error) {
                console.error('Sign in error:', error);
                
                if (error.code === 'auth/operation-not-allowed') {
                    showNotification('Google sign-in is not enabled in Firebase Console', 'error');
                } else if (error.code === 'auth/unauthorized-domain') {
                    showNotification('This domain is not authorized in Firebase', 'error');
                } else if (error.code === 'auth/popup-closed-by-user') {
                    showNotification('Sign-in popup was closed. Please try again.', 'info');
                } else if (error.code === 'auth/popup-blocked') {
                    showNotification('Sign-in popup was blocked by browser. Please allow popups and try again.', 'error');
                } else if (error.code === 'auth/cancelled-popup-request') {
                    showNotification('Another sign-in popup is already open. Please complete that first.', 'info');
                } else {
                    showNotification(`Sign in failed: ${error.message}`, 'error');
                }
            } finally {
                isSigningIn = false;
            }
        }

        async function signOut() {
            if (auth) {
                try {
                    await auth.signOut();
                    showNotification('You have been signed out.', 'info');
                } catch (error) {
                    console.error('Sign out error:', error);
                    showNotification('Error signing out. Please try again.', 'error');
                }
            }
        }

        async function loadVideosData() {
            try {
                if (!db) {
                    console.log('No database connection - using demo mode');
                    initializeDemoMode();
                    return;
                }

                console.log('âœ… Database connected, loading videos from Firebase...');
                console.log('ðŸ“Š Querying videos collection...');
                
                const videosSnapshot = await db.collection('videos').orderBy('episodeNumber').get();
                console.log('ðŸ“‹ Query completed. Documents found:', videosSnapshot.size);
                
                if (videosSnapshot.empty) {
                    console.log('ðŸ“ No videos found - initializing sample data...');
                    await initializeFirebaseData();
                    console.log('âœ… Sample data initialized successfully');
                } else {
                    console.log('ðŸ“– Loading existing videos from Firebase...');
                    videos = [];
                    
                    videosSnapshot.docs.forEach(doc => {
                        const data = doc.data();
                        console.log(`ðŸ“„ Processing video: Episode ${data.episodeNumber}`);
                        console.log(`ðŸ“Š Segments data:`, data.segments);
                        console.log(`ðŸ“Š Segments type:`, typeof data.segments);
                        console.log(`ðŸ“Š Is array:`, Array.isArray(data.segments));
                        
                        // Safely handle segments data
                        let processedSegments = [];
                        
                        if (data.segments && Array.isArray(data.segments)) {
                            console.log(`âœ… Valid segments array with ${data.segments.length} items`);
                            processedSegments = data.segments.map(segment => ({
                                ...segment,
                                ratings: segment.ratings || { ...defaultRatings }
                            }));
                        } else if (data.segments && typeof data.segments === 'object') {
                            console.log(`ðŸ”„ Converting segments object to array`);
                            const segmentValues = Object.values(data.segments);
                            processedSegments = segmentValues.map(segment => ({
                                ...segment,
                                ratings: segment.ratings || { ...defaultRatings }
                            }));
                            console.log(`ðŸ”„ Converted to array with ${processedSegments.length} items`);
                        } else {
                            console.log(`âš ï¸ No valid segments found for Episode ${data.episodeNumber}`);
                            processedSegments = generateDefaultSegments();
                        }
                        
                        const processedVideo = {
                            id: doc.id,
                            episodeNumber: data.episodeNumber,
                            title: data.title || `Omegle Bars Episode #${data.episodeNumber}`,
                            youtubeId: data.youtubeId || getYouTubeId(data.episodeNumber),
                            segments: processedSegments,
                            ratings: data.ratings || { ...defaultRatings }
                        };
                        
                        videos.push(processedVideo);
                        console.log(`âœ… Processed Episode ${data.episodeNumber} with ${processedSegments.length} segments`);
                    });
                    
                    console.log(`âœ… Successfully loaded ${videos.length} videos`);
                }
                
                // Separate rendering from data loading to prevent fallback on render errors
                console.log('ðŸŽ¨ Starting to render videos...');
                try {
                    renderVideos();
                    updateStats();
                    document.getElementById('loadingMessage').style.display = 'none';
                    document.getElementById('videoGrid').style.display = 'grid';
                    document.getElementById('statsBar').style.display = 'block';
                    updateConnectionStatus('connected');
                    console.log('âœ… Videos loaded and rendered successfully!');
                } catch (renderError) {
                    console.error('âŒ Error during rendering (keeping loaded data):', renderError);
                    console.error('âŒ Render error details:', renderError.message);
                    console.error('âŒ Render error stack:', renderError.stack);
                    showNotification('Error rendering videos. Data loaded but display may be incomplete.', 'error');
                    
                    // Show basic UI even if rendering fails
                    document.getElementById('loadingMessage').style.display = 'none';
                    document.getElementById('videoGrid').style.display = 'grid';
                    document.getElementById('statsBar').style.display = 'block';
                    updateConnectionStatus('connected');
                }
                
            } catch (error) {
                console.error('âŒ Error loading videos:', error);
                console.error('âŒ Error details:', error.message);
                console.error('âŒ Error code:', error.code);
                console.error('âŒ Error stack:', error.stack);
                showNotification('Error loading videos. Using demo data.', 'error');
                initializeDemoMode();
            }
        }

        async function initializeFirebaseData() {
            console.log('ðŸš€ Starting to generate sample videos...');
            const sampleVideos = generateSampleVideos();
            console.log(`ðŸ“Š Generated ${sampleVideos.length} sample videos`);
            
            if (db) {
                try {
                    console.log('ðŸ’¾ Saving sample data to Firebase...');
                    const batch = db.batch();
                    sampleVideos.forEach((video, index) => {
                        const docRef = db.collection('videos').doc(`episode_${video.episodeNumber}`);
                        batch.set(docRef, video);
                        if (index < 3) { // Log first 3 for debugging
                            console.log(`ðŸ“„ Preparing to save Episode ${video.episodeNumber}:`, video.title);
                        }
                    });
                    
                    console.log('â³ Committing batch write to Firebase...');
                    await batch.commit();
                    console.log('âœ… Sample data saved to Firebase successfully!');
                } catch (batchError) {
                    console.error('âŒ Error saving to Firebase:', batchError);
                    console.error('âŒ Batch error details:', batchError.message);
                    throw batchError; // Re-throw so the calling function handles it
                }
            } else {
                console.log('âš ï¸ No database connection - keeping data in memory only');
            }
            
            videos = sampleVideos;
            console.log(`âœ… Videos array populated with ${videos.length} items`);
        }

        function getYouTubeId(episodeNumber) {
            const youtubeIds = {
                1: 'GWhycrbmuhM',
                2: 'kI8-xlLZvH8', // Another Harry Mack video
                3: 'QIwWYx70RZE', // Another Harry Mack video
            };
            
            // Return known ID or create a placeholder that won't 404
            return youtubeIds[episodeNumber] || `GWhycrbmuhM`; // Use Episode 1 as fallback
        }
        
        function generateSampleVideos() {
            const wordBank = [
                "pizza", "galaxy", "thunderstorm", "basketball", "dragon", "coffee",
                "telephone", "rainbow", "adventure", "elephant", "computer", "sunshine",
                "bicycle", "ocean", "chocolate", "butterfly", "mountain", "music",
                "spaceship", "burger", "lightning", "guitar", "forest", "diamond",
                "robot", "sunset", "library", "airplane", "wizard", "sandwich",
                "telescope", "volcano", "penguin", "keyboard", "tornado", "ice cream"
            ];

            const sampleVideos = [];
            
            for (let i = 1; i <= 100; i++) {
                const segments = [];
                const numSegments = Math.random() < 0.8 ? 3 : (Math.random() < 0.5 ? 2 : 4);
                
                for (let j = 0; j < numSegments; j++) {
                    const numWords = Math.random() < 0.7 ? 3 : (Math.random() < 0.5 ? 2 : 4);
                    const segmentWords = [];
                    
                    // Generate candidate words with vote counts
                    for (let k = 0; k < numWords; k++) {
                        const candidateWords = [];
                        
                        // Get a random word for the main candidate
                        const baseWordIndex = Math.floor(Math.random() * wordBank.length);
                        const baseWord = wordBank[baseWordIndex];
                        
                        // Add the main word with high votes
                        candidateWords.push({
                            word: baseWord,
                            votes: Math.floor(Math.random() * 15) + 10,
                            voters: []
                        });
                        
                        // Sometimes add 1-2 alternative words with fewer votes (but not too many)
                        const numAlternatives = Math.random() < 0.4 ? 1 : (Math.random() < 0.2 ? 2 : 0);
                        
                        for (let alt = 0; alt < numAlternatives; alt++) {
                            let altWordIndex;
                            let altWord;
                            
                            // Make sure alternative word is different from base word
                            do {
                                altWordIndex = Math.floor(Math.random() * wordBank.length);
                                altWord = wordBank[altWordIndex];
                            } while (altWord === baseWord);
                            
                            // Only add if this word isn't already in the candidates
                            const wordExists = candidateWords.some(candidate => candidate.word === altWord);
                            if (!wordExists) {
                                candidateWords.push({
                                    word: altWord,
                                    votes: Math.floor(Math.random() * 5) + 1,
                                    voters: []
                                });
                            }
                        }
                        
                        segmentWords.push(candidateWords);
                    }
                    
                    // Generate ratings for this segment
                    const lyrics = Math.random() * 2 + 3;
                    const beats = Math.random() * 2 + 3;
                    const reaction = Math.random() * 2 + 3;
                    const overall = (lyrics + beats + reaction) / 3 + (Math.random() * 0.6 - 0.3);
                    
                    const baseRatingCount = Math.floor(Math.random() * 50) + 5;
                    
                    segments.push({
                        id: `segment_${i}_${j + 1}`, // Make ID unique with video number
                        words: segmentWords,
                        ratings: {
                            lyrics: { 
                                average: Math.max(1, Math.min(5, lyrics)),
                                count: baseRatingCount + Math.floor(Math.random() * 10) 
                            },
                            beats: { 
                                average: Math.max(1, Math.min(5, beats)), 
                                count: baseRatingCount + Math.floor(Math.random() * 12) 
                            },
                            reaction: { 
                                average: Math.max(1, Math.min(5, reaction)), 
                                count: baseRatingCount + Math.floor(Math.random() * 15) 
                            },
                            overall: { 
                                average: Math.max(1, Math.min(5, overall)), 
                                count: baseRatingCount + Math.floor(Math.random() * 8) 
                            }
                        }
                    });
                }

                // Calculate overall video ratings from segment averages
                const videoLyrics = segments.reduce((sum, seg) => sum + seg.ratings.lyrics.average, 0) / segments.length;
                const videoBeats = segments.reduce((sum, seg) => sum + seg.ratings.beats.average, 0) / segments.length;
                const videoReaction = segments.reduce((sum, seg) => sum + seg.ratings.reaction.average, 0) / segments.length;
                const videoOverall = segments.reduce((sum, seg) => sum + seg.ratings.overall.average, 0) / segments.length;
                
                const totalSegmentRatings = segments.reduce((sum, seg) => 
                    sum + seg.ratings.lyrics.count + seg.ratings.beats.count + seg.ratings.reaction.count + seg.ratings.overall.count, 0);

                const video = {
                    episodeNumber: i,
                    title: `Omegle Bars Episode #${i}`,
                    youtubeId: getYouTubeId(i),
                    segments: segments,
                    ratings: {
                        lyrics: { 
                            average: videoLyrics,
                            count: Math.floor(totalSegmentRatings * 0.25) 
                        },
                        beats: { 
                            average: videoBeats, 
                            count: Math.floor(totalSegmentRatings * 0.25) 
                        },
                        reaction: { 
                            average: videoReaction, 
                            count: Math.floor(totalSegmentRatings * 0.25) 
                        },
                        overall: { 
                            average: videoOverall, 
                            count: Math.floor(totalSegmentRatings * 0.25) 
                        }
                    }
                };

                sampleVideos.push(video);
            }
            
            videos = sampleVideos;
            return sampleVideos;
        }

        async function loadUserRatings() {
            if (!currentUser || !db) return;

            try {
                const ratingsSnapshot = await db.collection('userRatings')
                    .where('userId', '==', currentUser.uid)
                    .get();
                
                userRatings = {};
                
                ratingsSnapshot.docs.forEach(doc => {
                    const data = doc.data();
                    if (data.segmentId) {
                        // Segment-level rating
                        if (!userRatings[data.videoId]) {
                            userRatings[data.videoId] = { segments: {} };
                        }
                        userRatings[data.videoId].segments[data.segmentId] = data.ratings;
                    } else {
                        // Video-level rating (legacy)
                        if (!userRatings[data.videoId]) {
                            userRatings[data.videoId] = {};
                        }
                        userRatings[data.videoId].video = data.ratings;
                    }
                });
                
                updateUserRatingDisplay();
                
            } catch (error) {
                console.error('Error loading user ratings:', error);
            }
        }

        async function loadUserWordVotes() {
            if (!currentUser || !db) return;

            try {
                const votesSnapshot = await db.collection('userWordVotes')
                    .where('userId', '==', currentUser.uid)
                    .get();
                
                userWordVotes = {};
                
                votesSnapshot.docs.forEach(doc => {
                    const data = doc.data();
                    const key = `${data.videoId}_${data.segmentId}_${data.wordIndex}_${data.word}`;
                    userWordVotes[key] = data.voteType; // 'up' or 'down'
                });
                
            } catch (error) {
                console.error('Error loading user word votes:', error);
            }
        }

        function updateUserRatingDisplay() {
            // This will be called after renderVideos to update the display
            setTimeout(() => {
                Object.keys(userRatings).forEach(videoId => {
                    if (userRatings[videoId].segments) {
                        Object.keys(userRatings[videoId].segments).forEach(segmentId => {
                            const segmentRatings = userRatings[videoId].segments[segmentId];
                            const categories = ['lyrics', 'beats', 'reaction', 'overall'];
                            
                            categories.forEach(category => {
                                const rating = segmentRatings[category];
                                if (rating > 0) {
                                    const starsContainer = document.querySelector(`[data-video="${videoId}"][data-segment="${segmentId}"][data-category="${category}"]`)?.closest('.stars');
                                    if (starsContainer) {
                                        updateStarDisplay(starsContainer, rating, true);
                                        
                                        const controls = starsContainer.closest('.rating-controls');
                                        if (controls && !controls.querySelector('.user-rating-indicator')) {
                                            const indicator = document.createElement('div');
                                            indicator.className = 'user-rating-indicator';
                                            indicator.textContent = `Your rating: ${rating}â˜…`;
                                            controls.appendChild(indicator);
                                        }
                                    }
                                }
                            });
                        });
                    }
                    
                    // Handle video-level ratings (legacy)
                    if (userRatings[videoId].video) {
                        const videoRatings = userRatings[videoId].video;
                        const categories = ['lyrics', 'beats', 'reaction', 'overall'];
                        
                        categories.forEach(category => {
                            const rating = videoRatings[category];
                            if (rating > 0) {
                                const starsContainer = document.querySelector(`[data-video="${videoId}"][data-category="${category}"]:not([data-segment])`)?.closest('.stars');
                                if (starsContainer) {
                                    updateStarDisplay(starsContainer, rating, true);
                                    
                                    const controls = starsContainer.closest('.rating-controls');
                                    if (controls && !controls.querySelector('.user-rating-indicator')) {
                                        const indicator = document.createElement('div');
                                        indicator.className = 'user-rating-indicator';
                                        indicator.textContent = `Your rating: ${rating}â˜…`;
                                        controls.appendChild(indicator);
                                    }
                                }
                            }
                        });
                    }
                });
            }, 100);
        }

        async function submitRating(videoId, category, rating, segmentId = null) {
            try {
                if (!userRatings[videoId]) {
                    userRatings[videoId] = { segments: {} };
                }
                
                if (segmentId) {
                    if (!userRatings[videoId].segments[segmentId]) {
                        userRatings[videoId].segments[segmentId] = { lyrics: 0, beats: 0, reaction: 0, overall: 0 };
                    }
                    userRatings[videoId].segments[segmentId][category] = rating;
                } else {
                    if (!userRatings[videoId].video) {
                        userRatings[videoId].video = { lyrics: 0, beats: 0, reaction: 0, overall: 0 };
                    }
                    userRatings[videoId].video[category] = rating;
                }

                if (db) {
                    const docId = segmentId ? 
                        `${currentUser.uid}_${videoId}_${segmentId}` : 
                        `${currentUser.uid}_${videoId}`;
                    
                    const ratingsData = {
                        userId: currentUser.uid,
                        videoId: videoId,
                        ratings: segmentId ? userRatings[videoId].segments[segmentId] : userRatings[videoId].video,
                        lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                    };
                    
                    if (segmentId) {
                        ratingsData.segmentId = segmentId;
                    }

                    await db.collection('userRatings').doc(docId).set(ratingsData);
                    await updateVideoRating(videoId, category, rating, segmentId);
                }

                const segmentText = segmentId ? ` (${segmentId})` : '';
                showNotification(`Rated ${category}${segmentText}: ${rating} stars! Thanks for contributing!`, 'success');
                
            } catch (error) {
                console.error('Error submitting rating:', error);
                showNotification('Failed to save rating. Please try again.', 'error');
            }
        }

        async function updateVideoRating(videoId, category, newRating, segmentId = null) {
            if (!db) return;

            try {
                const docId = segmentId ? `${videoId}_${segmentId}_${category}` : `${videoId}_${category}`;
                const ratingsRef = db.collection(segmentId ? 'segmentRatings' : 'ratings').doc(docId);
                
                await db.runTransaction(async (transaction) => {
                    const ratingsDoc = await transaction.get(ratingsRef);
                    
                    let totalRating = newRating;
                    let count = 1;
                    
                    if (ratingsDoc.exists) {
                        const data = ratingsDoc.data();
                        totalRating = data.totalRating + newRating;
                        count = data.count + 1;
                    }
                    
                    const average = totalRating / count;
                    
                    transaction.set(ratingsRef, {
                        totalRating: totalRating,
                        count: count,
                        average: average,
                        videoId: videoId,
                        category: category
                    });
                    
                    if (segmentId) {
                        transaction.set(ratingsRef, {
                            ...ratingsRef.data,
                            segmentId: segmentId
                        });
                    }
                    
                    // Update the video document
                    const videoRef = db.collection('videos').doc(`episode_${videoId}`);
                    if (segmentId) {
                        transaction.update(videoRef, {
                            [`segments.${segmentId}.ratings.${category}.average`]: average,
                            [`segments.${segmentId}.ratings.${category}.count`]: count
                        });
                    } else {
                        transaction.update(videoRef, {
                            [`ratings.${category}.average`]: average,
                            [`ratings.${category}.count`]: count
                        });
                    }
                });
                
                // Update local data
                const video = videos.find(v => v.episodeNumber.toString() === videoId);
                if (video) {
                    if (segmentId) {
                        const segment = video.segments.find(s => s.id === segmentId);
                        if (segment && segment.ratings) {
                            const currentData = segment.ratings[category];
                            const newTotal = (currentData.average * currentData.count) + newRating;
                            const newCount = currentData.count + 1;
                            segment.ratings[category] = { average: newTotal / newCount, count: newCount };
                        }
                    } else {
                        const currentData = video.ratings[category];
                        const newTotal = (currentData.average * currentData.count) + newRating;
                        const newCount = currentData.count + 1;
                        video.ratings[category] = { average: newTotal / newCount, count: newCount };
                    }
                    renderVideos();
                    updateStats();
                }
            } catch (error) {
                console.error('Error updating rating:', error);
            }
        }

        async function voteOnWord(videoId, segmentId, wordIndex, word, voteType) {
            if (!currentUser) {
                showSignInPrompt('word voting', 0);
                return;
            }
            try {
                const voteKey = `${videoId}_${segmentId}_${wordIndex}_${word}`;
                const currentVote = userWordVotes[voteKey];

                // Toggle vote or change vote type
                let newVoteType = null;
                if (currentVote === voteType) {
                    // Remove vote if clicking same type
                    newVoteType = null;
                } else {
                    // Set new vote type
                    newVoteType = voteType;
                }
                userWordVotes[voteKey] = newVoteType;

                if (db) {
                    const voteDocId = `${currentUser.uid}_${voteKey}`;
                    if (newVoteType) {
                        await db.collection('userWordVotes').doc(voteDocId).set({
                            userId: currentUser.uid,
                            videoId: videoId,
                            segmentId: segmentId,
                            wordIndex: wordIndex,
                            word: word,
                            voteType: newVoteType,
                            timestamp: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    } else {
                        await db.collection('userWordVotes').doc(voteDocId).delete();
                    }

                    await updateWordVotes(videoId, segmentId, wordIndex, word, currentVote, newVoteType);
                }

                renderVideos();
                showNotification(`${newVoteType ? (newVoteType === 'up' ? 'Upvoted' : 'Downvoted') : 'Removed vote on'} word: ${word}`, 'success');
                
            } catch (error) {
                console.error('Error voting on word:', error);
                showNotification('Failed to save vote. Please try again.', 'error');
            }
        }

        async function updateWordVotes(videoId, segmentId, wordIndex, word, oldVote, newVote) {
            if (!db) return;

            try {
                const video = videos.find(v => v.episodeNumber.toString() === videoId);
                if (!video) return;

                const segment = video.segments.find(s => s.id === segmentId);
                if (!segment || !segment.words[wordIndex]) return;

                const wordCandidate = segment.words[wordIndex].find(w => w.word === word);
                if (!wordCandidate) return;

                // Update vote counts
                if (oldVote === 'up') wordCandidate.votes--;
                if (oldVote === 'down') wordCandidate.votes++;
                if (newVote === 'up') wordCandidate.votes++;
                if (newVote === 'down') wordCandidate.votes--;

                // Ensure votes don't go below 0
                wordCandidate.votes = Math.max(0, wordCandidate.votes);

                // Update in Firebase
                const videoRef = db.collection('videos').doc(`episode_${videoId}`);
                await videoRef.update({
                    [`segments`]: video.segments
                });

            } catch (error) {
                console.error('Error updating word votes:', error);
            }
        }

        async function addNewWord(videoId, segmentId, wordIndex, newWord) {
            if (!currentUser) {
                showSignInPrompt('add words', 0);
                return;
            }

            if (!newWord.trim()) {
                showNotification('Please enter a word', 'error');
                return;
            }

            try {
                const video = videos.find(v => v.episodeNumber.toString() === videoId);
                if (!video) return;

                const segment = video.segments.find(s => s.id === segmentId);
                if (!segment) return;

                // Check if word already exists
                const existingWord = segment.words[wordIndex].find(w => w.word.toLowerCase() === newWord.trim().toLowerCase()
                );

                if (existingWord) {
                    showNotification('This word already exists for this position', 'info');
                    return;
                }

                // Add new word
                const newWordObj = {
                    word: newWord.trim(),
                    votes: 1, // Start with 1 vote from the submitter
                    voters: [currentUser.uid]
                };
                segment.words[wordIndex].push(newWordObj);

                if (db) {
                    const videoRef = db.collection('videos').doc(`episode_${videoId}`);
                    await videoRef.update({
                        [`segments`]: video.segments
                    });

                    // Auto-vote for the word the user just added
                    const voteKey = `${videoId}_${segmentId}_${wordIndex}_${newWord.trim()}`;
                    userWordVotes[voteKey] = 'up';
                    const voteDocId = `${currentUser.uid}_${voteKey}`;
                    await db.collection('userWordVotes').doc(voteDocId).set({
                        userId: currentUser.uid,
                        videoId: videoId,
                        segmentId: segmentId,
                        wordIndex: wordIndex,
                        word: newWord.trim(),
                        voteType: 'up',
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }
                
                renderVideos();
                showNotification(`Added new word: ${newWord.trim()}`, 'success');

            } catch (error) {
                console.error('Error adding word:', error);
                showNotification('Failed to add word. Please try again.', 'error');
            }
        }

        function createStarRating(category, videoId, currentRating, ratingCount, segmentId = null) {
            let starsHtml = '';
            const ratingKey = segmentId ? (userRatings[videoId]?.segments?.[segmentId]?.[category] || 0) : (userRatings[videoId]?.video?.[category] || 0);

            for (let i = 1; i <= 5; i++) {
                const activeClass = i <= Math.round(currentRating) ? 'active' : '';
                const userRatedClass = ratingKey > 0 && i <= ratingKey ? 'user-rated' : '';
                const dataAttrs = segmentId ? `data-rating="${i}" data-category="${category}" data-video="${videoId}" data-segment="${segmentId}"` : `data-rating="${i}" data-category="${category}" data-video="${videoId}"`;
                starsHtml += `<span class="star ${activeClass} ${userRatedClass}" ${dataAttrs}>â˜…</span>`;
            }
            return starsHtml;
        }

        function createWordCandidatesHtml(wordCandidates, videoId, segmentId, wordIndex) {
            console.log(`ðŸ” Processing word candidates for ${videoId}-${segmentId}-${wordIndex}:`, wordCandidates);
            console.log(`ðŸ“Š Type:`, typeof wordCandidates, `Is Array:`, Array.isArray(wordCandidates));
            
            // Ensure we have a valid array of candidates
            let validCandidates = [];
            
            if (Array.isArray(wordCandidates)) {
                // It's already an array - filter out invalid entries
                validCandidates = wordCandidates.filter(candidate => 
                    candidate && 
                    candidate.word && 
                    typeof candidate.word === 'string' && 
                    candidate.word.trim() !== ''
                );
                console.log(`âœ… Filtered ${validCandidates.length} valid candidates from ${wordCandidates.length} total`);
            } else if (wordCandidates && typeof wordCandidates === 'object') {
                // It's an object - convert to array
                console.log(`ðŸ”„ Converting object to array of candidates`);
                const candidateValues = Object.values(wordCandidates);
                validCandidates = candidateValues.filter(candidate => 
                    candidate && 
                    candidate.word && 
                    typeof candidate.word === 'string' && 
                    candidate.word.trim() !== ''
                );
                console.log(`ðŸ”„ Converted object with ${candidateValues.length} values to ${validCandidates.length} valid candidates`);
            } else if (typeof wordCandidates === 'string') {
                // It's just a string - create a simple candidate object
                console.log(`ðŸ”§ Converting string "${wordCandidates}" to candidate object`);
                validCandidates = [{
                    word: wordCandidates,
                    votes: 5, // Default vote count
                    voters: []
                }];
            } else {
                // Fallback - create a default word
                console.log(`âš ï¸ Unknown word candidates format, creating fallback`);
                validCandidates = [{
                    word: 'unknown',
                    votes: 1,
                    voters: []
                }];
            }
            
            // Sort by votes (highest first)
            const sortedCandidates = validCandidates.sort((a, b) => (b.votes || 0) - (a.votes || 0));
            
            return sortedCandidates.map(candidate => {
                const voteKey = `${videoId}_${segmentId}_${wordIndex}_${candidate.word}`;
                const userVote = userWordVotes[voteKey];
                return `
                    <div class="word-item">
                        <span>${candidate.word}</span>
                        <span class="word-votes">${candidate.votes || 0}</span>
                        <div class="vote-buttons">
                            <button class="vote-btn ${userVote === 'up' ? 'voted' : ''}" onclick="voteOnWord('${videoId}', '${segmentId}', ${wordIndex}, '${candidate.word}', 'up')">
                                â†‘
                            </button>
                            <button class="vote-btn ${userVote === 'down' ? 'voted' : ''}" onclick="voteOnWord('${videoId}', '${segmentId}', ${wordIndex}, '${candidate.word}', 'down')">
                                â†“
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function createSegmentHtml(segment, videoId, segmentIndex) {
            console.log(`ðŸ”§ Creating segment HTML for ${videoId}-${segmentIndex}:`, segment);
            
            try {
                const segmentId = segment.id || `fallback_segment_${segmentIndex}`;
                console.log(`ðŸ“‹ Segment ID: ${segmentId}`);
                
                // Ensure segment has ratings - if not, use defaults
                const segmentRatings = segment.ratings || defaultRatings;
                console.log(`â­ Segment ratings:`, segmentRatings);
                
                const avgRating = (segmentRatings.lyrics.average + segmentRatings.beats.average + segmentRatings.reaction.average + segmentRatings.overall.average) / 4;
                console.log(`ðŸ“Š Average rating: ${avgRating}`);

                // Process words with extensive debugging
                console.log(`ðŸ”¤ Processing words for segment:`, segment.words);
                console.log(`ðŸ”¤ Words type:`, typeof segment.words, `Is Array:`, Array.isArray(segment.words));
                
                let wordsHtml = '';
                if (segment.words) {
                    if (Array.isArray(segment.words)) {
                        console.log(`âœ… Words is array with ${segment.words.length} items`);
                        wordsHtml = segment.words.map((wordCandidates, wordIndex) => {
                            console.log(`ðŸ”¤ Processing word ${wordIndex}:`, wordCandidates);
                            try {
                                return `
                                    <div style="margin-bottom: 15px;">
                                        <div class="segment-label">Word ${wordIndex + 1}</div>
                                        <div class="word-list">
                                            ${createWordCandidatesHtml(wordCandidates, videoId, segmentId, wordIndex)}
                                        </div>
                                        <div class="add-word-form">
                                            <input type="text" class="add-word-input" placeholder="Add alternative word..." id="newWord_${videoId}_${segmentId}_${wordIndex}">
                                            <button class="add-word-btn" onclick="addWordFromInput('${videoId}', '${segmentId}', ${wordIndex})">
                                                Add
                                            </button>
                                        </div>
                                    </div>
                                `;
                            } catch (wordError) {
                                console.error(`âŒ Error processing word ${wordIndex}:`, wordError);
                                return `<div class="word-error">Error loading word ${wordIndex + 1}</div>`;
                            }
                        }).join('');
                    } else if (typeof segment.words === 'object') {
                        console.log(`ðŸ”„ Converting words object to array`);
                        const wordEntries = Object.entries(segment.words);
                        console.log(`ðŸ”¤ Word entries:`, wordEntries);
                        wordsHtml = wordEntries.map(([wordKey, wordValue], wordIndex) => {
                            console.log(`ðŸ”¤ Processing word entry ${wordIndex} (${wordKey}):`, wordValue);
                            try {
                                // Convert single word to candidate format
                                let wordCandidates = [];
                                if (typeof wordValue === 'string') {
                                    wordCandidates = [{word: wordValue, votes: 5, voters: []}];
                                } else if (wordValue && wordValue.word) {
                                    wordCandidates = [wordValue];
                                } else {
                                    wordCandidates = [{word: 'unknown', votes: 1, voters: []}];
                                }
                                
                                return `
                                    <div style="margin-bottom: 15px;">
                                        <div class="segment-label">Word ${wordIndex + 1}</div>
                                        <div class="word-list">
                                            ${createWordCandidatesHtml(wordCandidates, videoId, segmentId, wordIndex)}
                                        </div>
                                        <div class="add-word-form">
                                            <input type="text" class="add-word-input" placeholder="Add alternative word..." id="newWord_${videoId}_${segmentId}_${wordIndex}">
                                            <button class="add-word-btn" onclick="addWordFromInput('${videoId}', '${segmentId}', ${wordIndex})">
                                                Add
                                            </button>
                                        </div>
                                    </div>
                                `;
                            } catch (wordError) {
                                console.error(`âŒ Error processing word entry ${wordIndex}:`, wordError);
                                return `<div class="word-error">Error loading word ${wordIndex + 1}</div>`;
                            }
                        }).join('');
                    } else {
                        console.log(`âš ï¸ Words is neither array nor object:`, segment.words);
                        wordsHtml = '<div class="no-words">No words available</div>';
                    }
                } else {
                    console.log(`âš ï¸ No words found in segment`);
                    wordsHtml = '<div class="no-words">No words available</div>';
                }

                console.log(`âœ… Successfully created segment HTML for ${segmentId}`);

                return `
                    <div class="segment" data-segment="${segmentId}">
                        <div class="segment-header" onclick="toggleSegment('${videoId}', '${segmentId}')">
                            <div class="segment-info">
                                <div class="segment-title">Segment ${segmentIndex + 1}</div>
                                <div class="segment-rating-summary">${avgRating.toFixed(1)}â˜… average</div>
                            </div>
                            <div class="segment-expand-icon">â–¶</div>
                        </div>
                        <div class="segment-content">
                            <div class="segment-details">
                                <div class="words-management">
                                    <h5>Crowdsourced Words (vote on accuracy)</h5>
                                    ${wordsHtml}
                                </div>
                                <div class="segment-ratings">
                                    <h5 style="color: #2c3e50; margin-bottom: 15px; font-size: 0.85rem;">Rate This Segment</h5>
                                    ${['lyrics', 'beats', 'reaction', 'overall'].map(category => `
                                        <div class="rating-category">
                                            <div class="rating-info">
                                                <span class="rating-label">${category.charAt(0).toUpperCase() + category.slice(1)}</span>
                                                <span class="rating-stats">${segmentRatings[category].average.toFixed(1)}â˜… (${segmentRatings[category].count} ratings)</span>
                                            </div>
                                            <div class="rating-controls">
                                                <div class="stars" data-category="${category}" data-video="${videoId}" data-segment="${segmentId}">
                                                    ${createStarRating(category, videoId, segmentRatings[category].average, segmentRatings[category].count, segmentId)}
                                                </div>
                                                ${userRatings[videoId]?.segments?.[segmentId]?.[category] ? `<div class="user-rating-indicator">Your rating: ${userRatings[videoId].segments[segmentId][category]}â˜…</div>` : ''}
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
            } catch (error) {
                console.error(`âŒ Error in createSegmentHtml for ${videoId}-${segmentIndex}:`, error);
                console.error(`âŒ Segment data:`, segment);
                return `
                    <div class="segment segment-error">
                        <div class="segment-header">
                            <div class="segment-info">
                                <div class="segment-title">Segment ${segmentIndex + 1} (Error)</div>
                                <div class="segment-rating-summary">Unable to load</div>
                            </div>
                        </div>
                    </div>
                `;
            }
        }

        function renderVideos() {
            console.log('ðŸŽ¨ Starting renderVideos function...');
            console.log(`ðŸ“Š Videos to render: ${videos.length}`);
            
            const videoGrid = document.getElementById('videoGrid');
            videoGrid.innerHTML = ''; // Clear existing videos

            let filteredVideos = [...videos];
            console.log(`ðŸ“‹ Initial video count: ${filteredVideos.length}`);

            // Apply filters
            const sortFilter = document.getElementById('sortFilter').value;
            const ratingFilter = parseFloat(document.getElementById('ratingFilter').value);
            const searchFilter = document.getElementById('searchFilter').value.toLowerCase();

            console.log(`ðŸ” Filters - Sort: ${sortFilter}, Rating: ${ratingFilter}, Search: "${searchFilter}"`);

            // Filter by rating
            if (ratingFilter > 0) {
                const beforeCount = filteredVideos.length;
                filteredVideos = filteredVideos.filter(video => video.ratings.overall.average >= ratingFilter);
                console.log(`ðŸ“Š Rating filter: ${beforeCount} â†’ ${filteredVideos.length} videos`);
            }

            // Filter by search term
            if (searchFilter) {
                const beforeCount = filteredVideos.length;
                filteredVideos = filteredVideos.filter(video => {
                    try {
                        return video.title.toLowerCase().includes(searchFilter) ||
                               video.episodeNumber.toString().includes(searchFilter) ||
                               (video.segments && video.segments.some(segment =>
                                   segment.words && segment.words.some(wordCandidates => {
                                       if (Array.isArray(wordCandidates)) {
                                           return wordCandidates.some(candidate =>
                                               candidate && candidate.word && 
                                               candidate.word.toLowerCase().includes(searchFilter)
                                           );
                                       }
                                       return false;
                                   })
                               ));
                    } catch (searchError) {
                        console.error(`âŒ Search error for video ${video.episodeNumber}:`, searchError);
                        return true; // Include video if search fails
                    }
                });
                console.log(`ðŸ” Search filter: ${beforeCount} â†’ ${filteredVideos.length} videos`);
            }

            // Sort videos
            filteredVideos.sort((a, b) => {
                if (sortFilter === 'episode') {
                    return a.episodeNumber - b.episodeNumber;
                } else {
                    return b.ratings[sortFilter].average - a.ratings[sortFilter].average;
                }
            });
            console.log(`ðŸ“Š Sorted ${filteredVideos.length} videos by ${sortFilter}`);

            // Render each video with error handling
            let successCount = 0;
            let errorCount = 0;
            
            filteredVideos.forEach((video, index) => {
                try {
                    console.log(`ðŸŽ¬ Rendering video ${index + 1}/${filteredVideos.length}: Episode ${video.episodeNumber}`);
                    
                    const videoCard = document.createElement('div');
                    videoCard.className = 'video-card';
                    
                    // Create video card HTML with error handling for segments
                    let segmentsHtml = '';
                    if (video.segments && Array.isArray(video.segments)) {
                        console.log(`ðŸ“¦ Processing ${video.segments.length} segments for Episode ${video.episodeNumber}`);
                        try {
                            segmentsHtml = video.segments.map((segment, segIndex) => {
                                try {
                                    return createSegmentHtml(segment, video.episodeNumber, segIndex);
                                } catch (segmentError) {
                                    console.error(`âŒ Error rendering segment ${segIndex} for Episode ${video.episodeNumber}:`, segmentError);
                                    return `<div class="segment-error">Error loading segment ${segIndex + 1}</div>`;
                                }
                            }).join('');
                        } catch (segmentsError) {
                            console.error(`âŒ Error processing segments for Episode ${video.episodeNumber}:`, segmentsError);
                            segmentsHtml = '<div class="segments-error">Error loading segments</div>';
                        }
                    } else {
                        console.log(`âš ï¸ No valid segments for Episode ${video.episodeNumber}`);
                        segmentsHtml = '<div class="no-segments">No segments available</div>';
                    }
                    
                    videoCard.innerHTML = `
                        <div class="video-embed" style="position: relative; cursor: pointer; background-image: url('https://img.youtube.com/vi/${video.youtubeId}/maxresdefault.jpg'); background-size: cover; background-position: center;" onclick="window.open('https://www.youtube.com/watch?v=${video.youtubeId}', '_blank')">
                            <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center;">
                                <div style="text-align: center; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">
                                    <div style="font-size: 4rem; margin-bottom: 10px;">â–¶ï¸</div>
                                    <div style="font-size: 1.1rem; font-weight: bold;">Episode #${video.episodeNumber}</div>
                                    <div style="font-size: 0.9rem; opacity: 0.9;">Click to watch on YouTube</div>
                                </div>
                            </div>
                        </div>
                        <div class="video-content">
                            <h3 class="video-title">${video.title}</h3>
                            <div class="overall-rating">
                                <h4>Overall Video Rating</h4>
                                <div class="rating-category">
                                    <div class="rating-info">
                                        <span class="rating-label">Overall</span>
                                        <span class="rating-stats">${video.ratings.overall.average.toFixed(1)}â˜… (${video.ratings.overall.count} ratings)</span>
                                    </div>
                                    <div class="rating-controls">
                                        <div class="stars" data-category="overall" data-video="${video.episodeNumber}">
                                            ${createStarRating('overall', video.episodeNumber, video.ratings.overall.average, video.ratings.overall.count)}
                                        </div>
                                        ${userRatings[video.episodeNumber]?.video?.overall ? `<div class="user-rating-indicator">Your rating: ${userRatings[video.episodeNumber].video.overall}â˜…</div>` : ''}
                                    </div>
                                </div>
                            </div>

                            <div class="segments-section">
                                <div class="segments-header">
                                    <h4>Segments (${video.segments ? video.segments.length : 0})</h4>
                                    <button class="expand-toggle" onclick="toggleAllSegments('${video.episodeNumber}')">Expand All</button>
                                </div>
                                <div class="segments-container" data-video="${video.episodeNumber}">
                                    ${segmentsHtml}
                                </div>
                            </div>
                        </div>
                    `;
                    videoGrid.appendChild(videoCard);
                    successCount++;
                    
                } catch (videoError) {
                    console.error(`âŒ Error rendering video ${video.episodeNumber}:`, videoError);
                    console.error(`âŒ Video error details:`, videoError.message);
                    errorCount++;
                    
                    // Create a basic error card
                    const errorCard = document.createElement('div');
                    errorCard.className = 'video-card';
                    errorCard.innerHTML = `
                        <div class="video-content">
                            <h3 class="video-title">Episode #${video.episodeNumber} (Error)</h3>
                            <p>Error loading this episode. Please try refreshing.</p>
                        </div>
                    `;
                    videoGrid.appendChild(errorCard);
                }
            });

            console.log(`âœ… Rendering complete: ${successCount} success, ${errorCount} errors`);

            // Attach star rating event listeners
            try {
                document.querySelectorAll('.star').forEach(star => {
                    star.onclick = function() {
                        const rating = parseInt(this.dataset.rating);
                        const category = this.dataset.category;
                        const videoId = this.dataset.video;
                        const segmentId = this.dataset.segment || null;
                        if (currentUser) {
                            submitRating(videoId, category, rating, segmentId);
                        } else {
                            showSignInPrompt('rate segments', 0);
                        }
                    };
                });
                console.log('âœ… Star rating event listeners attached');
            } catch (eventError) {
                console.error('âŒ Error attaching event listeners:', eventError);
            }

            // Update user rating display after rendering
            try {
                updateUserRatingDisplay();
                console.log('âœ… User rating display updated');
            } catch (displayError) {
                console.error('âŒ Error updating user rating display:', displayError);
            }
        }

        function updateStarDisplay(starsContainer, rating, userRated = false) {
            const stars = starsContainer.querySelectorAll('.star');
            stars.forEach((star, index) => {
                star.classList.remove('active', 'user-rated');
                if (index < rating) {
                    star.classList.add('active');
                }
                if (userRated && index < rating) {
                    star.classList.add('user-rated');
                }
            });
        }

        function toggleSegment(videoId, segmentId) {
            // Find the segment within the specific video container
            const videoContainer = document.querySelector(`.segments-container[data-video="${videoId}"]`);
            if (videoContainer) {
                const segmentElement = videoContainer.querySelector(`.segment[data-segment="${segmentId}"]`);
                if (segmentElement) {
                    segmentElement.classList.toggle('expanded');
                }
            }
        }

        function toggleAllSegments(videoId) {
            const container = document.querySelector(`.segments-container[data-video="${videoId}"]`);
            if (container) {
                const segments = container.querySelectorAll('.segment');
                let allExpanded = true;
                segments.forEach(segment => {
                    if (!segment.classList.contains('expanded')) {
                        allExpanded = false;
                    }
                });

                segments.forEach(segment => {
                    if (allExpanded) {
                        segment.classList.remove('expanded');
                    } else {
                        segment.classList.add('expanded');
                    }
                });
                
                // Update button text
                const button = container.closest('.video-card').querySelector('.expand-toggle');
                if (button) {
                    button.textContent = allExpanded ? 'Expand All' : 'Collapse All';
                }
            }
        }

        function addWordFromInput(videoId, segmentId, wordIndex) {
            const inputId = `newWord_${videoId}_${segmentId}_${wordIndex}`;
            const inputElement = document.getElementById(inputId);
            const newWord = inputElement.value;
            addNewWord(videoId, segmentId, wordIndex, newWord);
            inputElement.value = ''; // Clear input after adding
        }

        function updateStats() {
            let totalRatings = 0;
            let totalOverallRating = 0;
            let overallRatingCount = 0;
            let maxOverallRating = 0;
            let topEpisode = '#--';

            videos.forEach(video => {
                if (video.ratings.overall.count > 0) {
                    totalOverallRating += video.ratings.overall.average * video.ratings.overall.count;
                    overallRatingCount += video.ratings.overall.count;
                }

                if (video.segments) {
                    video.segments.forEach(segment => {
                        if (segment.ratings) {
                            Object.values(segment.ratings).forEach(rating => {
                                totalRatings += rating.count;
                            });
                        }
                    });
                }
                
                if (video.ratings.overall.average > maxOverallRating) {
                    maxOverallRating = video.ratings.overall.average;
                    topEpisode = `#${video.episodeNumber}`;
                }
            });

            document.getElementById('totalRatings').textContent = totalRatings;
            document.getElementById('avgOverall').textContent = overallRatingCount > 0 ? (totalOverallRating / overallRatingCount).toFixed(1) : '0.0';
            document.getElementById('activeUsers').textContent = Object.keys(userRatings).length;
            document.getElementById('topEpisode').textContent = topEpisode;
        }
        
        function showNotification(message, type) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        function showSignInPrompt(action, delay = 0) {
            setTimeout(() => {
                showNotification(`Please sign in to ${action}.`, 'info');
            }, delay);
        }

        function init() {
            updateConnectionStatus('connecting');
            
            initializeFirebase();
            
            // Setup filters
            document.getElementById('sortFilter').addEventListener('change', applyFilters);
            document.getElementById('ratingFilter').addEventListener('change', applyFilters);
            document.getElementById('searchFilter').addEventListener('input', applyFilters);
            
            setupRealtimeUpdates();
        
            document.getElementById('authButton').addEventListener('click', () => {
                if (currentUser) {
                    signOut();
                } else {
                    signIn();
                }
            });
        }

        function applyFilters() {
            renderVideos(); // Re-render videos based on current filter settings
        }

        function setupRealtimeUpdates() {
            if (!db) return; // Don't setup if in demo mode
            
            db.collection('videos').onSnapshot((snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === 'modified') {
                        const updatedVideo = { id: change.doc.id, ...change.doc.data() };
                        const index = videos.findIndex(v => v.episodeNumber === updatedVideo.episodeNumber);
                        if (index !== -1) {
                            videos[index] = updatedVideo;
                        }
                    }
                });
                
                if (snapshot.docChanges().length > 0) {
                    applyFilters();
                    updateStats();
                }
            });
        }

        // Make functions globally available for onclick handlers
        window.voteOnWord = voteOnWord;
        window.addWordFromInput = addWordFromInput;
        window.toggleSegment = toggleSegment;
        window.toggleAllSegments = toggleAllSegments;
 
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>

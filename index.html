<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harry Mack Omegle Bars - Community Hub</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            color: white;
            position: relative;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .user-section {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .user-info {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .auth-button {
            display: inline-flex;
            align-items: center;
            background: white;
            color: #3c4043;
            border: 1px solid #dadce0;
            border-radius: 24px;
            padding: 8px 16px;
            font-family: 'Google Sans', Roboto, Arial, sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px 0 rgba(60,64,67,0.30);
            gap: 8px;
        }
        
        .auth-button {
            display: inline-flex;
            align-items: center;
            background: white;
            color: #3c4043;
            border: 1px solid #dadce0;
            border-radius: 24px;
            padding: 10px 16px;
            font-family: 'Google Sans', 'Roboto', Arial, sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px 0 rgba(60,64,67,0.30), 0 1px 3px 1px rgba(60,64,67,0.15);
            gap: 12px;
            min-height: 40px;
        }
        
        .auth-button:hover {
            background: #f8f9fa;
            border-color: #c1c7cd;
            box-shadow: 0 1px 3px 1px rgba(60,64,67,0.15), 0 1px 2px 0 rgba(60,64,67,0.30);
        }
        
        .auth-button:active {
            background: #f1f3f4;
            box-shadow: 0 1px 2px 0 rgba(60,64,67,0.30);
        }
        
        .google-icon {
            width: 18px;
            height: 18px;
            display: block;
        }
        
        .connection-status {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
            z-index: 1000;
        }

        .status-connected {
            background: #27ae60;
            color: white;
        }

        .status-disconnected {
            background: #e74c3c;
            color: white;
        }

        .status-demo {
            background: #f39c12;
            color: white;
        }

        .status-connecting {
            background: #f39c12;
            color: white;
        }

        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
        }

        .video-card {
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .video-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
        }

        .video-embed {
            position: relative;
            width: 100%;
            height: 200px;
            background: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 14px;
        }

        .video-content {
            padding: 20px;
        }

        .video-title {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .overall-rating {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border-left: 4px solid #3498db;
        }

        .overall-rating h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .segments-section {
            margin-bottom: 20px;
        }

        .segments-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .segments-header h4 {
            color: #8e44ad;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .expand-toggle {
            background: #8e44ad;
            color: white;
            border: none;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .expand-toggle:hover {
            background: #7d3c98;
        }

        .segment {
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 15px;
            border-left: 4px solid #e74c3c;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .segment-header {
            padding: 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #fff;
            border-bottom: 1px solid #eee;
        }

        .segment-header:hover {
            background: #f8f9fa;
        }

        .segment-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .segment-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
        }

        .segment-rating-summary {
            font-size: 0.75rem;
            color: #7f8c8d;
        }

        .segment-expand-icon {
            color: #8e44ad;
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }

        .segment.expanded .segment-expand-icon {
            transform: rotate(90deg);
        }

        .segment-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .segment.expanded .segment-content {
            max-height: 600px;
        }

        .segment-details {
            padding: 20px;
        }

        .words-management {
            margin-bottom: 20px;
        }

        .words-management h5 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 0.85rem;
        }

        .word-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }

        .word-item {
            display: flex;
            align-items: center;
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 0.8rem;
            gap: 5px;
        }

        .word-votes {
            background: rgba(255, 255, 255, 0.3);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
        }

        .vote-buttons {
            display: flex;
            gap: 2px;
        }

        .vote-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.7rem;
            transition: background 0.2s ease;
        }

        .vote-btn:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        .vote-btn.voted {
            background: rgba(255, 255, 255, 0.8);
            color: #333;
        }

        .add-word-form {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .add-word-input {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 0.8rem;
        }

        .add-word-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background 0.3s ease;
        }

        .add-word-btn:hover {
            background: #229954;
        }

        .segment-ratings {
            border-top: 1px solid #eee;
            padding-top: 15px;
        }

        .rating-category {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .rating-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .rating-label {
            font-weight: 600;
            color: #34495e;
            font-size: 0.85rem;
        }

        .rating-stats {
            font-size: 0.7rem;
            color: #7f8c8d;
            margin-top: 2px;
        }

        .rating-controls {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
        }

        .stars {
            display: flex;
            gap: 3px;
        }

        .star {
            width: 20px;
            height: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #ddd;
            user-select: none;
        }

        .star:hover,
        .star.active {
            color: #f39c12;
            transform: scale(1.1);
        }

        .star.user-rated {
            color: #e74c3c;
        }

        .user-rating-indicator {
            font-size: 0.65rem;
            color: #e74c3c;
            font-weight: bold;
        }

        .stats-bar {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            color: white;
            text-align: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .stat-item {
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .filter-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            color: white;
        }

        .filter-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-controls select,
        .filter-controls input {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            background: white;
            color: #333;
        }

        .loading {
            text-align: center;
            color: white;
            font-size: 1.2rem;
            margin: 50px 0;
        }

        .error-message {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 10px;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: slideIn 0.3s ease;
        }

        .notification.success {
            background: #27ae60;
            color: white;
        }

        .notification.error {
            background: #e74c3c;
            color: white;
        }

        .notification.info {
            background: #3498db;
            color: white;
        }

        .segment-label {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .debug-info {
            background: #ffeb3b;
            color: #333;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 0.8rem;
            font-family: monospace;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @media (max-width: 768px) {
            .video-grid {
                grid-template-columns: 1fr;
            }
            .header h1 {
                font-size: 2rem;
            }
            .user-section {
                position: static;
                justify-content: center;
                margin-top: 15px;
            }
            .filter-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>

<body>
    <div class="connection-status" id="connectionStatus">
        <span id="statusText">Connecting...</span>
    </div>

    <div class="container">
        <div class="header">
            <div class="user-section">
                <div class="user-info" id="userInfo" style="display: none;">
                    Welcome, <span id="userName"></span>!
                </div>
                <button class="auth-button" id="authButton">
                    <img class="google-icon" src="https://developers.google.com/identity/images/g-logo.png" alt="Google logo">
                    Sign in with Google
                </button>
            </div>
            
            <h1>üé§ Harry Mack Community Hub</h1>
            <p>Rate each segment and crowdsource words with the global Harry Mack fan community!</p>
            <p style="font-size: 0.9rem; margin-top: 10px; opacity: 0.8;">
                ‚ú® Rate individual segments ‚Ä¢ Add missing words ‚Ä¢ Vote on word accuracy ‚ú®
            </p>
        </div>

        <div class="filter-section">
            <div class="filter-controls">
                <label>Sort by:</label>
                <select id="sortFilter">
                    <option value="episode">Episode Number</option>
                    <option value="overall">Overall Rating</option>
                    <option value="lyrics">Lyrics Rating</option>
                    <option value="beats">Beats Rating</option>
                    <option value="reaction">Reaction Rating</option>
                </select>
                
                <label>Min Rating:</label>
                <select id="ratingFilter">
                    <option value="0">All Videos</option>
                    <option value="3">3+ Stars</option>
                    <option value="4">4+ Stars</option>
                    <option value="5">5 Stars Only</option>
                </select>

                <input type="text" id="searchFilter" placeholder="Search by words or episode...">
            </div>
        </div>

        <div id="loadingMessage" class="loading">
            Loading Harry Mack videos and community ratings...
        </div>

        <div class="video-grid" id="videoGrid" style="display: none;">
        </div>

        <div class="stats-bar" id="statsBar" style="display: none;">
            <h3 style="margin-bottom: 20px;">Global Community Stats</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-number" id="totalRatings">0</div>
                    <div class="stat-label">Total Ratings</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="avgOverall">0.0</div>
                    <div class="stat-label">Avg Overall Rating</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="activeUsers">0</div>
                    <div class="stat-label">Community Members</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="topEpisode">#--</div>
                    <div class="stat-label">Highest Rated Episode</div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-app-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-auth-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-firestore-compat.min.js"></script>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBUtq7jUntXqH0C0V2fDR1fwh2yPoZJAls",
            authDomain: "harry-mack-community.firebaseapp.com",
            projectId: "harry-mack-community",
            storageBucket: "harry-mack-community.firebasestorage.app",
            messagingSenderId: "1035009511388",
            appId: "1:1035009511388:web:23b2e932da2ac74466c919"
        };

        let app, auth, db;
        let currentUser = null;
        let isSigningIn = false;
        let videos = [];
        let userRatings = {};
        let userWordVotes = {};
        let isAddingWord = false;
		let isVotingOnWord = false;
        let realtimeUpdateTimeout = null; // Add this to debounce real-time updates
        
        // Default ratings structure
        const defaultRatings = {
            lyrics: { average: 3.0, count: 0 },
            beats: { average: 3.0, count: 0 },
            reaction: { average: 3.0, count: 0 },
            overall: { average: 3.0, count: 0 }
        };

        // Debug mode flag
        const DEBUG_EPISODE_2 = true;

        // FIXED: Better Firebase format conversion
        function convertWordsObjectToArray(wordsData) {
            console.log('üîç Converting words data:', JSON.stringify(wordsData, null, 2));
            
            if (!wordsData) {
                return [
                    [{word: 'word1', votes: 5, voters: []}],
                    [{word: 'word2', votes: 5, voters: []}],
                    [{word: 'word3', votes: 5, voters: []}]
                ];
            }
        
            // If it's already the correct format (array of arrays), return as-is
            if (Array.isArray(wordsData) && wordsData.length > 0 && Array.isArray(wordsData[0])) {
                console.log('‚úÖ Already in correct array format');
                return wordsData;
            }
        
            // Convert Firebase object format to array format
            if (Array.isArray(wordsData)) {
                console.log('üîÑ Converting from Firebase array-of-objects format');
                
                return wordsData.map((wordPosition, positionIndex) => {
                    if (typeof wordPosition === 'object' && wordPosition !== null && !Array.isArray(wordPosition)) {
                        // Convert object with numeric keys back to array
                        const candidates = [];
                        Object.keys(wordPosition).sort((a, b) => parseInt(a) - parseInt(b)).forEach(key => {
                            const candidate = wordPosition[key];
                            if (candidate && candidate.word) {
                                candidates.push({
                                    word: candidate.word,
                                    votes: candidate.votes || 1,
                                    voters: candidate.voters || []
                                });
                            }
                        });
                        return candidates.length > 0 ? candidates : [{word: `word${positionIndex + 1}`, votes: 1, voters: []}];
                    } else if (Array.isArray(wordPosition)) {
                        // Already in correct format
                        return wordPosition;
                    } else {
                        // Fallback
                        return [{word: `word${positionIndex + 1}`, votes: 1, voters: []}];
                    }
                });
            }
        
            // Fallback - create default structure
            console.log('‚ö†Ô∏è Unknown format, creating defaults');
            return [
                [{word: 'word1', votes: 5, voters: []}],
                [{word: 'word2', votes: 5, voters: []}],
                [{word: 'word3', votes: 5, voters: []}]
            ];
        }

        function sanitizeSegmentData(segment, videoId, segmentIndex) {
            console.log(`üîß Sanitizing segment data for ${videoId}-${segmentIndex}:`, segment);
            
            const sanitized = {
                id: segment?.id || `segment_${videoId}_${segmentIndex + 1}`,
                ratings: segment?.ratings || { ...defaultRatings },
                words: []
            };
        
            if (segment?.words) {
                console.log(`üîÑ Processing words for ${videoId}-${segmentIndex}`);
                try {
                    sanitized.words = convertWordsObjectToArray(segment.words);
                    console.log(`‚úÖ Words converted successfully for ${videoId}-${segmentIndex}`);
                } catch (conversionError) {
                    console.warn(`‚ö†Ô∏è Error converting words for ${videoId}-${segmentIndex}:`, conversionError);
                    sanitized.words = [
                        [{word: 'word1', votes: 5, voters: []}],
                        [{word: 'word2', votes: 5, voters: []}],
                        [{word: 'word3', votes: 5, voters: []}]
                    ];
                }
            } else {
                console.warn(`‚ö†Ô∏è No words found for ${videoId}-${segmentIndex}, creating default`);
                sanitized.words = [
                    [{word: 'word1', votes: 5, voters: []}],
                    [{word: 'word2', votes: 5, voters: []}],
                    [{word: 'word3', votes: 5, voters: []}]
                ];
            }
        
            console.log(`‚úÖ Sanitized segment for ${videoId}-${segmentIndex}:`, sanitized);
            return sanitized;
        }

        // NEW: Calculate weighted video ratings from segment ratings
        function calculateVideoOverallRating(video) {
            console.log(`üßÆ Calculating weighted video rating for Episode ${video.episodeNumber}`);
            
            if (!video.segments || video.segments.length === 0) {
                console.log('‚ö†Ô∏è No segments found, using default ratings');
                return { ...defaultRatings };
            }

            const categories = ['lyrics', 'beats', 'reaction', 'overall'];
            const videoRatings = {};

            categories.forEach(category => {
                let totalWeightedScore = 0;
                let totalRatingCount = 0;

                // Sum up weighted scores from all segments
                video.segments.forEach(segment => {
                    if (segment.ratings && segment.ratings[category]) {
                        const segmentRating = segment.ratings[category];
                        const average = segmentRating.average || 0;
                        const count = segmentRating.count || 0;
                        
                        totalWeightedScore += (average * count);
                        totalRatingCount += count;
                    }
                });

                // Calculate weighted average
                const weightedAverage = totalRatingCount > 0 ? totalWeightedScore / totalRatingCount : 0;
                
                videoRatings[category] = {
                    average: Math.max(0, Math.min(5, weightedAverage)), // Clamp between 0-5
                    count: totalRatingCount
                };

                console.log(`üìä ${category}: ${weightedAverage.toFixed(2)}‚òÖ (${totalRatingCount} total ratings)`);
            });

            return videoRatings;
        }

        // NEW: Update video rating and refresh UI
        function updateVideoRatingDisplay(video) {
            console.log(`üé® Updating video rating display for Episode ${video.episodeNumber}`);
            
            // Find the video card in the DOM
            const videoCards = document.querySelectorAll('.video-card');
            let targetCard = null;
            
            videoCards.forEach(card => {
                const starsElement = card.querySelector('[data-video]');
                if (starsElement && starsElement.dataset.video === video.episodeNumber.toString()) {
                    targetCard = card;
                }
            });

            if (!targetCard) {
                console.log('‚ö†Ô∏è Video card not found in DOM');
                return;
            }

            // Update the overall rating display
            const ratingStats = targetCard.querySelector('.overall-rating .rating-stats');
            if (ratingStats) {
                ratingStats.textContent = `${video.ratings.overall.average.toFixed(1)}‚òÖ (${video.ratings.overall.count} ratings)`;
            }

            // Update the stars display
            const starsContainer = targetCard.querySelector('.overall-rating .stars');
            if (starsContainer) {
                updateStarDisplay(starsContainer, video.ratings.overall.average, false);
            }

            console.log(`‚úÖ Updated display: ${video.ratings.overall.average.toFixed(1)}‚òÖ (${video.ratings.overall.count} ratings)`);
        }

        function generateDefaultSegments() {
            console.log('üîß Generating default segments...');
            const wordBank = ["pizza", "galaxy", "thunderstorm", "basketball", "dragon", "coffee"];
            const numSegments = 3; // Default to 3 segments
            const segments = [];
            
            for (let j = 0; j < numSegments; j++) {
                const segmentWords = [];
                
                // Generate 3 words per segment
                for (let k = 0; k < 3; k++) {
                    const candidateWords = [];
                    const baseWord = wordBank[Math.floor(Math.random() * wordBank.length)];
                    
                    candidateWords.push({
                        word: baseWord,
                        votes: Math.floor(Math.random() * 10) + 5,
                        voters: []
                    });
                    
                    segmentWords.push(candidateWords);
                }
                
                segments.push({
                    id: `default_segment_${j + 1}`,
                    words: segmentWords,
                    ratings: { ...defaultRatings }
                });
            }
            
            console.log(`‚úÖ Generated ${segments.length} default segments`);
            return segments;
        }

        async function initializeFirebase() {
            try {
                console.log('üî• Initializing Firebase...');
                app = firebase.initializeApp(firebaseConfig);
                auth = firebase.auth();
                db = firebase.firestore();
                
                console.log('‚úÖ Firebase services initialized');
                console.log('üîí Setting auth persistence...');
                
                await auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);
                console.log('‚úÖ Auth persistence set');
                
                console.log('üîÑ Checking for redirect result...');
                try {
                    const result = await auth.getRedirectResult();
                    console.log('üîÑ Redirect result:', result);
                    
                    if (result.user) {
                        console.log('üë§ User signed in via redirect:', result.user.email);
                        showNotification(`Welcome ${result.user.displayName || result.user.email}! You're now signed in.`, 'success');
                        handleAuthStateChange(result.user);
                    } else if (result.credential) {
                        console.log('üîë Got credential but no user - possible error');
                    } else {
                        console.log('‚ÑπÔ∏è No redirect result - normal page load');
                    }
                } catch (redirectError) {
                    console.error('‚ùå Redirect error:', redirectError);
                    console.error('‚ùå Error code:', redirectError.code);
                    console.error('‚ùå Error message:', redirectError.message);
                    
                    if (redirectError.code === 'auth/unauthorized-domain') {
                        showNotification('This domain is not authorized. Please add it to Firebase.', 'error');
                    } else if (redirectError.code !== 'auth/redirect-cancelled-by-user') {
                        showNotification(`Sign in failed: ${redirectError.message}`, 'error');
                    }
                }

                auth.onAuthStateChanged((user) => {
                    console.log('üîÑ Auth state changed:', user ? user.email : 'No user');
                    if (user) {
                        isSigningIn = false;
                    }
                    handleAuthStateChange(user);
                });
                
                const currentUser = auth.currentUser;
                console.log('üë§ Current user on init:', currentUser ? currentUser.email : 'None');
                
                // Test Firestore permissions
                console.log('üß™ Testing Firestore read permissions...');
                try {
                    await db.collection('videos').limit(1).get();
                    console.log('‚úÖ Firestore read permission confirmed');
                } catch (permError) {
                    console.error('‚ùå Firestore permission error:', permError);
                    throw permError;
                }
                
                console.log('üìä Starting to load videos data...');
                loadVideosData();
                updateConnectionStatus('connected');
                
            } catch (error) {
                console.error('‚ùå Firebase initialization failed:', error);
                console.error('‚ùå Error details:', error.message, error.code);
                handleFirebaseError();
            }
        }

        function handleFirebaseError() {
            updateConnectionStatus('demo');
            showNotification('Running in demo mode - all features work except saving ratings!', 'info');
            initializeDemoMode();
        }

        function initializeDemoMode() {
            generateSampleVideos();
            renderVideos();
            updateStats();
            
            document.getElementById('loadingMessage').style.display = 'none';
            document.getElementById('videoGrid').style.display = 'grid';
            document.getElementById('statsBar').style.display = 'block';
        }

        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            
            statusElement.className = 'connection-status status-' + status;
            
            switch(status) {
                case 'connected':
                    statusText.textContent = 'üü¢ Live';
                    break;
                case 'disconnected':
                    statusText.textContent = 'üî¥ Offline';
                    break;
                case 'demo':
                    statusText.textContent = 'üü° Demo Mode';
                    break;
                case 'connecting':
                    statusText.textContent = 'üü° Connecting...';
                    break;
            }
        }

        function handleAuthStateChange(user) {
            currentUser = user;
            
            const userInfo = document.getElementById('userInfo');
            const userName = document.getElementById('userName');
            const authButton = document.getElementById('authButton');

            if (user) {
                userInfo.style.display = 'block';
                userName.textContent = user.displayName || user.email;
                authButton.innerHTML = 'Sign Out';
                authButton.onclick = signOut;
                
                loadUserRatings();
                loadUserWordVotes();
                
            } else {
                userInfo.style.display = 'none';
                authButton.innerHTML = '<img class="google-icon" src="https://developers.google.com/identity/images/g-logo.png" alt="Google logo">Sign in with Google';
                authButton.onclick = signIn;
                userRatings = {};
                userWordVotes = {};
            }
        }

        async function signIn() {
            if (!auth) {
                showNotification('Authentication not available in demo mode', 'info');
                return;
            }
            
            if (isSigningIn) {
                console.log('Sign-in already in progress');
                return;
            }
            
            console.log('Sign in button clicked');
            console.log('Current URL:', window.location.href);
            console.log('Auth domain:', firebaseConfig.authDomain);
            
            const provider = new firebase.auth.GoogleAuthProvider();
            provider.addScope('profile');
            provider.addScope('email');
            
            try {
                isSigningIn = true;
                console.log('Starting popup sign in...');
                showNotification('Opening Google sign-in popup...', 'info');
                
                const result = await auth.signInWithPopup(provider);
                
                console.log('Sign in successful:', result.user);
                showNotification('Successfully signed in!', 'success');
                
            } catch (error) {
                console.error('Sign in error:', error);
                
                if (error.code === 'auth/operation-not-allowed') {
                    showNotification('Google sign-in is not enabled in Firebase Console', 'error');
                } else if (error.code === 'auth/unauthorized-domain') {
                    showNotification('This domain is not authorized in Firebase', 'error');
                } else if (error.code === 'auth/popup-closed-by-user') {
                    showNotification('Sign-in popup was closed. Please try again.', 'info');
                } else if (error.code === 'auth/popup-blocked') {
                    showNotification('Sign-in popup was blocked by browser. Please allow popups and try again.', 'error');
                } else if (error.code === 'auth/cancelled-popup-request') {
                    showNotification('Another sign-in popup is already open. Please complete that first.', 'info');
                } else {
                    showNotification(`Sign in failed: ${error.message}`, 'error');
                }
            } finally {
                isSigningIn = false;
            }
        }

        async function signOut() {
            if (auth) {
                try {
                    await auth.signOut();
                    showNotification('You have been signed out.', 'info');
                } catch (error) {
                    console.error('Sign out error:', error);
                    showNotification('Error signing out. Please try again.', 'error');
                }
            }
        }

        async function loadVideosData() {
            try {
                if (!db) {
                    console.log('No database connection - using demo mode');
                    initializeDemoMode();
                    return;
                }

                console.log('‚úÖ Database connected, loading videos from Firebase...');
                console.log('üìä Querying videos collection...');
                
                const videosSnapshot = await db.collection('videos').orderBy('episodeNumber').get();
                console.log('üìã Query completed. Documents found:', videosSnapshot.size);
                
                if (videosSnapshot.empty) {
                    console.log('üìù No videos found - initializing sample data...');
                    await initializeFirebaseData();
                    console.log('‚úÖ Sample data initialized successfully');
                } else {
                    console.log('üìñ Loading existing videos from Firebase...');
                    videos = [];
                    
                    videosSnapshot.docs.forEach(doc => {
                        const data = doc.data();
                        console.log(`üìÑ Processing video: Episode ${data.episodeNumber}`);
                        
                        if (data.episodeNumber === 2 && DEBUG_EPISODE_2) {
                            console.log('üîç EPISODE 2 DEBUG - Raw data:', JSON.stringify(data, null, 2));
                        }

                        let processedSegments = [];

                        if (data.episodeNumber === 2) {
                            console.log('üîß FIXING EPISODE 2 DATA - Detected incomplete structure');
                            
                            const isCorrupted = !data.segments || 
                                               Object.keys(data.segments).length < 2 || 
                                               !Object.values(data.segments).some(seg => seg.words);
                            
                            if (isCorrupted) {
                                console.log('‚ö†Ô∏è Episode 2 data is corrupted, regenerating...');
                                
                                const wordBank = ["freestyle", "microphone", "talent", "creativity", "improvise", "rhythm"];
                                const newSegments = [];
                                
                                for (let j = 0; j < 3; j++) {
                                    const segmentWords = [];
                                    
                                    for (let k = 0; k < 3; k++) {
                                        const candidateWords = [];
                                        const baseWord = wordBank[Math.floor(Math.random() * wordBank.length)];
                                        
                                        candidateWords.push({
                                            word: baseWord,
                                            votes: Math.floor(Math.random() * 10) + 5,
                                            voters: []
                                        });
                                        
                                        segmentWords.push(candidateWords);
                                    }
                                    
                                    newSegments.push({
                                        id: `segment_2_${j + 1}`,
                                        words: segmentWords,
                                        ratings: {
                                            lyrics: { average: 3.5 + Math.random(), count: 15 + Math.floor(Math.random() * 10) },
                                            beats: { average: 3.8 + Math.random(), count: 18 + Math.floor(Math.random() * 12) },
                                            reaction: { average: 3.2 + Math.random(), count: 12 + Math.floor(Math.random() * 8) },
                                            overall: { average: 3.5 + Math.random(), count: 14 + Math.floor(Math.random() * 6) }
                                        }
                                    });
                                }
                                
                                processedSegments = newSegments;
                                console.log('‚úÖ Episode 2 data regenerated with', processedSegments.length, 'segments');
                                console.log('‚ÑπÔ∏è Episode 2 fixed locally only - skipping Firebase save');
                                
                            } else {
                                const segmentValues = Object.values(data.segments);
                                processedSegments = segmentValues.map((segment, idx) => 
                                    sanitizeSegmentData(segment, data.episodeNumber, idx)
                                );
                            }
                        } else if (data.segments && Array.isArray(data.segments)) {
                            console.log(`‚úÖ Valid segments array with ${data.segments.length} items`);
                            processedSegments = data.segments.map((segment, idx) => 
                                sanitizeSegmentData(segment, data.episodeNumber, idx)
                            );
                        } else if (data.segments && typeof data.segments === 'object') {
                            console.log(`üîÑ Converting segments object to array`);
                            const segmentValues = Object.values(data.segments);
                            processedSegments = segmentValues.map((segment, idx) => 
                                sanitizeSegmentData(segment, data.episodeNumber, idx)
                            );
                        } else {
                            console.log(`‚ö†Ô∏è No valid segments found for Episode ${data.episodeNumber}`);
                            processedSegments = generateDefaultSegments();
                        }
                        
                        const processedVideo = {
                            id: doc.id,
                            episodeNumber: data.episodeNumber,
                            title: data.title || `Omegle Bars Episode #${data.episodeNumber}`,
                            youtubeId: getYouTubeId(data.episodeNumber),
                            segments: processedSegments,
                            ratings: data.ratings || { ...defaultRatings }
                        };
                        
                        // üî• NEW: Recalculate video ratings from segments (in case stored ratings are outdated)
                        if (processedSegments.length > 0) {
                            console.log(`üîÑ Recalculating video ratings for Episode ${data.episodeNumber}`);
                            processedVideo.ratings = calculateVideoOverallRating(processedVideo);
                        }
                        
                        videos.push(processedVideo);
                        console.log(`‚úÖ Processed Episode ${data.episodeNumber} with ${processedSegments.length} segments`);
                    });
                    
                    console.log(`‚úÖ Successfully loaded ${videos.length} videos`);
                }
                
                console.log('üé® Starting to render videos...');
                try {
                    renderVideos();
                    updateStats();
                    document.getElementById('loadingMessage').style.display = 'none';
                    document.getElementById('videoGrid').style.display = 'grid';
                    document.getElementById('statsBar').style.display = 'block';
                    updateConnectionStatus('connected');
                    console.log('‚úÖ Videos loaded and rendered successfully!');
                } catch (renderError) {
                    console.error('‚ùå Error during rendering (keeping loaded data):', renderError);
                    showNotification('Error rendering videos. Data loaded but display may be incomplete.', 'error');
                    
                    document.getElementById('loadingMessage').style.display = 'none';
                    document.getElementById('videoGrid').style.display = 'grid';
                    document.getElementById('statsBar').style.display = 'block';
                    updateConnectionStatus('connected');
                }
                
            } catch (error) {
                console.error('‚ùå Error loading videos:', error);
                showNotification('Error loading videos. Using demo data.', 'error');
                initializeDemoMode();
            }
        }

        async function initializeFirebaseData() {
            console.log('üöÄ Starting to generate sample videos...');
            const sampleVideos = generateSampleVideos();
            console.log(`üìä Generated ${sampleVideos.length} sample videos`);
            
            if (db) {
                try {
                    console.log('üíæ Saving sample data to Firebase...');
                    const batch = db.batch();
                    sampleVideos.forEach((video, index) => {
                        const docRef = db.collection('videos').doc(`episode_${video.episodeNumber}`);
                        batch.set(docRef, video);
                        if (index < 3) {
                            console.log(`üìÑ Preparing to save Episode ${video.episodeNumber}:`, video.title);
                        }
                    });
                    
                    console.log('‚è≥ Committing batch write to Firebase...');
                    await batch.commit();
                    console.log('‚úÖ Sample data saved to Firebase successfully!');
                } catch (batchError) {
                    console.error('‚ùå Error saving to Firebase:', batchError);
                    throw batchError;
                }
            } else {
                console.log('‚ö†Ô∏è No database connection - keeping data in memory only');
            }
            
            videos = sampleVideos;
            console.log(`‚úÖ Videos array populated with ${videos.length} items`);
        }

        function getYouTubeId(episodeNumber) {
            const youtubeIds = [
                'NPdKxsSE5JQ',  // Episode 1
                'BgCUCg9aMyA',  // Episode 2
                '37duQAUSYXo',  // Episode 3
                'jrNapeXr3TY',  // Episode 4
                'Gh7Wbix9UwY',  // Episode 5
                'dwFhTq5x0Tc',  // Episode 6
                '75j7pEjRAIQ',  // Episode 7
                'O6ve-5b_x5U',  // Episode 8
                'oxuUDgOdoRw',  // Episode 9
                '7GAuu0Ro9PM',  // Episode 10
                'Rqv6oiyddn8',  // Episode 11
                'hZcpRm80EBk',  // Episode 12
                '6c5Y47TYQWQ',  // Episode 13
                'Ap4dVD_CRm8',  // Episode 14
                'lt0r0JNDeeo',  // Episode 15
                'XTfaaoBRjvs',  // Episode 16
                'QwnqI4dyPI8',  // Episode 17
                'VBBMfHGMs7I',  // Episode 18
                'EWThDBgYj9U',  // Episode 19
                'Tf84L54lSTE',  // Episode 20
                're1sJCcYZy4',  // Episode 21
                '3Y-0TUj1amk',  // Episode 22
                'JeRZWJ7NMGU',  // Episode 23
                'ZC6kl6ohAjo',  // Episode 24
                '1kN6LAf_7eg',  // Episode 25
                'U6dbmuCfdyk',  // Episode 26
                'dlnQOB15Sq8',  // Episode 27
                'ZOhE4fUduUU',  // Episode 28
                '2JHSSISCVww',  // Episode 29
                'vtjdWxFcOc4',  // Episode 30
                'fP4SftKI4LQ',  // Episode 31
                'Z3FjhBuFKyM',  // Episode 32
                'p-GYLYqpTP8',  // Episode 33
                'PPS8RLQkw04',  // Episode 34
                'YPLX5YpSMfI',  // Episode 35
                'QaD5-e6hjmY',  // Episode 36
                '1XZJKKNopEw',  // Episode 37
                'eStSbs0PklY',  // Episode 38
                'dkcnYy_VjRc',  // Episode 39
                '4dMm3q1rldE',  // Episode 40
                '25ceuw4CuK8',  // Episode 41
                'wy6qazFc2FQ',  // Episode 42
                'oXI3ysg3s3s',  // Episode 43
                'UlIzq76NZJA',  // Episode 44
                'OBM1UVnsQQo',  // Episode 45
                'KSc0UuBLRhg',  // Episode 46
                'n1K9P5Dtph4',  // Episode 47
                '5yTm4j6KaBQ',  // Episode 48
                '1dfh0G8Ik1c',  // Episode 49
                '-pRhkKkM2Ms',  // Episode 50
                'mwWw-1t3hyw',  // Episode 51
                '3ZhcM7-bh4c',  // Episode 52
                'Js2Q8tJLgig',  // Episode 53
                'eX9uZQoXAdY',  // Episode 54
                'AYc7Q6CSeGE',  // Episode 55
                'Djm0fwEX9ls',  // Episode 56
                'UI2qbARbQEw',  // Episode 57
                'sfFpAz8ZHVg',  // Episode 58
                'CKnUOb6My5Y',  // Episode 59
                'BbcTwW_aKxI',  // Episode 60
                'I0ng6LIjAOg',  // Episode 61
                'g25N4i6leas',  // Episode 62
                'abuAR-yoWSU',  // Episode 63
                'izM7RQctoPc',  // Episode 64
                'BNC68gQluSE',  // Episode 65
                'TJk3eDFwiaY',  // Episode 66
                'FxLKfWt3Kq4',  // Episode 67
                'QaRkdWCTKkM',  // Episode 68
                'O9AxmMO9xKw',  // Episode 69
                'AO0yvg0pLiM',  // Episode 70
                'qQKgwgWzg58',  // Episode 71
                'xqCEjV48TWA',  // Episode 72
                'SnJpkJ0or5o',  // Episode 73
                '2kfaZHwzda8',  // Episode 74
                '4yeyJVkbX8Y',  // Episode 75
                'Xm8Z4bGH_Ok',  // Episode 76
                'yxb2mb4wkF4',  // Episode 77
                'NKtwLntS4Pg',  // Episode 78
                'MiU7GJYeTas',  // Episode 79
                'TwRATtm76cI',  // Episode 80
                'bt0DLDPVE1M',  // Episode 81
                '6Phbw1vg5Wc',  // Episode 82
                '16xwgMHig-A',  // Episode 83
                'REllMQ6EQi8',  // Episode 84
                '6mfIBMQMYTw',  // Episode 85
                'gBgJRYcIcWA',  // Episode 86
                'WG0ZmvMYVrM',  // Episode 87
                'cXKJ3uv_XIk',  // Episode 88
                '_SZbXNGBWGk',  // Episode 89 
                'uhiwj4ho4V4',  // Episode 90
                'qG37EIdryFo',  // Episode 91
                'hr6sqlk73AI',  // Episode 92
                'rjBtpTI0MAc',  // Episode 93
                'bJgAtUirT7I',  // Episode 94
                '1suTTTUn7iA',  // Episode 95
                'TFaKz7SQsgg',  // Episode 96
                'qlfHCE9nl34',  // Episode 97
                'vL4W6n--r5A',  // Episode 98
                '-70WqAfeEYE',  // Episode 99
                'ijVGIcVRIbk',  // Episode 100
                '6sYh6iuMUA8',  // Episode 101
                'elpFOcnxTZY',  // Episode 102
                'sfAjqVYDISQ',  // Episode 103
                'BXFq6Y1iW7k',  // Episode 104
                'E6dqj45rjlE',  // Episode 105
                '2bMkeJ6Vu2s',  // Episode 106
                'HuCyL-QEIhQ',  // Episode 107
                '6u8Yt12uZnk',  // Episode 108
                'dfAQMcKqxM0',  // Episode 109
                'jSZmrM-1qpw'   // Episode 110
            ];
            
            const index = episodeNumber - 1;
            
            if (index >= 0 && index < youtubeIds.length) {
                return youtubeIds[index];
            }
            
            return youtubeIds[index % youtubeIds.length];
        }
        
        function generateSampleVideos() {
            const wordBank = [
                "pizza", "galaxy", "thunderstorm", "basketball", "dragon", "coffee",
                "telephone", "rainbow", "adventure", "elephant", "computer", "sunshine",
                "bicycle", "ocean", "chocolate", "butterfly", "mountain", "music",
                "spaceship", "burger", "lightning", "guitar", "forest", "diamond",
                "robot", "sunset", "library", "airplane", "wizard", "sandwich",
                "telescope", "volcano", "penguin", "keyboard", "tornado", "ice cream"
            ];

            const sampleVideos = [];
            
            for (let i = 1; i <= 100; i++) {
                const segments = [];
                const numSegments = Math.random() < 0.8 ? 3 : (Math.random() < 0.5 ? 2 : 4);
                
                for (let j = 0; j < numSegments; j++) {
                    const numWords = Math.random() < 0.7 ? 3 : (Math.random() < 0.5 ? 2 : 4);
                    const segmentWords = [];
                    
                    for (let k = 0; k < numWords; k++) {
                        const candidateWords = [];
                        
                        const baseWordIndex = Math.floor(Math.random() * wordBank.length);
                        const baseWord = wordBank[baseWordIndex];
                        
                        candidateWords.push({
                            word: baseWord,
                            votes: Math.floor(Math.random() * 15) + 10,
                            voters: []
                        });
                        
                        const numAlternatives = Math.random() < 0.4 ? 1 : (Math.random() < 0.2 ? 2 : 0);
                        
                        for (let alt = 0; alt < numAlternatives; alt++) {
                            let altWordIndex;
                            let altWord;
                            
                            do {
                                altWordIndex = Math.floor(Math.random() * wordBank.length);
                                altWord = wordBank[altWordIndex];
                            } while (altWord === baseWord);
                            
                            const wordExists = candidateWords.some(candidate => candidate.word === altWord);
                            if (!wordExists) {
                                candidateWords.push({
                                    word: altWord,
                                    votes: Math.floor(Math.random() * 5) + 1,
                                    voters: []
                                });
                            }
                        }
                        
                        segmentWords.push(candidateWords);
                    }
                    
                    const lyrics = Math.random() * 2 + 3;
                    const beats = Math.random() * 2 + 3;
                    const reaction = Math.random() * 2 + 3;
                    const overall = (lyrics + beats + reaction) / 3 + (Math.random() * 0.6 - 0.3);
                    
                    const baseRatingCount = Math.floor(Math.random() * 50) + 5;
                    
                    segments.push({
                        id: `segment_${i}_${j + 1}`,
                        words: segmentWords,
                        ratings: {
                            lyrics: { 
                                average: Math.max(1, Math.min(5, lyrics)),
                                count: baseRatingCount + Math.floor(Math.random() * 10) 
                            },
                            beats: { 
                                average: Math.max(1, Math.min(5, beats)), 
                                count: baseRatingCount + Math.floor(Math.random() * 12) 
                            },
                            reaction: { 
                                average: Math.max(1, Math.min(5, reaction)), 
                                count: baseRatingCount + Math.floor(Math.random() * 15) 
                            },
                            overall: { 
                                average: Math.max(1, Math.min(5, overall)), 
                                count: baseRatingCount + Math.floor(Math.random() * 8) 
                            }
                        }
                    });
                }

                const videoLyrics = segments.reduce((sum, seg) => sum + seg.ratings.lyrics.average, 0) / segments.length;
                const videoBeats = segments.reduce((sum, seg) => sum + seg.ratings.beats.average, 0) / segments.length;
                const videoReaction = segments.reduce((sum, seg) => sum + seg.ratings.reaction.average, 0) / segments.length;
                const videoOverall = segments.reduce((sum, seg) => sum + seg.ratings.overall.average, 0) / segments.length;
                
                const totalSegmentRatings = segments.reduce((sum, seg) => 
                    sum + seg.ratings.lyrics.count + seg.ratings.beats.count + seg.ratings.reaction.count + seg.ratings.overall.count, 0);

                const video = {
                    episodeNumber: i,
                    title: `Omegle Bars Episode #${i}`,
                    youtubeId: getYouTubeId(i),
                    segments: segments,
                    ratings: {
                        lyrics: { 
                            average: videoLyrics,
                            count: Math.floor(totalSegmentRatings * 0.25) 
                        },
                        beats: { 
                            average: videoBeats, 
                            count: Math.floor(totalSegmentRatings * 0.25) 
                        },
                        reaction: { 
                            average: videoReaction, 
                            count: Math.floor(totalSegmentRatings * 0.25) 
                        },
                        overall: { 
                            average: videoOverall, 
                            count: Math.floor(totalSegmentRatings * 0.25) 
                        }
                    }
                };

                sampleVideos.push(video);
            }
            
            videos = sampleVideos;
            return sampleVideos;
        }

        async function loadUserRatings() {
            if (!currentUser || !db) return;

            try {
                const ratingsSnapshot = await db.collection('userRatings')
                    .where('userId', '==', currentUser.uid)
                    .get();
                
                userRatings = {};
                
                ratingsSnapshot.docs.forEach(doc => {
                    const data = doc.data();
                    if (data.segmentId) {
                        if (!userRatings[data.videoId]) {
                            userRatings[data.videoId] = { segments: {} };
                        }
                        userRatings[data.videoId].segments[data.segmentId] = data.ratings;
                    } else {
                        if (!userRatings[data.videoId]) {
                            userRatings[data.videoId] = {};
                        }
                        userRatings[data.videoId].video = data.ratings;
                    }
                });
                
                updateUserRatingDisplay();
                
            } catch (error) {
                console.error('Error loading user ratings:', error);
            }
        }

        async function loadUserWordVotes() {
            if (!currentUser || !db) return;

            try {
                const votesSnapshot = await db.collection('userWordVotes')
                    .where('userId', '==', currentUser.uid)
                    .get();
                
                userWordVotes = {};
                
                votesSnapshot.docs.forEach(doc => {
                    const data = doc.data();
                    const key = `${data.videoId}_${data.segmentId}_${data.wordIndex}_${data.word}`;
                    userWordVotes[key] = data.voteType;
                });
                
            } catch (error) {
                console.error('Error loading user word votes:', error);
            }
        }
         

        function updateUserRatingDisplay() {
            setTimeout(() => {
                Object.keys(userRatings).forEach(videoId => {
                    if (userRatings[videoId].segments) {
                        Object.keys(userRatings[videoId].segments).forEach(segmentId => {
                            const segmentRatings = userRatings[videoId].segments[segmentId];
                            const categories = ['lyrics', 'beats', 'reaction', 'overall'];
                            
                            categories.forEach(category => {
                                const rating = segmentRatings[category];
                                if (rating > 0) {
                                    const starsContainer = document.querySelector(`[data-video="${videoId}"][data-segment="${segmentId}"][data-category="${category}"]`)?.closest('.stars');
                                    if (starsContainer) {
                                        updateStarDisplay(starsContainer, rating, true);
                                        
                                        const controls = starsContainer.closest('.rating-controls');
                                        if (controls && !controls.querySelector('.user-rating-indicator')) {
                                            const indicator = document.createElement('div');
                                            indicator.className = 'user-rating-indicator';
                                            indicator.textContent = `Your rating: ${rating}‚òÖ`;
                                            controls.appendChild(indicator);
                                        }
                                    }
                                }
                            });
                        });
                    }
                    
                    if (userRatings[videoId].video) {
                        const videoRatings = userRatings[videoId].video;
                        const categories = ['lyrics', 'beats', 'reaction', 'overall'];
                        
                        categories.forEach(category => {
                            const rating = videoRatings[category];
                            if (rating > 0) {
                                const starsContainer = document.querySelector(`[data-video="${videoId}"][data-category="${category}"]:not([data-segment])`)?.closest('.stars');
                                if (starsContainer) {
                                    updateStarDisplay(starsContainer, rating, true);
                                    
                                    const controls = starsContainer.closest('.rating-controls');
                                    if (controls && !controls.querySelector('.user-rating-indicator')) {
                                        const indicator = document.createElement('div');
                                        indicator.className = 'user-rating-indicator';
                                        indicator.textContent = `Your rating: ${rating}‚òÖ`;
                                        controls.appendChild(indicator);
                                    }
                                }
                            }
                        });
                    }
                });
            }, 100);
        }

        async function submitRating(videoId, category, rating, segmentId = null) {
            try {
                if (!userRatings[videoId]) {
                    userRatings[videoId] = { segments: {} };
                }
                
                if (segmentId) {
                    if (!userRatings[videoId].segments[segmentId]) {
                        userRatings[videoId].segments[segmentId] = { lyrics: 0, beats: 0, reaction: 0, overall: 0 };
                    }
                    userRatings[videoId].segments[segmentId][category] = rating;
                } else {
                    if (!userRatings[videoId].video) {
                        userRatings[videoId].video = { lyrics: 0, beats: 0, reaction: 0, overall: 0 };
                    }
                    userRatings[videoId].video[category] = rating;
                }

                if (db) {
                    const docId = segmentId ? 
                        `${currentUser.uid}_${videoId}_${segmentId}` : 
                        `${currentUser.uid}_${videoId}`;
                    
                    const ratingsData = {
                        userId: currentUser.uid,
                        videoId: videoId,
                        ratings: segmentId ? userRatings[videoId].segments[segmentId] : userRatings[videoId].video,
                        lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                    };
                    
                    if (segmentId) {
                        ratingsData.segmentId = segmentId;
                    }

                    await db.collection('userRatings').doc(docId).set(ratingsData);
                    await updateVideoRating(videoId, category, rating, segmentId);
                }

                const segmentText = segmentId ? ` (Segment ${segmentId})` : '';
                showNotification(`Rated ${category}${segmentText}: ${rating} stars! Video rating automatically updated.`, 'success');
                
            } catch (error) {
                console.error('Error submitting rating:', error);
                showNotification('Failed to save rating. Please try again.', 'error');
            }
        }

        async function updateVideoRating(videoId, category, newRating, segmentId = null) {
            if (!db) return;

            try {
                const docId = segmentId ? `${videoId}_${segmentId}_${category}` : `${videoId}_${category}`;
                const ratingsRef = db.collection(segmentId ? 'segmentRatings' : 'ratings').doc(docId);
                
                await db.runTransaction(async (transaction) => {
                    const ratingsDoc = await transaction.get(ratingsRef);
                    
                    let totalRating = newRating;
                    let count = 1;
                    
                    if (ratingsDoc.exists) {
                        const data = ratingsDoc.data();
                        totalRating = data.totalRating + newRating;
                        count = data.count + 1;
                    }
                    
                    const average = totalRating / count;
                    
                    transaction.set(ratingsRef, {
                        totalRating: totalRating,
                        count: count,
                        average: average,
                        videoId: videoId,
                        category: category
                    });
                    
                    if (segmentId) {
                        transaction.set(ratingsRef, {
                            ...ratingsRef.data,
                            segmentId: segmentId
                        });
                    }
                    
                    const videoRef = db.collection('videos').doc(`episode_${videoId}`);
                    if (segmentId) {
                        transaction.update(videoRef, {
                            [`segments.${segmentId}.ratings.${category}.average`]: average,
                            [`segments.${segmentId}.ratings.${category}.count`]: count
                        });
                    } else {
                        transaction.update(videoRef, {
                            [`ratings.${category}.average`]: average,
                            [`ratings.${category}.count`]: count
                        });
                    }
                });
                
                // Update local data and recalculate video ratings
                const video = videos.find(v => v.episodeNumber.toString() === videoId);
                if (video) {
                    if (segmentId) {
                        const segment = video.segments.find(s => s.id === segmentId);
                        if (segment && segment.ratings) {
                            const currentData = segment.ratings[category];
                            const newTotal = (currentData.average * currentData.count) + newRating;
                            const newCount = currentData.count + 1;
                            segment.ratings[category] = { average: newTotal / newCount, count: newCount };
                            
                            // üî• NEW: Recalculate video overall rating from segments
                            console.log('üîÑ Recalculating video rating after segment update...');
                            video.ratings = calculateVideoOverallRating(video);
                            
                            // Update only the video rating display (no full re-render)
                            updateVideoRatingDisplay(video);
                            updateStats();
                            
                            console.log(`‚úÖ Video rating updated: ${video.ratings.overall.average.toFixed(1)}‚òÖ`);
                        }
                    } else {
                        const currentData = video.ratings[category];
                        const newTotal = (currentData.average * currentData.count) + newRating;
                        const newCount = currentData.count + 1;
                        video.ratings[category] = { average: newTotal / newCount, count: newCount };
                        
                        // Update display for video-level ratings (legacy)
                        updateVideoRatingDisplay(video);
                        updateStats();
                    }
                }
            } catch (error) {
                console.error('Error updating rating:', error);
            }
        }



	   
	   
	   // FIXED: voteOnWord function - NO renderVideos() call
		async function voteOnWord(videoId, segmentId, wordIndex, word, voteType) {
			if (!currentUser) {
				showSignInPrompt('word voting', 0);
				return;
			}
			try {
				const voteKey = `${videoId}_${segmentId}_${wordIndex}_${word}`;
				const currentVote = userWordVotes[voteKey];

				let newVoteType = null;
				if (currentVote === voteType) {
					newVoteType = null;
				} else {
					newVoteType = voteType;
				}
				userWordVotes[voteKey] = newVoteType;

				if (db) {
					const voteDocId = `${currentUser.uid}_${voteKey}`;
					if (newVoteType) {
						await db.collection('userWordVotes').doc(voteDocId).set({
							userId: currentUser.uid,
							videoId: videoId,
							segmentId: segmentId,
							wordIndex: wordIndex,
							word: word,
							voteType: newVoteType,
							timestamp: firebase.firestore.FieldValue.serverTimestamp()
						});
					} else {
						await db.collection('userWordVotes').doc(voteDocId).delete();
					}

					await updateWordVotes(videoId, segmentId, wordIndex, word, currentVote, newVoteType);
				}

				// ONLY update the specific word - NO renderVideos()!
				updateSingleWordInDOM(videoId, segmentId, wordIndex, word, newVoteType);

				showNotification(`${newVoteType ? (newVoteType === 'up' ? 'Upvoted' : 'Downvoted') : 'Removed vote on'} word: ${word}`, 'success');
				
			} catch (error) {
				console.error('Error voting on word:', error);
				showNotification('Failed to save vote. Please try again.', 'error');
			}
		}
	   
	   

        async function updateWordVotes(videoId, segmentId, wordIndex, word, oldVote, newVote) {
            if (!db) return;

            try {
                const video = videos.find(v => v.episodeNumber.toString() === videoId);
                if (!video) return;

                const segment = video.segments.find(s => s.id === segmentId);
                if (!segment || !segment.words[wordIndex]) return;

                const wordCandidate = segment.words[wordIndex].find(w => w.word === word);
                if (!wordCandidate) return;

                if (oldVote === 'up') wordCandidate.votes--;
                if (oldVote === 'down') wordCandidate.votes++;
                if (newVote === 'up') wordCandidate.votes++;
                if (newVote === 'down') wordCandidate.votes--;

                wordCandidate.votes = Math.max(0, wordCandidate.votes);

                const videoRef = db.collection('videos').doc(`episode_${videoId}`);
                await videoRef.update({
                    [`segments`]: video.segments
                });

            } catch (error) {
                console.error('Error updating word votes:', error);
            }
        }

        // FIXED: Improved addNewWord function - no more collapsing!
        async function addNewWord(videoId, segmentId, wordIndex, newWord) {
            console.log('üîç Adding word:', { videoId, segmentId, wordIndex, newWord });
            
            // Check if already adding a word
            if (isAddingWord) {
                console.log('‚ùå Already adding a word, please wait');
                showNotification('Please wait, another word is being added...', 'info');
                return;
            }

            // Set flag to prevent issues
            isAddingWord = true;
            
            try {
                // Validate user and input
                if (!currentUser) {
                    showSignInPrompt('add words', 0);
                    return;
                }

                if (!newWord || !newWord.trim()) {
                    showNotification('Please enter a word', 'error');
                    return;
                }

                const trimmedWord = newWord.trim();
                console.log('‚úÖ User authenticated, word validated:', trimmedWord);

                // Find video and segment
                const video = videos.find(v => v.episodeNumber.toString() === videoId);
                if (!video) {
                    showNotification('Video not found', 'error');
                    return;
                }

                const segment = video.segments.find(s => s.id === segmentId);
                if (!segment || !segment.words || !segment.words[wordIndex]) {
                    showNotification('Invalid word position', 'error');
                    return;
                }

                // Check if word already exists
                const existingWord = segment.words[wordIndex].find(w => 
                    w && w.word && w.word.toLowerCase() === trimmedWord.toLowerCase()
                );

                if (existingWord) {
                    showNotification('This word already exists for this position', 'info');
                    return;
                }

                // Add word locally FIRST
                const newWordObj = {
                    word: trimmedWord,
                    votes: 1,
                    voters: [currentUser.uid]
                };
                
                // Add to the actual segment data
                segment.words[wordIndex].push(newWordObj);
                console.log('‚úÖ Word added to local data');

                // Save user vote locally
                const voteKey = `${videoId}_${segmentId}_${wordIndex}_${trimmedWord}`;
                userWordVotes[voteKey] = 'up';

                // Update ONLY the specific word list in the DOM - no re-rendering!
                updateWordListInDOM(videoId, segmentId, wordIndex, segment.words[wordIndex]);

                // Save to Firebase in background
                if (db) {
                    console.log('üíæ Saving to Firebase...');
                    
                    // Convert to Firebase format
                    const segmentsForFirebase = video.segments.map(seg => ({
                        id: seg.id,
                        ratings: { ...seg.ratings },
                        words: seg.words.map(wordCandidates => {
                            const wordObj = {};
                            wordCandidates.forEach((candidate, index) => {
                                if (candidate && candidate.word) {
                                    wordObj[index.toString()] = {
                                        word: candidate.word,
                                        votes: candidate.votes || 1,
                                        voters: candidate.voters || []
                                    };
                                }
                            });
                            return wordObj;
                        })
                    }));

                    const videoRef = db.collection('videos').doc(`episode_${videoId}`);
                    await videoRef.update({ segments: segmentsForFirebase });
                    console.log('‚úÖ Firebase update successful!');

                    // Save user vote to Firebase
                    const voteDocId = `${currentUser.uid}_${voteKey}`;
                    await db.collection('userWordVotes').doc(voteDocId).set({
                        userId: currentUser.uid,
                        videoId: videoId,
                        segmentId: segmentId,
                        wordIndex: parseInt(wordIndex),
                        word: trimmedWord,
                        voteType: 'up',
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    console.log('‚úÖ Vote record saved');
                }

                showNotification(`Added new word: ${trimmedWord}`, 'success');
                console.log('‚úÖ Word addition completed successfully - no re-render needed!');

            } catch (error) {
                console.error('‚ùå Error adding word:', error);
                showNotification('Failed to add word. Please try again.', 'error');
            } finally {
                // Reset flag after a delay to prevent rapid re-triggering
                setTimeout(() => {
                    isAddingWord = false;
                    console.log('üîÑ Word addition flag reset');
                }, 1000); // Reduced timeout since no re-render
            }
        }

        // NEW: Function to update just one word list without re-rendering everything
        function updateWordListInDOM(videoId, segmentId, wordIndex, wordCandidates) {
            console.log('üéØ Updating word list in DOM for:', videoId, segmentId, wordIndex);
            
            // Find the specific word list element
            const segmentElement = document.querySelector(
                `.segments-container[data-video="${videoId}"] .segment[data-segment="${segmentId}"]`
            );

            if (!segmentElement) {
                console.warn('‚ö†Ô∏è Segment element not found');
                return;
            }

            const wordListElements = segmentElement.querySelectorAll('.word-list');
            if (!wordListElements[wordIndex]) {
                console.warn('‚ö†Ô∏è Word list element not found for index:', wordIndex);
                return;
            }

            // Update just this word list
            const targetWordList = wordListElements[wordIndex];
            targetWordList.innerHTML = createWordCandidatesHtml(wordCandidates, videoId, segmentId, wordIndex);
            
            console.log('‚úÖ Word list updated in DOM without collapsing!');
        }



		// NEW: Function to update just one word's vote count and buttons without re-rendering
		function updateSingleWordInDOM(videoId, segmentId, wordIndex, word, userVote) {
			console.log('üéØ Updating single word in DOM:', videoId, segmentId, wordIndex, word);
			
			// Find the specific word element
			const segmentElement = document.querySelector(
				`.segments-container[data-video="${videoId}"] .segment[data-segment="${segmentId}"]`
			);

			if (!segmentElement) {
				console.warn('‚ö†Ô∏è Segment element not found');
				return;
			}

			const wordListElements = segmentElement.querySelectorAll('.word-list');
			if (!wordListElements[wordIndex]) {
				console.warn('‚ö†Ô∏è Word list element not found for index:', wordIndex);
				return;
			}

			// Find the specific word item within this word list
			const wordList = wordListElements[wordIndex];
			const wordItems = wordList.querySelectorAll('.word-item');
			
			let targetWordItem = null;
			wordItems.forEach(item => {
				const wordSpan = item.querySelector('span:first-child');
				if (wordSpan && wordSpan.textContent === word) {
					targetWordItem = item;
				}
			});

			if (!targetWordItem) {
				console.warn('‚ö†Ô∏è Specific word item not found:', word);
				return;
			}

			// Update the vote count from local data
			const video = videos.find(v => v.episodeNumber.toString() === videoId);
			if (video && video.segments) {
				const segment = video.segments.find(s => s.id === segmentId);
				if (segment && segment.words[wordIndex]) {
					const wordCandidate = segment.words[wordIndex].find(w => w.word === word);
					if (wordCandidate) {
						// Update vote count display
						const votesSpan = targetWordItem.querySelector('.word-votes');
						if (votesSpan) {
							votesSpan.textContent = wordCandidate.votes;
						}

						// Update vote button states
						const upButton = targetWordItem.querySelector('.vote-btn:first-of-type');
						const downButton = targetWordItem.querySelector('.vote-btn:last-of-type');
						
						if (upButton && downButton) {
							// Reset button states
							upButton.classList.remove('voted');
							downButton.classList.remove('voted');
							
							// Set current vote state
							if (userVote === 'up') {
								upButton.classList.add('voted');
							} else if (userVote === 'down') {
								downButton.classList.add('voted');
							}
						}
					}
				}
			}
			
			console.log('‚úÖ Single word updated in DOM without collapsing!');
		}





		
		// FIXED: createStarRating function - ensures only 5 stars
		function createStarRating(category, videoId, currentRating, ratingCount, segmentId = null) {
			let starsHtml = '';
			const ratingKey = segmentId ? 
				(userRatings[videoId]?.segments?.[segmentId]?.[category] || 0) : 
				(userRatings[videoId]?.video?.[category] || 0);

			// Create exactly 5 stars, no more
			for (let i = 1; i <= 5; i++) {
				const activeClass = i <= Math.round(currentRating) ? 'active' : '';
				const userRatedClass = ratingKey > 0 && i <= ratingKey ? 'user-rated' : '';
				
				const dataAttrs = segmentId ? 
					`data-rating="${i}" data-category="${category}" data-video="${videoId}" data-segment="${segmentId}"` : 
					`data-rating="${i}" data-category="${category}" data-video="${videoId}"`;
					
				starsHtml += `<span class="star ${activeClass} ${userRatedClass}" ${dataAttrs}>‚òÖ</span>`;
			}
			
			return starsHtml;
		}
				
				
		

        function createWordCandidatesHtml(wordCandidates, videoId, segmentId, wordIndex) {
            console.log(`üîç Processing word candidates for ${videoId}-${segmentId}-${wordIndex}:`, wordCandidates);
            
            let validCandidates = [];
            
            if (Array.isArray(wordCandidates)) {
                validCandidates = wordCandidates.filter(candidate => 
                    candidate && 
                    candidate.word && 
                    typeof candidate.word === 'string' && 
                    candidate.word.trim() !== ''
                );
            } else {
                console.log(`‚ö†Ô∏è Unknown word candidates format, creating fallback`);
                validCandidates = [{
                    word: 'unknown',
                    votes: 1,
                    voters: []
                }];
            }
            
            const sortedCandidates = validCandidates.sort((a, b) => (b.votes || 0) - (a.votes || 0));
            
            return sortedCandidates.map(candidate => {
                const voteKey = `${videoId}_${segmentId}_${wordIndex}_${candidate.word}`;
                const userVote = userWordVotes[voteKey];
                return `
                    <div class="word-item">
                        <span>${candidate.word}</span>
                        <span class="word-votes">${candidate.votes || 0}</span>
                        <div class="vote-buttons">
                            <button class="vote-btn ${userVote === 'up' ? 'voted' : ''}" onclick="voteOnWord('${videoId}', '${segmentId}', ${wordIndex}, '${candidate.word}', 'up')">
                                ‚Üë
                            </button>
                            <button class="vote-btn ${userVote === 'down' ? 'voted' : ''}" onclick="voteOnWord('${videoId}', '${segmentId}', ${wordIndex}, '${candidate.word}', 'down')">
                                ‚Üì
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        
		// FIXED: createSegmentHtml function - fixes star duplication
		function createSegmentHtml(segment, videoId, segmentIndex) {
			console.log(`üîß Creating segment HTML for ${videoId}-${segmentIndex}:`, segment);
			
			try {
				const segmentId = segment.id || `fallback_segment_${segmentIndex}`;
				const segmentRatings = segment.ratings || defaultRatings;
				
				const avgRating = [
					segmentRatings.lyrics?.average || 0,
					segmentRatings.beats?.average || 0, 
					segmentRatings.reaction?.average || 0,
					segmentRatings.overall?.average || 0
				].reduce((sum, val) => sum + val, 0) / 4;
				
				let wordsHtml = '';
				if (segment.words && Array.isArray(segment.words)) {
					wordsHtml = segment.words.map((wordCandidates, wordIndex) => {
						try {
							return `
								<div style="margin-bottom: 15px;">
									<div class="segment-label">Word ${wordIndex + 1}</div>
									<div class="word-list">
										${createWordCandidatesHtml(wordCandidates, videoId, segmentId, wordIndex)}
									</div>
									<div class="add-word-form">
										<input type="text" class="add-word-input" placeholder="Add alternative word..." id="newWord_${videoId}_${segmentId}_${wordIndex}">
										<button class="add-word-btn" onclick="addWordFromInput('${videoId}', '${segmentId}', ${wordIndex})">
											Add
										</button>
									</div>
								</div>
							`;
						} catch (wordError) {
							console.error(`‚ùå Error processing word ${wordIndex}:`, wordError);
							return `<div class="word-error">Error loading word ${wordIndex + 1}</div>`;
						}
					}).join('');
				} else {
					console.log(`‚ö†Ô∏è No valid words array found in segment`);
					wordsHtml = '<div class="no-words">No words available</div>';
				}

				return `
					<div class="segment" data-segment="${segmentId}">
						<div class="segment-header" onclick="toggleSegment('${videoId}', '${segmentId}')">
							<div class="segment-info">
								<div class="segment-title">Segment ${String.fromCharCode(65 + segmentIndex)}</div>
								<div class="segment-rating-summary">${avgRating.toFixed(1)}‚òÖ average</div>
							</div>
							<div class="segment-expand-icon">‚ñ∂</div>
						</div>
						<div class="segment-content">
							<div class="segment-details">
								<div class="words-management">
									<h5>Crowdsourced Words (vote on accuracy)</h5>
									${wordsHtml}
								</div>
								<div class="segment-ratings">
									<h5 style="color: #2c3e50; margin-bottom: 15px; font-size: 0.85rem;">Rate This Segment</h5>
									${['lyrics', 'beats', 'reaction', 'overall'].map(category => `
										<div class="rating-category">
											<div class="rating-info">
												<span class="rating-label">${category.charAt(0).toUpperCase() + category.slice(1)}</span>
												<span class="rating-stats">${(segmentRatings[category]?.average || 0).toFixed(1)}‚òÖ (${segmentRatings[category]?.count || 0} ratings)</span>
											</div>
											<div class="rating-controls">
												<div class="stars" data-category="${category}" data-video="${videoId}" data-segment="${segmentId}">
													${createStarRating(category, videoId, segmentRatings[category]?.average || 0, segmentRatings[category]?.count || 0, segmentId)}
												</div>
												${userRatings[videoId]?.segments?.[segmentId]?.[category] ? `<div class="user-rating-indicator">Your rating: ${userRatings[videoId].segments[segmentId][category]}‚òÖ</div>` : ''}
											</div>
										</div>
									`).join('')}
								</div>
							</div>
						</div>
					</div>
				`;
				
			} catch (error) {
				console.error(`‚ùå Error in createSegmentHtml for ${videoId}-${segmentIndex}:`, error);
				return `
					<div class="segment segment-error">
						<div class="segment-header">
							<div class="segment-info">
								<div class="segment-title">Segment ${String.fromCharCode(65 + segmentIndex)} (Error)</div>
								<div class="segment-rating-summary">Unable to load</div>
							</div>
						</div>
					</div>
				`;
			}
		}
		
		
        function preserveExpandedState() {
            const expandedSegments = [];
            document.querySelectorAll('.segment.expanded').forEach(segment => {
                const videoId = segment.closest('.segments-container').dataset.video;
                const segmentId = segment.dataset.segment;
                expandedSegments.push(`${videoId}_${segmentId}`);
            });
            return expandedSegments;
        }
        
        function restoreExpandedState(expandedSegments) {
            setTimeout(() => {
                expandedSegments.forEach(segmentKey => {
                    const [videoId, segmentId] = segmentKey.split('_', 2);
                    const segmentElement = document.querySelector(
                        `.segments-container[data-video="${videoId}"] .segment[data-segment="${segmentId}"]`
                    );
                    if (segmentElement) {
                        segmentElement.classList.add('expanded');
                    }
                });
            }, 100);
        }
        
        function renderVideos() {
            console.log('üé® Starting renderVideos function...');

            const expandedSegments = preserveExpandedState();
            
            console.log(`üìä Videos to render: ${videos.length}`);
            
            const videoGrid = document.getElementById('videoGrid');
            videoGrid.innerHTML = '';

            let filteredVideos = [...videos];
            console.log(`üìã Initial video count: ${filteredVideos.length}`);

            const sortFilter = document.getElementById('sortFilter').value;
            const ratingFilter = parseFloat(document.getElementById('ratingFilter').value);
            const searchFilter = document.getElementById('searchFilter').value.toLowerCase();

            console.log(`üîç Filters - Sort: ${sortFilter}, Rating: ${ratingFilter}, Search: "${searchFilter}"`);

            if (ratingFilter > 0) {
                const beforeCount = filteredVideos.length;
                filteredVideos = filteredVideos.filter(video => video.ratings.overall.average >= ratingFilter);
                console.log(`üìä Rating filter: ${beforeCount} ‚Üí ${filteredVideos.length} videos`);
            }

            if (searchFilter) {
                const beforeCount = filteredVideos.length;
                filteredVideos = filteredVideos.filter(video => {
                    try {
                        return video.title.toLowerCase().includes(searchFilter) ||
                               video.episodeNumber.toString().includes(searchFilter) ||
                               (video.segments && video.segments.some(segment =>
                                   segment.words && segment.words.some(wordCandidates => {
                                       if (Array.isArray(wordCandidates)) {
                                           return wordCandidates.some(candidate =>
                                               candidate && candidate.word && 
                                               candidate.word.toLowerCase().includes(searchFilter)
                                           );
                                       }
                                       return false;
                                   })
                               ));
                    } catch (searchError) {
                        console.error(`‚ùå Search error for video ${video.episodeNumber}:`, searchError);
                        return true;
                    }
                });
                console.log(`üîç Search filter: ${beforeCount} ‚Üí ${filteredVideos.length} videos`);
            }

            filteredVideos.sort((a, b) => {
                if (sortFilter === 'episode') {
                    return a.episodeNumber - b.episodeNumber;
                } else {
                    return b.ratings[sortFilter].average - a.ratings[sortFilter].average;
                }
            });
            console.log(`üìä Sorted ${filteredVideos.length} videos by ${sortFilter}`);

            let successCount = 0;
            let errorCount = 0;
            
            filteredVideos.forEach((video, index) => {
                try {
                    console.log(`üé¨ Rendering video ${index + 1}/${filteredVideos.length}: Episode ${video.episodeNumber}`);
                    
                    const videoCard = document.createElement('div');
                    videoCard.className = 'video-card';
                    
                    let segmentsHtml = '';
                    if (video.segments && Array.isArray(video.segments)) {
                        console.log(`üì¶ Processing ${video.segments.length} segments for Episode ${video.episodeNumber}`);
                        try {
                            segmentsHtml = video.segments.map((segment, segIndex) => {
                                try {
                                    return createSegmentHtml(segment, video.episodeNumber, segIndex);
                                } catch (segmentError) {
                                    console.error(`‚ùå Error rendering segment ${segIndex} for Episode ${video.episodeNumber}:`, segmentError);
                                    return `<div class="segment-error">Error loading segment ${String.fromCharCode(65 + segIndex)}</div>`;
                                }
                            }).join('');
                        } catch (segmentsError) {
                            console.error(`‚ùå Error processing segments for Episode ${video.episodeNumber}:`, segmentsError);
                            segmentsHtml = '<div class="segments-error">Error loading segments</div>';
                        }
                    } else {
                        console.log(`‚ö†Ô∏è No valid segments for Episode ${video.episodeNumber}`);
                        segmentsHtml = '<div class="no-segments">No segments available</div>';
                    }
                    
                    videoCard.innerHTML = `
                        <div class="video-embed" style="position: relative; cursor: pointer; background-image: url('https://img.youtube.com/vi/${video.youtubeId}/maxresdefault.jpg'); background-size: cover; background-position: center;" onclick="window.open('https://www.youtube.com/watch?v=${video.youtubeId}', '_blank')">
                            <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center;">
                                <div style="text-align: center; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">
                                    <div style="font-size: 4rem; margin-bottom: 10px;">‚ñ∂Ô∏è</div>
                                    <div style="font-size: 1.1rem; font-weight: bold;">Episode #${video.episodeNumber}</div>
                                    <div style="font-size: 0.9rem; opacity: 0.9;">Click to watch on YouTube</div>
                                </div>
                            </div>
                        </div>
                        <div class="video-content">
                            <h3 class="video-title">${video.title}</h3>
                            <div class="overall-rating">
                                <h4>Overall Video Rating</h4>
                                <div class="rating-category">
                                    <div class="rating-info">
                                        <span class="rating-label">Overall</span>
                                        <span class="rating-stats">${video.ratings.overall.average.toFixed(1)}‚òÖ (${video.ratings.overall.count} ratings)</span>
                                    </div>
                                    <div class="rating-controls">
                                        <div class="stars" data-category="overall" data-video="${video.episodeNumber}">
                                            ${createStarRating('overall', video.episodeNumber, video.ratings.overall.average, video.ratings.overall.count)}
                                        </div>
                                        ${userRatings[video.episodeNumber]?.video?.overall ? `<div class="user-rating-indicator">Your rating: ${userRatings[video.episodeNumber].video.overall}‚òÖ</div>` : ''}
                                    </div>
                                </div>
                            </div>

                            <div class="segments-section">
                                <div class="segments-header">
                                    <h4>Segments (${video.segments ? video.segments.length : 0})</h4>
                                    <button class="expand-toggle" onclick="toggleAllSegments('${video.episodeNumber}')">Expand All</button>
                                </div>
                                <div class="segments-container" data-video="${video.episodeNumber}">
                                    ${segmentsHtml}
                                </div>
                            </div>
                        </div>
                    `;
                    videoGrid.appendChild(videoCard);
                    successCount++;
                    
                } catch (videoError) {
                    console.error(`‚ùå Error rendering video ${video.episodeNumber}:`, videoError);
                    console.error(`‚ùå Video error details:`, videoError.message);
                    errorCount++;
                    
                    const errorCard = document.createElement('div');
                    errorCard.className = 'video-card';
                    errorCard.innerHTML = `
                        <div class="video-content">
                            <h3 class="video-title">Episode #${video.episodeNumber} (Error)</h3>
                            <p>Error loading this episode. Please try refreshing.</p>
                        </div>
                    `;
                    videoGrid.appendChild(errorCard);
                }
            });

            console.log(`‚úÖ Rendering complete: ${successCount} success, ${errorCount} errors`);

            try {
                document.querySelectorAll('.star').forEach(star => {
                    star.onclick = function() {
                        const rating = parseInt(this.dataset.rating);
                        const category = this.dataset.category;
                        const videoId = this.dataset.video;
                        const segmentId = this.dataset.segment || null;
                        if (currentUser) {
                            submitRating(videoId, category, rating, segmentId);
                        } else {
                            showSignInPrompt('rate segments', 0);
                        }
                    };
                });
                console.log('‚úÖ Star rating event listeners attached');
            } catch (eventError) {
                console.error('‚ùå Error attaching event listeners:', eventError);
            }

            try {
                updateUserRatingDisplay();
                console.log('‚úÖ User rating display updated');
            } catch (displayError) {
                console.error('‚ùå Error updating user rating display:', displayError);
            }
             
            restoreExpandedState(expandedSegments);
        }

        function updateStarDisplay(starsContainer, rating, userRated = false) {
            const stars = starsContainer.querySelectorAll('.star');
            stars.forEach((star, index) => {
                star.classList.remove('active', 'user-rated');
                if (index < rating) {
                    star.classList.add('active');
                }
                if (userRated && index < rating) {
                    star.classList.add('user-rated');
                }
            });
        }

        function toggleSegment(videoId, segmentId) {
            const videoContainer = document.querySelector(`.segments-container[data-video="${videoId}"]`);
            if (videoContainer) {
                const segmentElement = videoContainer.querySelector(`.segment[data-segment="${segmentId}"]`);
                if (segmentElement) {
                    segmentElement.classList.toggle('expanded');
                }
            }
        }

        function toggleAllSegments(videoId) {
            const container = document.querySelector(`.segments-container[data-video="${videoId}"]`);
            if (container) {
                const segments = container.querySelectorAll('.segment');
                let allExpanded = true;
                segments.forEach(segment => {
                    if (!segment.classList.contains('expanded')) {
                        allExpanded = false;
                    }
                });

                segments.forEach(segment => {
                    if (allExpanded) {
                        segment.classList.remove('expanded');
                    } else {
                        segment.classList.add('expanded');
                    }
                });
                
                const button = container.closest('.video-card').querySelector('.expand-toggle');
                if (button) {
                    button.textContent = allExpanded ? 'Expand All' : 'Collapse All';
                }
            }
        }

        function addWordFromInput(videoId, segmentId, wordIndex) {
            const inputId = `newWord_${videoId}_${segmentId}_${wordIndex}`;
            const inputElement = document.getElementById(inputId);
            const newWord = inputElement.value;
            addNewWord(videoId, segmentId, wordIndex, newWord);
            inputElement.value = '';
        }

        function updateStats() {
            let totalRatings = 0;
            let totalOverallRating = 0;
            let overallRatingCount = 0;
            let maxOverallRating = 0;
            let topEpisode = '#--';

            videos.forEach(video => {
                if (video.ratings.overall.count > 0) {
                    totalOverallRating += video.ratings.overall.average * video.ratings.overall.count;
                    overallRatingCount += video.ratings.overall.count;
                }

                if (video.segments) {
                    video.segments.forEach(segment => {
                        if (segment.ratings) {
                            Object.values(segment.ratings).forEach(rating => {
                                totalRatings += rating.count;
                            });
                        }
                    });
                }
                
                if (video.ratings.overall.average > maxOverallRating) {
                    maxOverallRating = video.ratings.overall.average;
                    topEpisode = `#${video.episodeNumber}`;
                }
            });

            document.getElementById('totalRatings').textContent = totalRatings;
            document.getElementById('avgOverall').textContent = overallRatingCount > 0 ? (totalOverallRating / overallRatingCount).toFixed(1) : '0.0';
            document.getElementById('activeUsers').textContent = Object.keys(userRatings).length;
            document.getElementById('topEpisode').textContent = topEpisode;
        }
        
        function showNotification(message, type) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        function showSignInPrompt(action, delay = 0) {
            setTimeout(() => {
                showNotification(`Please sign in to ${action}.`, 'info');
            }, delay);
        }

        function init() {
            updateConnectionStatus('connecting');
            
            initializeFirebase();
            
            document.getElementById('sortFilter').addEventListener('change', applyFilters);
            document.getElementById('ratingFilter').addEventListener('change', applyFilters);
            document.getElementById('searchFilter').addEventListener('input', applyFilters);
            
            setupRealtimeUpdates();
        
            document.getElementById('authButton').addEventListener('click', () => {
                if (currentUser) {
                    signOut();
                } else {
                    signIn();
                }
            });
        }

        function applyFilters() {
            renderVideos();
        }




		// FIXED: setupRealtimeUpdates - prevent collapse during word voting
		function setupRealtimeUpdates() {
			if (!db) return;
			
			db.collection('videos').onSnapshot((snapshot) => {
				// Clear existing timeout
				if (realtimeUpdateTimeout) {
					clearTimeout(realtimeUpdateTimeout);
				}

				// IMPROVED: Only process if not currently voting on words or adding words
				if (!isAddingWord && !isVotingOnWord && snapshot.docChanges().length > 0) {
					console.log('üì° Real-time update received, processing changes...');
					
					let hasChanges = false;
					snapshot.docChanges().forEach((change) => {
						if (change.type === 'modified') {
							const updatedVideo = { id: change.doc.id, ...change.doc.data() };
							const index = videos.findIndex(v => v.episodeNumber === updatedVideo.episodeNumber);
							if (index !== -1) {
								// Process the segments to ensure correct format
								let processedSegments = [];
								if (updatedVideo.segments && Array.isArray(updatedVideo.segments)) {
									processedSegments = updatedVideo.segments.map((segment, idx) => 
										sanitizeSegmentData(segment, updatedVideo.episodeNumber, idx)
									);
								} else if (updatedVideo.segments && typeof updatedVideo.segments === 'object') {
									const segmentValues = Object.values(updatedVideo.segments);
									processedSegments = segmentValues.map((segment, idx) => 
										sanitizeSegmentData(segment, updatedVideo.episodeNumber, idx)
									);
								}
								
								videos[index] = {
									...updatedVideo,
									segments: processedSegments
								};
								hasChanges = true;
							}
						}
					});
					
					// Debounce the UI update
					if (hasChanges) {
						realtimeUpdateTimeout = setTimeout(() => {
							console.log('üîÑ Applying real-time updates to UI...');
							applyFilters();
							updateStats();
						}, 2000); // Increased delay to 2 seconds
					}
				} else if (isAddingWord || isVotingOnWord) {
					console.log('‚è∏Ô∏è Skipping real-time update - word operation in progress');
				}
			});
		}



        // Make functions globally available for onclick handlers
        window.voteOnWord = voteOnWord;
        window.addWordFromInput = addWordFromInput;
        window.toggleSegment = toggleSegment;
        window.toggleAllSegments = toggleAllSegments;
 
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>

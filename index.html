<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harry Mack Omegle Bars - Community Hub</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            color: white;
            position: relative;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .user-section {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .user-info {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .auth-button {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s ease;
        }

        .auth-button:hover {
            background: #c0392b;
        }

        .connection-status {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
            z-index: 1000;
        }

        .status-connected {
            background: #27ae60;
            color: white;
        }

        .status-disconnected {
            background: #e74c3c;
            color: white;
        }

        .status-connecting {
            background: #f39c12;
            color: white;
        }

        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
        }

        .video-card {
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .video-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
        }

        .video-embed {
            position: relative;
            width: 100%;
            height: 200px;
            background: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 14px;
        }

        .video-content {
            padding: 20px;
        }

        .video-title {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .words-section {
            margin-bottom: 20px;
        }

        .words-section h4 {
            color: #8e44ad;
            margin-bottom: 10px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .word-segments {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .word-tag {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .word-tag:hover {
            transform: scale(1.05);
        }

        .segment-label {
            font-size: 0.75rem;
            color: #7f8c8d;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .rating-section {
            border-top: 2px solid #ecf0f1;
            padding-top: 15px;
        }

        .rating-category {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .rating-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .rating-label {
            font-weight: 600;
            color: #34495e;
            font-size: 0.9rem;
        }

        .rating-stats {
            font-size: 0.75rem;
            color: #7f8c8d;
            margin-top: 2px;
        }

        .rating-controls {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
        }

        .stars {
            display: flex;
            gap: 4px;
        }

        .star {
            width: 24px;
            height: 24px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #ddd;
            user-select: none;
        }

        .star:hover,
        .star.active {
            color: #f39c12;
            transform: scale(1.1);
        }

        .star.user-rated {
            color: #e74c3c;
        }

        .user-rating-indicator {
            font-size: 0.7rem;
            color: #e74c3c;
            font-weight: bold;
        }

        .stats-bar {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            color: white;
            text-align: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .stat-item {
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .filter-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            color: white;
        }

        .filter-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-controls select,
        .filter-controls input {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            background: white;
            color: #333;
        }

        .loading {
            text-align: center;
            color: white;
            font-size: 1.2rem;
            margin: 50px 0;
        }

        .error-message {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 10px;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: slideIn 0.3s ease;
        }

        .notification.success {
            background: #27ae60;
            color: white;
        }

        .notification.error {
            background: #e74c3c;
            color: white;
        }

        .notification.info {
            background: #3498db;
            color: white;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @media (max-width: 768px) {
            .video-grid {
                grid-template-columns: 1fr;
            }
            .header h1 {
                font-size: 2rem;
            }
            .user-section {
                position: static;
                justify-content: center;
                margin-top: 15px;
            }
            .filter-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connectionStatus">
        <span id="statusText">Connecting...</span>
    </div>

    <div class="container">
        <div class="header">
            <div class="user-section">
                <div class="user-info" id="userInfo" style="display: none;">
                    Welcome, <span id="userName"></span>!
                </div>
                <button class="auth-button" id="authButton">Sign In with Google</button>
            </div>
            <h1>ðŸŽ¤ Harry Mack Community Hub</h1>
            <p>Rate and explore all 100 Omegle Bars episodes with the global Harry Mack fan community!</p>
            <p style="font-size: 0.9rem; margin-top: 10px; opacity: 0.8;">
                âœ¨ Browse and see community ratings without signing in â€¢ Sign in only when you want to vote âœ¨
            </p>
        </div>

        <div class="filter-section">
            <div class="filter-controls">
                <label>Sort by:</label>
                <select id="sortFilter">
                    <option value="episode">Episode Number</option>
                    <option value="overall">Overall Rating</option>
                    <option value="lyrics">Lyrics Rating</option>
                    <option value="beats">Beats Rating</option>
                    <option value="reaction">Reaction Rating</option>
                </select>
                
                <label>Min Rating:</label>
                <select id="ratingFilter">
                    <option value="0">All Videos</option>
                    <option value="3">3+ Stars</option>
                    <option value="4">4+ Stars</option>
                    <option value="5">5 Stars Only</option>
                </select>

                <input type="text" id="searchFilter" placeholder="Search by words or episode...">
            </div>
        </div>

        <div id="loadingMessage" class="loading">
            Loading Harry Mack videos and community ratings...
        </div>

        <div class="video-grid" id="videoGrid" style="display: none;">
            <!-- Videos will be populated by JavaScript -->
        </div>

        <div class="stats-bar" id="statsBar" style="display: none;">
            <h3 style="margin-bottom: 20px;">Global Community Stats</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-number" id="totalRatings">0</div>
                    <div class="stat-label">Total Ratings</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="avgOverall">0.0</div>
                    <div class="stat-label">Avg Overall Rating</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="activeUsers">0</div>
                    <div class="stat-label">Community Members</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="topEpisode">#--</div>
                    <div class="stat-label">Highest Rated Episode</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-app-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-auth-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-firestore-compat.min.js"></script>

    <script>
        // Firebase Configuration
        // NOTE: Replace with your actual Firebase config
    // Import the functions you need from the SDKs you need
    import { initializeApp } from "firebase/app";
    import { getAnalytics } from "firebase/analytics";
    // TODO: Add SDKs for Firebase products that you want to use
    // https://firebase.google.com/docs/web/setup#available-libraries

    // Your web app's Firebase configuration
    // For Firebase JS SDK v7.20.0 and later, measurementId is optional
    const firebaseConfig = {
        apiKey: "AIzaSyBUtq7jUntXqH0C0V2fDR1fwh2yPoZJAls",
        authDomain: "harry-mack-community.firebaseapp.com",
        projectId: "harry-mack-community",
        storageBucket: "harry-mack-community.firebasestorage.app",
        messagingSenderId: "1035009511388",
        appId: "1:1035009511388:web:23b2e932da2ac74466c919",
        measurementId: "G-LDRK7LL6CS"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const analytics = getAnalytics(app);

        // Initialize Firebase
        let app, auth, db;
        let currentUser = null;
        let videos = [];
        let userRatings = {};

        function initializeFirebase() {
            try {
                app = initializeApp(firebaseConfig);
                auth = app.auth();
                db = app.firestore();
                
                // Set up auth state listener
                auth.onAuthStateChanged(handleAuthStateChange);
                
                // Initialize the app
                loadVideosData();
                updateConnectionStatus('connected');
                
            } catch (error) {
                console.error('Firebase initialization failed:', error);
                handleFirebaseError();
            }
        }

        function handleFirebaseError() {
            updateConnectionStatus('disconnected');
            showNotification('Using demo mode - Firebase not configured. Ratings won\'t be saved.', 'error');
            initializeDemoMode();
        }

        function initializeDemoMode() {
            // Generate sample data for demo
            generateSampleVideos();
            renderVideos();
            updateStats();
            document.getElementById('loadingMessage').style.display = 'none';
            document.getElementById('videoGrid').style.display = 'grid';
            document.getElementById('statsBar').style.display = 'block';
        }

        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            
            statusElement.className = 'connection-status status-' + status;
            
            switch(status) {
                case 'connected':
                    statusText.textContent = 'ðŸŸ¢ Connected';
                    break;
                case 'disconnected':
                    statusText.textContent = 'ðŸ”´ Offline Mode';
                    break;
                case 'connecting':
                    statusText.textContent = 'ðŸŸ¡ Connecting...';
                    break;
            }
        }

        function handleAuthStateChange(user) {
            currentUser = user;
            const userInfo = document.getElementById('userInfo');
            const userName = document.getElementById('userName');
            const authButton = document.getElementById('authButton');

            if (user) {
                userInfo.style.display = 'block';
                userName.textContent = user.displayName || user.email;
                authButton.textContent = 'Sign Out';
                authButton.onclick = signOut;
                
                // Load user's existing ratings
                loadUserRatings();
                
            } else {
                userInfo.style.display = 'none';
                authButton.textContent = 'Sign In with Google';
                authButton.onclick = signIn;
                userRatings = {};
            }
        }

        function signIn() {
            if (!auth) {
                showNotification('Authentication not available in demo mode', 'info');
                return;
            }
            
            const provider = new firebase.auth.GoogleAuthProvider();
            auth.signInWithPopup(provider).catch(error => {
                console.error('Sign in error:', error);
                showNotification('Sign in failed. Please try again.', 'error');
            });
        }

        function signOut() {
            if (auth) {
                auth.signOut();
            }
        }

        async function loadVideosData() {
            if (!db) {
                generateSampleVideos();
                renderVideos();
                updateStats();
                document.getElementById('loadingMessage').style.display = 'none';
                document.getElementById('videoGrid').style.display = 'grid';
                document.getElementById('statsBar').style.display = 'block';
                return;
            }

            try {
                const videosSnapshot = await db.collection('videos').orderBy('episodeNumber').get();
                
                if (videosSnapshot.empty) {
                    // Initialize with sample data if collection is empty
                    await initializeFirebaseData();
                } else {
                    videos = videosSnapshot.docs.map(doc => ({
                        id: doc.id,
                        ...doc.data()
                    }));
                }
                
                renderVideos();
                updateStats();
                document.getElementById('loadingMessage').style.display = 'none';
                document.getElementById('videoGrid').style.display = 'grid';
                document.getElementById('statsBar').style.display = 'block';
                
            } catch (error) {
                console.error('Error loading videos:', error);
                showNotification('Error loading videos. Using demo data.', 'error');
                initializeDemoMode();
            }
        }

        async function initializeFirebaseData() {
            // This would populate Firebase with initial video data
            const sampleVideos = generateSampleVideos();
            
            const batch = db.batch();
            sampleVideos.forEach((video, index) => {
                const docRef = db.collection('videos').doc(`episode_${video.episodeNumber}`);
                batch.set(docRef, video);
            });
            
            await batch.commit();
            videos = sampleVideos;
        }

        function generateSampleVideos() {
            const wordBank = [
                "pizza", "galaxy", "thunderstorm", "basketball", "dragon", "coffee",
                "telephone", "rainbow", "adventure", "elephant", "computer", "sunshine",
                "bicycle", "ocean", "chocolate", "butterfly", "mountain", "music",
                "spaceship", "burger", "lightning", "guitar", "forest", "diamond",
                "robot", "sunset", "library", "airplane", "wizard", "sandwich",
                "telescope", "volcano", "penguin", "keyboard", "tornado", "ice cream"
            ];

            const sampleVideos = [];
            
            for (let i = 1; i <= 100; i++) {
                const segments = [];
                for (let j = 0; j < 3; j++) {
                    const segmentWords = [];
                    for (let k = 0; k < 3; k++) {
                        segmentWords.push(wordBank[Math.floor(Math.random() * wordBank.length)]);
                    }
                    segments.push({ words: segmentWords });
                }

                // Generate realistic sample ratings with some episodes having more ratings
                const baseRatingCount = Math.floor(Math.random() * 150) + 10; // 10-160 ratings per category
                const lyrics = Math.random() * 2 + 3; // 3-5 stars
                const beats = Math.random() * 2 + 3;
                const reaction = Math.random() * 2 + 3;
                const overall = (lyrics + beats + reaction) / 3 + (Math.random() * 0.6 - 0.3); // Slightly correlated

                const video = {
                    episodeNumber: i,
                    title: `Omegle Bars Episode #${i}`,
                    youtubeId: `omegle_bars_${i}`,
                    segments: segments,
                    ratings: {
                        lyrics: { 
                            average: Math.max(1, Math.min(5, lyrics)), 
                            count: baseRatingCount + Math.floor(Math.random() * 20) 
                        },
                        beats: { 
                            average: Math.max(1, Math.min(5, beats)), 
                            count: baseRatingCount + Math.floor(Math.random() * 25) 
                        },
                        reaction: { 
                            average: Math.max(1, Math.min(5, reaction)), 
                            count: baseRatingCount + Math.floor(Math.random() * 30) 
                        },
                        overall: { 
                            average: Math.max(1, Math.min(5, overall)), 
                            count: baseRatingCount + Math.floor(Math.random() * 15) 
                        }
                    }
                };

                sampleVideos.push(video);
            }
            
            videos = sampleVideos;
            return sampleVideos;
        }

        async function loadUserRatings() {
            if (!currentUser || !db) return;

            try {
                const ratingsSnapshot = await db.collection('userRatings')
                    .where('userId', '==', currentUser.uid)
                    .get();
                
                userRatings = {};
                ratingsSnapshot.docs.forEach(doc => {
                    const data = doc.data();
                    userRatings[data.videoId] = data.ratings;
                });
                
                // Update UI to show user's ratings
                updateUserRatingDisplay();
                
            } catch (error) {
                console.error('Error loading user ratings:', error);
            }
        }

        function updateUserRatingDisplay() {
            // Update star displays to show user's ratings
            Object.keys(userRatings).forEach(videoId => {
                const categories = ['lyrics', 'beats', 'reaction', 'overall'];
                categories.forEach(category => {
                    const rating = userRatings[videoId][category];
                    if (rating > 0) {
                        const starsContainer = document.querySelector(`[data-video="${videoId}"][data-category="${category}"]`)?.closest('.stars');
                        if (starsContainer) {
                            updateStarDisplay(starsContainer, rating, true);
                            // Add user rating indicator
                            const controls = starsContainer.closest('.rating-controls');
                            if (controls && !controls.querySelector('.user-rating-indicator')) {
                                const indicator = document.createElement('div');
                                indicator.className = 'user-rating-indicator';
                                indicator.textContent = `Your rating: ${rating}â˜…`;
                                controls.appendChild(indicator);
                            }
                        }
                    }
                });
            });
        }

        async function submitRating(videoId, category, rating) {
            try {
                // Update user's personal ratings
                if (!userRatings[videoId]) {
                    userRatings[videoId] = { lyrics: 0, beats: 0, reaction: 0, overall: 0 };
                }
                userRatings[videoId][category] = rating;

                if (db) {
                    // Save to Firebase
                    await db.collection('userRatings').doc(`${currentUser.uid}_${videoId}`).set({
                        userId: currentUser.uid,
                        videoId: videoId,
                        ratings: userRatings[videoId],
                        lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                    });

                    // Update video's aggregate rating
                    await updateVideoRating(videoId, category, rating);
                }

                showNotification(`Rated ${category}: ${rating} stars! Thanks for contributing to the community!`, 'success');
                
            } catch (error) {
                console.error('Error submitting rating:', error);
                showNotification('Failed to save rating. Please try again.', 'error');
            }
        }

        async function updateVideoRating(videoId, category, newRating) {
            if (!db) return;

            try {
                const videoRef = db.collection('videos').doc(videoId);
                const ratingsRef = db.collection('ratings').doc(`${videoId}_${category}`);
                
                await db.runTransaction(async (transaction) => {
                    const ratingsDoc = await transaction.get(ratingsRef);
                    
                    let totalRating = newRating;
                    let count = 1;
                    
                    if (ratingsDoc.exists) {
                        const data = ratingsDoc.data();
                        totalRating = data.totalRating + newRating;
                        count = data.count + 1;
                    }
                    
                    const average = totalRating / count;
                    
                    transaction.set(ratingsRef, {
                        totalRating: totalRating,
                        count: count,
                        average: average
                    });
                    
                    transaction.update(videoRef, {
                        [`ratings.${category}.average`]: average,
                        [`ratings.${category}.count`]: count
                    });
                });
                
                // Update local data
                const video = videos.find(v => v.episodeNumber.toString() === videoId);
                if (video) {
                    const currentData = video.ratings[category];
                    const newTotal = (currentData.average * currentData.count) + newRating;
                    const newCount = currentData.count + 1;
                    video.ratings[category] = {
                        average: newTotal / newCount,
                        count: newCount
                    };
                }
                
                // Re-render to show updated ratings
                renderVideos();
                updateStats();
                
            } catch (error) {
                console.error('Error updating video rating:', error);
            }
        }

        function createStarRating(category, videoId, currentRating, ratingCount) {
            let starsHtml = '';
            const userRating = userRatings[videoId] ? userRatings[videoId][category] : 0;
            
            for (let i = 1; i <= 5; i++) {
                const activeClass = i <= Math.round(currentRating) ? 'active' : '';
                const userRatedClass = userRating > 0 && i <= userRating ? 'user-rated' : '';
                starsHtml += `<span class="star ${activeClass} ${userRatedClass}" data-rating="${i}" data-category="${category}" data-video="${videoId}">â˜…</span>`;
            }
            return starsHtml;
        }

        function createVideoCard(video) {
            const wordsHtml = video.segments.map((segment, index) => `
                <div>
                    <div class="segment-label">Segment ${index + 1}</div>
                    <div class="word-segments">
                        ${segment.words.map(word => `<span class="word-tag">${word}</span>`).join('')}
                    </div>
                </div>
            `).join('');

            const videoId = video.episodeNumber.toString();
            const userVideoRatings = userRatings[videoId] || { lyrics: 0, beats: 0, reaction: 0, overall: 0 };

            return `
                <div class="video-card" data-episode="${video.episodeNumber}">
                    <div class="video-embed">
                        YouTube Video Embed Here<br>
                        <small>(Episode #${video.episodeNumber})</small>
                    </div>
                    <div class="video-content">
                        <div class="video-title">${video.title}</div>
                        
                        <div class="words-section">
                            <h4>Improvised Words</h4>
                            ${wordsHtml}
                        </div>

                        <div class="rating-section">
                            ${['lyrics', 'beats', 'reaction', 'overall'].map(category => `
                                <div class="rating-category">
                                    <div class="rating-info">
                                        <span class="rating-label">${category.charAt(0).toUpperCase() + category.slice(1)}</span>
                                        <span class="rating-stats">${video.ratings[category].average.toFixed(1)}â˜… (${video.ratings[category].count} ratings)</span>
                                    </div>
                                    <div class="rating-controls">
                                        <div class="stars">${createStarRating(category, videoId, video.ratings[category].average, video.ratings[category].count)}</div>
                                        ${userVideoRatings[category] > 0 ? `<div class="user-rating-indicator">Your rating: ${userVideoRatings[category]}â˜…</div>` : ''}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderVideos(videosToShow = videos) {
            const grid = document.getElementById('videoGrid');
            grid.innerHTML = videosToShow.map(createVideoCard).join('');
            
            // Add click handlers for stars
            document.querySelectorAll('.star').forEach(star => {
                star.addEventListener('click', handleStarClick);
                star.addEventListener('mouseenter', handleStarHover);
                star.addEventListener('mouseleave', handleStarLeave);
            });
        }

        function handleStarClick(e) {
            const rating = parseInt(e.target.dataset.rating);
            const category = e.target.dataset.category;
            const videoId = e.target.dataset.video;
            
            if (!currentUser) {
                showSignInPrompt(category, rating);
                return;
            }
            
            submitRating(videoId, category, rating);
            updateStarDisplay(e.target.closest('.stars'), rating, true);
        }

        function handleStarHover(e) {
            const rating = parseInt(e.target.dataset.rating);
            const stars = e.target.closest('.stars');
            updateStarDisplay(stars, rating);
        }

        function handleStarLeave(e) {
            const stars = e.target.closest('.stars');
            const videoId = e.target.dataset.video;
            const category = e.target.dataset.category;
            
            // Reset to actual rating
            const video = videos.find(v => v.episodeNumber.toString() === videoId);
            if (video) {
                const userRating = userRatings[videoId] ? userRatings[videoId][category] : 0;
                const displayRating = userRating > 0 ? userRating : video.ratings[category].average;
                updateStarDisplay(stars, displayRating, userRating > 0);
            }
        }

        function updateStarDisplay(starsContainer, rating, isUserRating = false) {
            const stars = starsContainer.querySelectorAll('.star');
            stars.forEach((star, index) => {
                star.classList.remove('active', 'user-rated');
                if (index < Math.round(rating)) {
                    star.classList.add(isUserRating ? 'user-rated' : 'active');
                }
            });
        }

        function updateStats() {
            let totalRatings = 0;
            let totalOverallRating = 0;
            let validOverallRatings = 0;
            let topEpisode = { number: 0, rating: 0 };

            videos.forEach(video => {
                // Count all ratings across all categories
                Object.values(video.ratings).forEach(rating => {
                    totalRatings += rating.count;
                });

                // Calculate overall average
                if (video.ratings.overall.count > 0) {
                    totalOverallRating += video.ratings.overall.average;
                    validOverallRatings++;

                    // Find top episode
                    if (video.ratings.overall.average > topEpisode.rating) {
                        topEpisode = {
                            number: video.episodeNumber,
                            rating: video.ratings.overall.average
                        };
                    }
                }
            });

            // Update stats display
            document.getElementById('totalRatings').textContent = totalRatings.toLocaleString();
            document.getElementById('avgOverall').textContent = validOverallRatings > 0 ? 
                (totalOverallRating / validOverallRatings).toFixed(1) : '0.0';
            document.getElementById('activeUsers').textContent = Object.keys(userRatings).length;
            document.getElementById('topEpisode').textContent = topEpisode.number > 0 ? 
                `#${topEpisode.number}` : '#--';
        }

        function showNotification(message, type = 'info') {
            // Remove existing notifications
            document.querySelectorAll('.notification').forEach(n => n.remove());

            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 4000);
        }

        function showSignInPrompt(category, rating) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 2000;
                animation: fadeIn 0.3s ease;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white;
                    padding: 30px;
                    border-radius: 15px;
                    text-align: center;
                    max-width: 400px;
                    margin: 20px;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                ">
                    <h3 style="margin-bottom: 15px; color: #2c3e50;">Join the Community!</h3>
                    <p style="margin-bottom: 20px; color: #7f8c8d; line-height: 1.5;">
                        Sign in to rate this ${category} as ${rating} star${rating > 1 ? 's' : ''} and help other Harry Mack fans discover the best episodes!
                    </p>
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button id="modalSignIn" style="
                            background: #3498db;
                            color: white;
                            border: none;
                            padding: 12px 24px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: bold;
                        ">Sign In with Google</button>
                        <button id="modalCancel" style="
                            background: #95a5a6;
                            color: white;
                            border: none;
                            padding: 12px 24px;
                            border-radius: 8px;
                            cursor: pointer;
                        ">Maybe Later</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            document.getElementById('modalSignIn').onclick = () => {
                modal.remove();
                signIn();
            };
            
            document.getElementById('modalCancel').onclick = () => {
                modal.remove();
            };
            
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
        }

        // Filter and search functionality
        function setupFilters() {
            const sortFilter = document.getElementById('sortFilter');
            const ratingFilter = document.getElementById('ratingFilter');
            const searchFilter = document.getElementById('searchFilter');

            [sortFilter, ratingFilter, searchFilter].forEach(filter => {
                filter.addEventListener('change', applyFilters);
                filter.addEventListener('input', applyFilters);
            });
        }

        function applyFilters() {
            let filteredVideos = [...videos];
            
            // Apply rating filter
            const minRating = parseFloat(document.getElementById('ratingFilter').value);
            if (minRating > 0) {
                filteredVideos = filteredVideos.filter(video => 
                    video.ratings.overall.average >= minRating
                );
            }
            
            // Apply search filter
            const searchTerm = document.getElementById('searchFilter').value.toLowerCase();
            if (searchTerm) {
                filteredVideos = filteredVideos.filter(video => {
                    const titleMatch = video.title.toLowerCase().includes(searchTerm);
                    const episodeMatch = video.episodeNumber.toString().includes(searchTerm);
                    const wordsMatch = video.segments.some(segment => 
                        segment.words.some(word => word.toLowerCase().includes(searchTerm))
                    );
                    return titleMatch || episodeMatch || wordsMatch;
                });
            }
            
            // Apply sort
            const sortBy = document.getElementById('sortFilter').value;
            filteredVideos.sort((a, b) => {
                if (sortBy === 'episode') {
                    return a.episodeNumber - b.episodeNumber;
                } else {
                    return b.ratings[sortBy].average - a.ratings[sortBy].average;
                }
            });
            
            renderVideos(filteredVideos);
        }

        // Real-time updates listener
        function setupRealtimeUpdates() {
            if (!db) return;

            // Listen for rating updates
            db.collection('videos').onSnapshot((snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === 'modified') {
                        const updatedVideo = { id: change.doc.id, ...change.doc.data() };
                        const index = videos.findIndex(v => v.episodeNumber === updatedVideo.episodeNumber);
                        if (index !== -1) {
                            videos[index] = updatedVideo;
                        }
                    }
                });
                
                // Re-render if there were changes
                if (snapshot.docChanges().length > 0) {
                    applyFilters(); // This will re-render with current filters
                    updateStats();
                }
            });
        }

        // Initialize the application
        function init() {
            updateConnectionStatus('connecting');
            
            // Try to initialize Firebase, fall back to demo mode if it fails
            initializeFirebase();
            
            // Set up filters
            setupFilters();
            
            // Set up real-time updates
            setupRealtimeUpdates();

            // Set up auth button
            document.getElementById('authButton').addEventListener('click', () => {
                if (currentUser) {
                    signOut();
                } else {
                    signIn();
                }
            });
        }

        // Start the application when the page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
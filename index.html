<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harry Mack Omegle Bars - Community Hub</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            color: white;
            position: relative;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .user-section {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .user-info {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .auth-button {
            display: inline-flex;
            align-items: center;
            background: white;
            color: #3c4043;
            border: 1px solid #dadce0;
            border-radius: 24px;
            padding: 8px 16px;
            font-family: 'Google Sans', Roboto, Arial, sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px 0 rgba(60,64,67,0.30);
            gap: 8px;
        }
        
        .auth-button {
            display: inline-flex;
            align-items: center;
            background: white;
            color: #3c4043;
            border: 1px solid #dadce0;
            border-radius: 24px;
            padding: 10px 16px;
            font-family: 'Google Sans', 'Roboto', Arial, sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px 0 rgba(60,64,67,0.30), 0 1px 3px 1px rgba(60,64,67,0.15);
            gap: 12px;
            min-height: 40px;
        }
        
        .auth-button:hover {
            background: #f8f9fa;
            border-color: #c1c7cd;
            box-shadow: 0 1px 3px 1px rgba(60,64,67,0.15), 0 1px 2px 0 rgba(60,64,67,0.30);
        }
        
        .auth-button:active {
            background: #f1f3f4;
            box-shadow: 0 1px 2px 0 rgba(60,64,67,0.30);
        }
        
        .google-icon {
            width: 18px;
            height: 18px;
            display: block;
        }
        
        .connection-status {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
            z-index: 1000;
        }

        .status-connected {
            background: #27ae60;
            color: white;
        }

        .status-disconnected {
            background: #e74c3c;
            color: white;
        }

        .status-demo {
            background: #f39c12;
            color: white;
        }

        .status-connecting {
            background: #f39c12;
            color: white;
        }

        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
        }

        .video-card {
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .video-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
        }

        .video-embed {
            position: relative;
            width: 100%;
            height: 200px;
            background: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 14px;
        }

        .video-content {
            padding: 20px;
        }

        .video-title {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .overall-rating {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border-left: 4px solid #3498db;
        }

        .overall-rating h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .segments-section {
            margin-bottom: 20px;
        }

        .segments-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .segments-header h4 {
            color: #8e44ad;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .expand-toggle {
            background: #8e44ad;
            color: white;
            border: none;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .expand-toggle:hover {
            background: #7d3c98;
        }

        .segment {
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 15px;
            border-left: 4px solid #e74c3c;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .segment-header {
            padding: 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #fff;
            border-bottom: 1px solid #eee;
        }

        .segment-header:hover {
            background: #f8f9fa;
        }

        .segment-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .segment-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
        }

        .segment-rating-summary {
            font-size: 0.75rem;
            color: #7f8c8d;
        }

        .segment-expand-icon {
            color: #8e44ad;
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }

        .segment.expanded .segment-expand-icon {
            transform: rotate(90deg);
        }

        .segment-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .segment.expanded .segment-content {
            max-height: 600px;
        }

        .segment-details {
            padding: 20px;
        }

        .words-management {
            margin-bottom: 20px;
        }

        .words-management h5 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 0.85rem;
        }

        .word-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }

        .word-item {
            display: flex;
            align-items: center;
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 0.8rem;
            gap: 5px;
        }

        .word-votes {
            background: rgba(255, 255, 255, 0.3);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
        }

        .vote-buttons {
            display: flex;
            gap: 2px;
        }

        .vote-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.7rem;
            transition: background 0.2s ease;
        }

        .vote-btn:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        .vote-btn.voted {
            background: rgba(255, 255, 255, 0.8);
            color: #333;
        }

        .add-word-form {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .add-word-input {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 0.8rem;
        }

        .add-word-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background 0.3s ease;
        }

        .add-word-btn:hover {
            background: #229954;
        }

        .segment-ratings {
            border-top: 1px solid #eee;
            padding-top: 15px;
        }

        .rating-category {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .rating-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .rating-label {
            font-weight: 600;
            color: #34495e;
            font-size: 0.85rem;
        }

        .rating-stats {
            font-size: 0.7rem;
            color: #7f8c8d;
            margin-top: 2px;
        }

        .rating-controls {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
        }

        .stars {
            display: flex;
            gap: 3px;
        }

        .star {
            width: 20px;
            height: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #ddd;
            user-select: none;
        }

        .star:hover,
        .star.active {
            color: #f39c12;
            transform: scale(1.1);
        }

        .star.user-rated {
            color: #e74c3c;
        }

        .user-rating-indicator {
            font-size: 0.65rem;
            color: #e74c3c;
            font-weight: bold;
        }

        .stats-bar {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            color: white;
            text-align: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .stat-item {
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .filter-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            color: white;
        }

        .filter-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-controls select,
        .filter-controls input {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            background: white;
            color: #333;
        }

        .loading {
            text-align: center;
            color: white;
            font-size: 1.2rem;
            margin: 50px 0;
        }

        .error-message {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 10px;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: slideIn 0.3s ease;
        }

        .notification.success {
            background: #27ae60;
            color: white;
        }

        .notification.error {
            background: #e74c3c;
            color: white;
        }

        .notification.info {
            background: #3498db;
            color: white;
        }

        .segment-label {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .debug-info {
            background: #ffeb3b;
            color: #333;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 0.8rem;
            font-family: monospace;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @media (max-width: 768px) {
            .video-grid {
                grid-template-columns: 1fr;
            }
            .header h1 {
                font-size: 2rem;
            }
            .user-section {
                position: static;
                justify-content: center;
                margin-top: 15px;
            }
            .filter-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>

<body>
    <div class="connection-status" id="connectionStatus">
        <span id="statusText">Connecting...</span>
    </div>

    <div class="container">
        <div class="header">
            <div class="user-section">
                <div class="user-info" id="userInfo" style="display: none;">
                    Welcome, <span id="userName"></span>!
                </div>
                <button class="auth-button" id="authButton">
                    <img class="google-icon" src="https://developers.google.com/identity/images/g-logo.png" alt="Google logo">
                    Sign in with Google
                </button>
            </div>
            
            <h1>🎤 Harry Mack Community Hub</h1>
            <p>Rate each segment and crowdsource words with the global Harry Mack fan community!</p>
            <p style="font-size: 0.9rem; margin-top: 10px; opacity: 0.8;">
                ✨ Rate individual segments • Add missing words • Vote on word accuracy ✨
            </p>
        </div>

        <div class="filter-section">
            <div class="filter-controls">
                <label>Sort by:</label>
                <select id="sortFilter">
                    <option value="episode">Episode Number</option>
                    <option value="overall">Overall Rating</option>
                    <option value="lyrics">Lyrics Rating</option>
                    <option value="beats">Beats Rating</option>
                    <option value="reaction">Reaction Rating</option>
                </select>
                
                <label>Min Rating:</label>
                <select id="ratingFilter">
                    <option value="0">All Videos</option>
                    <option value="3">3+ Stars</option>
                    <option value="4">4+ Stars</option>
                    <option value="5">5 Stars Only</option>
                </select>

                <input type="text" id="searchFilter" placeholder="Search by words or episode...">
            </div>
        </div>

        <div id="loadingMessage" class="loading">
            Loading Harry Mack videos and community ratings...
        </div>

        <div class="video-grid" id="videoGrid" style="display: none;">
        </div>

        <div class="stats-bar" id="statsBar" style="display: none;">
            <h3 style="margin-bottom: 20px;">Global Community Stats</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-number" id="totalRatings">0</div>
                    <div class="stat-label">Total Ratings</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="avgOverall">0.0</div>
                    <div class="stat-label">Avg Overall Rating</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="activeUsers">0</div>
                    <div class="stat-label">Community Members</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="topEpisode">#--</div>
                    <div class="stat-label">Highest Rated Episode</div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-app-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-auth-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-firestore-compat.min.js"></script>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBUtq7jUntXqH0C0V2fDR1fwh2yPoZJAls",
            authDomain: "harry-mack-community.firebaseapp.com",
            projectId: "harry-mack-community",
            storageBucket: "harry-mack-community.firebasestorage.app",
            messagingSenderId: "1035009511388",
            appId: "1:1035009511388:web:23b2e932da2ac74466c919"
        };

        let app, auth, db;
        let currentUser = null;
        let isSigningIn = false;
        let videos = [];
        let userRatings = {};
        let userWordVotes = {};

        // Default ratings structure
        const defaultRatings = {
            lyrics: { average: 3.0, count: 0 },
            beats: { average: 3.0, count: 0 },
            reaction: { average: 3.0, count: 0 },
            overall: { average: 3.0, count: 0 }
        };

        // Debug mode flag
        const DEBUG_EPISODE_2 = true;



        // OPTION 2: Complete Fix - Better Firebase handling
        // If you want Firebase saving, replace your convertWordsObjectToArray function with this:
        function convertWordsObjectToArray(wordsData) {
            
            console.log('🔍 DEBUG: Input to convertWordsObjectToArray:', JSON.stringify(wordsData, null, 2));
            console.log('🔄 Converting words data:', wordsData);
            
            if (!wordsData) {
                return [
                    [{word: 'word1', votes: 5, voters: []}],
                    [{word: 'word2', votes: 5, voters: []}],
                    [{word: 'word3', votes: 5, voters: []}]
                ];
            }
        
            // If it's already the correct format (array of arrays), return as-is
            if (Array.isArray(wordsData) && wordsData.length > 0 && Array.isArray(wordsData[0])) {
                console.log('✅ Already in correct format');
                return wordsData;
            }
        
            // If it's an array of objects (Firebase format), convert back to arrays
            if (Array.isArray(wordsData) && wordsData.length > 0 && 
                typeof wordsData[0] === 'object' && !Array.isArray(wordsData[0])) {
                console.log('🔄 Converting from Firebase object format');
                
                return wordsData.map((wordPosition, index) => {
                    if (typeof wordPosition === 'object' && wordPosition !== null) {
                        // Convert object back to array
                        const candidates = Object.values(wordPosition).filter(candidate => 
                            candidate && typeof candidate === 'object' && candidate.word
                        );
                        return candidates.length > 0 ? candidates : [{word: `word${index + 1}`, votes: 1, voters: []}];
                    } else {
                        return [{word: `word${index + 1}`, votes: 1, voters: []}];
                    }
                });
            }
        
            // Fallback - create default structure
            console.log('⚠️ Unknown format, creating defaults');
            return [
                [{word: 'word1', votes: 5, voters: []}],
                [{word: 'word2', votes: 5, voters: []}],
                [{word: 'word3', votes: 5, voters: []}]
            ];
        }
        
    


        function sanitizeSegmentData(segment, videoId, segmentIndex) {
            console.log(`🔧 Sanitizing segment data for ${videoId}-${segmentIndex}:`, segment);
            
            const sanitized = {
                id: segment?.id || `segment_${videoId}_${segmentIndex + 1}`,
                ratings: segment?.ratings || { ...defaultRatings },
                words: []
            };
        
            // FIXED: Don't convert if data is already in correct format
            if (segment?.words) {
                console.log(`🔄 Processing words for ${videoId}-${segmentIndex}`);
                
                // Check if words are already in correct format (array of arrays)
                if (Array.isArray(segment.words) && 
                    segment.words.length > 0 && 
                    Array.isArray(segment.words[0])) {
                    
                    console.log(`✅ Words already in correct format for ${videoId}-${segmentIndex}`);
                    sanitized.words = segment.words; // Use as-is, no conversion needed
                    
                } else {
                    console.log(`🔄 Converting words format for ${videoId}-${segmentIndex}`);
                    try {
                        sanitized.words = convertWordsObjectToArray(segment.words);
                        console.log(`✅ Words converted successfully for ${videoId}-${segmentIndex}`);
                    } catch (conversionError) {
                        console.warn(`⚠️ Error converting words for ${videoId}-${segmentIndex}:`, conversionError);
                        sanitized.words = [
                            [{word: 'word1', votes: 5, voters: []}],
                            [{word: 'word2', votes: 5, voters: []}],
                            [{word: 'word3', votes: 5, voters: []}]
                        ];
                    }
                }
            } else {
                console.warn(`⚠️ No words found for ${videoId}-${segmentIndex}, creating default`);
                sanitized.words = [
                    [{word: 'word1', votes: 5, voters: []}],
                    [{word: 'word2', votes: 5, voters: []}],
                    [{word: 'word3', votes: 5, voters: []}]
                ];
            }
        
            console.log(`✅ Sanitized segment for ${videoId}-${segmentIndex}:`, sanitized);
            return sanitized;
        }

        function generateDefaultSegments() {
            console.log('🔧 Generating default segments...');
            const wordBank = ["pizza", "galaxy", "thunderstorm", "basketball", "dragon", "coffee"];
            const numSegments = 3; // Default to 3 segments
            const segments = [];
            
            for (let j = 0; j < numSegments; j++) {
                const segmentWords = [];
                
                // Generate 3 words per segment
                for (let k = 0; k < 3; k++) {
                    const candidateWords = [];
                    const baseWord = wordBank[Math.floor(Math.random() * wordBank.length)];
                    
                    candidateWords.push({
                        word: baseWord,
                        votes: Math.floor(Math.random() * 10) + 5,
                        voters: []
                    });
                    
                    segmentWords.push(candidateWords);
                }
                
                segments.push({
                    id: `default_segment_${j + 1}`,
                    words: segmentWords,
                    ratings: { ...defaultRatings }
                });
            }
            
            console.log(`✅ Generated ${segments.length} default segments`);
            return segments;
        }

        async function initializeFirebase() {
            try {
                console.log('🔥 Initializing Firebase...');
                app = firebase.initializeApp(firebaseConfig);
                auth = firebase.auth();
                db = firebase.firestore();
                
                console.log('✅ Firebase services initialized');
                console.log('🔒 Setting auth persistence...');
                
                await auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);
                console.log('✅ Auth persistence set');
                
                console.log('🔄 Checking for redirect result...');
                try {
                    const result = await auth.getRedirectResult();
                    console.log('🔄 Redirect result:', result);
                    
                    if (result.user) {
                        console.log('👤 User signed in via redirect:', result.user.email);
                        showNotification(`Welcome ${result.user.displayName || result.user.email}! You're now signed in.`, 'success');
                        handleAuthStateChange(result.user);
                    } else if (result.credential) {
                        console.log('🔑 Got credential but no user - possible error');
                    } else {
                        console.log('ℹ️ No redirect result - normal page load');
                    }
                } catch (redirectError) {
                    console.error('❌ Redirect error:', redirectError);
                    console.error('❌ Error code:', redirectError.code);
                    console.error('❌ Error message:', redirectError.message);
                    
                    if (redirectError.code === 'auth/unauthorized-domain') {
                        showNotification('This domain is not authorized. Please add it to Firebase.', 'error');
                    } else if (redirectError.code !== 'auth/redirect-cancelled-by-user') {
                        showNotification(`Sign in failed: ${redirectError.message}`, 'error');
                    }
                }

                auth.onAuthStateChanged((user) => {
                    console.log('🔄 Auth state changed:', user ? user.email : 'No user');
                    if (user) {
                        isSigningIn = false;
                    }
                    handleAuthStateChange(user);
                });
                
                const currentUser = auth.currentUser;
                console.log('👤 Current user on init:', currentUser ? currentUser.email : 'None');
                
                // Test Firestore permissions
                console.log('🧪 Testing Firestore read permissions...');
                try {
                    await db.collection('videos').limit(1).get();
                    console.log('✅ Firestore read permission confirmed');
                } catch (permError) {
                    console.error('❌ Firestore permission error:', permError);
                    throw permError;
                }
                
                console.log('📊 Starting to load videos data...');
                loadVideosData();
                updateConnectionStatus('connected');
                
            } catch (error) {
                console.error('❌ Firebase initialization failed:', error);
                console.error('❌ Error details:', error.message, error.code);
                handleFirebaseError();
            }
        }

        function handleFirebaseError() {
            updateConnectionStatus('demo');
            showNotification('Running in demo mode - all features work except saving ratings!', 'info');
            initializeDemoMode();
        }

        function initializeDemoMode() {
            generateSampleVideos();
            renderVideos();
            updateStats();
            
            document.getElementById('loadingMessage').style.display = 'none';
            document.getElementById('videoGrid').style.display = 'grid';
            document.getElementById('statsBar').style.display = 'block';
        }

        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            
            statusElement.className = 'connection-status status-' + status;
            
            switch(status) {
                case 'connected':
                    statusText.textContent = '🟢 Live';
                    break;
                case 'disconnected':
                    statusText.textContent = '🔴 Offline';
                    break;
                case 'demo':
                    statusText.textContent = '🟡 Demo Mode';
                    break;
                case 'connecting':
                    statusText.textContent = '🟡 Connecting...';
                    break;
            }
        }

        function handleAuthStateChange(user) {
            currentUser = user;
            
            const userInfo = document.getElementById('userInfo');
            const userName = document.getElementById('userName');
            const authButton = document.getElementById('authButton');

            if (user) {
                userInfo.style.display = 'block';
                userName.textContent = user.displayName || user.email;
                authButton.innerHTML = 'Sign Out';
                authButton.onclick = signOut;
                
                loadUserRatings();
                loadUserWordVotes();
                
            } else {
                userInfo.style.display = 'none';
                authButton.innerHTML = '<img class="google-icon" src="https://developers.google.com/identity/images/g-logo.png" alt="Google logo">Sign in with Google';
                authButton.onclick = signIn;
                userRatings = {};
                userWordVotes = {};
            }
        }

        async function signIn() {
            if (!auth) {
                showNotification('Authentication not available in demo mode', 'info');
                return;
            }
            
            if (isSigningIn) {
                console.log('Sign-in already in progress');
                return;
            }
            
            console.log('Sign in button clicked');
            console.log('Current URL:', window.location.href);
            console.log('Auth domain:', firebaseConfig.authDomain);
            
            const provider = new firebase.auth.GoogleAuthProvider();
            provider.addScope('profile');
            provider.addScope('email');
            
            try {
                isSigningIn = true;
                console.log('Starting popup sign in...');
                showNotification('Opening Google sign-in popup...', 'info');
                
                const result = await auth.signInWithPopup(provider);
                
                console.log('Sign in successful:', result.user);
                showNotification('Successfully signed in!', 'success');
                
            } catch (error) {
                console.error('Sign in error:', error);
                
                if (error.code === 'auth/operation-not-allowed') {
                    showNotification('Google sign-in is not enabled in Firebase Console', 'error');
                } else if (error.code === 'auth/unauthorized-domain') {
                    showNotification('This domain is not authorized in Firebase', 'error');
                } else if (error.code === 'auth/popup-closed-by-user') {
                    showNotification('Sign-in popup was closed. Please try again.', 'info');
                } else if (error.code === 'auth/popup-blocked') {
                    showNotification('Sign-in popup was blocked by browser. Please allow popups and try again.', 'error');
                } else if (error.code === 'auth/cancelled-popup-request') {
                    showNotification('Another sign-in popup is already open. Please complete that first.', 'info');
                } else {
                    showNotification(`Sign in failed: ${error.message}`, 'error');
                }
            } finally {
                isSigningIn = false;
            }
        }

        async function signOut() {
            if (auth) {
                try {
                    await auth.signOut();
                    showNotification('You have been signed out.', 'info');
                } catch (error) {
                    console.error('Sign out error:', error);
                    showNotification('Error signing out. Please try again.', 'error');
                }
            }
        }

        async function loadVideosData() {
            try {
                if (!db) {
                    console.log('No database connection - using demo mode');
                    initializeDemoMode();
                    return;
                }

                console.log('✅ Database connected, loading videos from Firebase...');
                console.log('📊 Querying videos collection...');
                
                const videosSnapshot = await db.collection('videos').orderBy('episodeNumber').get();
                console.log('📋 Query completed. Documents found:', videosSnapshot.size);
                
                if (videosSnapshot.empty) {
                    console.log('📝 No videos found - initializing sample data...');
                    await initializeFirebaseData();
                    console.log('✅ Sample data initialized successfully');
                } else {
                    console.log('📖 Loading existing videos from Firebase...');
                    videos = [];
                    
                    videosSnapshot.docs.forEach(doc => {
                        const data = doc.data();
                        console.log(`📄 Processing video: Episode ${data.episodeNumber}`);
                        
                        // Special handling for Episode 2
                        if (data.episodeNumber === 2 && DEBUG_EPISODE_2) {
                            console.log('🔍 EPISODE 2 DEBUG - Raw data:', JSON.stringify(data, null, 2));
                            console.log('🔍 EPISODE 2 DEBUG - Segments type:', typeof data.segments);
                            console.log('🔍 EPISODE 2 DEBUG - Segments is array:', Array.isArray(data.segments));
                            console.log('🔍 EPISODE 2 DEBUG - Segments content:', data.segments);
                        }

                        if (data.episodeNumber === 2 && DEBUG_EPISODE_2) {
                            console.log('🔍 EPISODE 2 DETAILED ANALYSIS:');
                            
                            // Show the complete segments object structure
                            console.log('📊 Complete segments object:', JSON.stringify(data.segments, null, 2));
                            
                            // Analyze each segment
                            Object.entries(data.segments).forEach(([key, segment]) => {
                                console.log(`📋 Segment "${key}" details:`);
                                console.log(`   - Has ratings:`, !!segment.ratings);
                                console.log(`   - Has words:`, !!segment.words);
                                console.log(`   - Has id:`, !!segment.id);
                                console.log(`   - All properties:`, Object.keys(segment));
                                console.log(`   - Full segment:`, segment);
                                
                                if (segment.words) {
                                    console.log(`   - Words type:`, typeof segment.words);
                                    console.log(`   - Words is array:`, Array.isArray(segment.words));
                                    console.log(`   - Words content:`, segment.words);
                                }
                                
                                if (segment.ratings) {
                                    console.log(`   - Ratings:`, segment.ratings);
                                }
                            });
                        }
                                                
                        // Safely handle segments data
                        let processedSegments = [];

                        // Add this right after the Episode 2 debug section (around line 1035)
                        // Replace the existing "else if (data.segments && typeof data.segments === 'object')" section
                        
                        if (data.episodeNumber === 2) {
                            console.log('🔧 FIXING EPISODE 2 DATA - Detected incomplete structure');
                            
                            // Check if Episode 2 is corrupted (missing segments/words)
                            const isCorrupted = !data.segments || 
                                               Object.keys(data.segments).length < 2 || 
                                               !Object.values(data.segments).some(seg => seg.words);
                            
                            if (isCorrupted) {
                                console.log('⚠️ Episode 2 data is corrupted, regenerating...');
                                
                                // Generate proper Episode 2 segments using the same logic as sample videos
                                const wordBank = ["freestyle", "microphone", "talent", "creativity", "improvise", "rhythm"];
                                const newSegments = [];
                                
                                for (let j = 0; j < 3; j++) { // Create 3 segments
                                    const segmentWords = [];
                                    
                                    // Generate 3 words per segment
                                    for (let k = 0; k < 3; k++) {
                                        const candidateWords = [];
                                        const baseWord = wordBank[Math.floor(Math.random() * wordBank.length)];
                                        
                                        candidateWords.push({
                                            word: baseWord,
                                            votes: Math.floor(Math.random() * 10) + 5,
                                            voters: []
                                        });
                                        
                                        segmentWords.push(candidateWords);
                                    }
                                    
                                    // Create segment with proper structure
                                    newSegments.push({
                                        id: `segment_2_${j + 1}`,
                                        words: segmentWords,
                                        ratings: {
                                            lyrics: { average: 3.5 + Math.random(), count: 15 + Math.floor(Math.random() * 10) },
                                            beats: { average: 3.8 + Math.random(), count: 18 + Math.floor(Math.random() * 12) },
                                            reaction: { average: 3.2 + Math.random(), count: 12 + Math.floor(Math.random() * 8) },
                                            overall: { average: 3.5 + Math.random(), count: 14 + Math.floor(Math.random() * 6) }
                                        }
                                    });
                                }
                                
                                // Replace the corrupted segments with proper ones
                                processedSegments = newSegments;
                                console.log('✅ Episode 2 data regenerated with', processedSegments.length, 'segments');
                    
                                // Skip Firebase save due to nested array limitations
                                console.log('ℹ️ Episode 2 fixed locally only - skipping Firebase save');
                                
                            } else {
                                // Process normally if not corrupted
                                const segmentValues = Object.values(data.segments);
                                processedSegments = segmentValues.map((segment, idx) => 
                                    sanitizeSegmentData(segment, data.episodeNumber, idx)
                                );
                            }
                        } else if (data.segments && Array.isArray(data.segments)) {
                            console.log(`✅ Valid segments array with ${data.segments.length} items`);
                            processedSegments = data.segments.map((segment, idx) => 
                                sanitizeSegmentData(segment, data.episodeNumber, idx)
                            );
                        } else if (data.segments && typeof data.segments === 'object') {
                            console.log(`🔄 Converting segments object to array`);
                            const segmentValues = Object.values(data.segments);
                            processedSegments = segmentValues.map((segment, idx) => 
                                sanitizeSegmentData(segment, data.episodeNumber, idx)
                            );
                        } else {
                            console.log(`⚠️ No valid segments found for Episode ${data.episodeNumber}`);
                            processedSegments = generateDefaultSegments();
                        }
                        
     
                        
                        const processedVideo = {
                            id: doc.id,
                            episodeNumber: data.episodeNumber,
                            title: data.title || `Omegle Bars Episode #${data.episodeNumber}`,
                            youtubeId: getYouTubeId(data.episodeNumber),
                            segments: processedSegments,
                            ratings: data.ratings || { ...defaultRatings }
                        };
                        
                        videos.push(processedVideo);
                        console.log(`✅ Processed Episode ${data.episodeNumber} with ${processedSegments.length} segments`);
                    });
                    
                    console.log(`✅ Successfully loaded ${videos.length} videos`);
                }
                
                // Separate rendering from data loading to prevent fallback on render errors
                console.log('🎨 Starting to render videos...');
                try {
                    renderVideos();
                    updateStats();
                    document.getElementById('loadingMessage').style.display = 'none';
                    document.getElementById('videoGrid').style.display = 'grid';
                    document.getElementById('statsBar').style.display = 'block';
                    updateConnectionStatus('connected');
                    console.log('✅ Videos loaded and rendered successfully!');
                } catch (renderError) {
                    console.error('❌ Error during rendering (keeping loaded data):', renderError);
                    console.error('❌ Render error details:', renderError.message);
                    console.error('❌ Render error stack:', renderError.stack);
                    showNotification('Error rendering videos. Data loaded but display may be incomplete.', 'error');
                    
                    // Show basic UI even if rendering fails
                    document.getElementById('loadingMessage').style.display = 'none';
                    document.getElementById('videoGrid').style.display = 'grid';
                    document.getElementById('statsBar').style.display = 'block';
                    updateConnectionStatus('connected');
                }
                
            } catch (error) {
                console.error('❌ Error loading videos:', error);
                console.error('❌ Error details:', error.message);
                console.error('❌ Error code:', error.code);
                console.error('❌ Error stack:', error.stack);
                showNotification('Error loading videos. Using demo data.', 'error');
                initializeDemoMode();
            }
        }

        async function initializeFirebaseData() {
            console.log('🚀 Starting to generate sample videos...');
            const sampleVideos = generateSampleVideos();
            console.log(`📊 Generated ${sampleVideos.length} sample videos`);
            
            if (db) {
                try {
                    console.log('💾 Saving sample data to Firebase...');
                    const batch = db.batch();
                    sampleVideos.forEach((video, index) => {
                        const docRef = db.collection('videos').doc(`episode_${video.episodeNumber}`);
                        batch.set(docRef, video);
                        if (index < 3) { // Log first 3 for debugging
                            console.log(`📄 Preparing to save Episode ${video.episodeNumber}:`, video.title);
                        }
                    });
                    
                    console.log('⏳ Committing batch write to Firebase...');
                    await batch.commit();
                    console.log('✅ Sample data saved to Firebase successfully!');
                } catch (batchError) {
                    console.error('❌ Error saving to Firebase:', batchError);
                    console.error('❌ Batch error details:', batchError.message);
                    throw batchError; // Re-throw so the calling function handles it
                }
            } else {
                console.log('⚠️ No database connection - keeping data in memory only');
            }
            
            videos = sampleVideos;
            console.log(`✅ Videos array populated with ${videos.length} items`);
        }

        function getYouTubeId(episodeNumber) {
            const youtubeIds = [
                'NPdKxsSE5JQ',  // Episode 1
                'BgCUCg9aMyA',  // Episode 2
                '37duQAUSYXo',  // Episode 3
                'jrNapeXr3TY',  // Episode 4
                'Gh7Wbix9UwY',  // Episode 5
                'dwFhTq5x0Tc',  // Episode 6
                '75j7pEjRAIQ',  // Episode 7
                'O6ve-5b_x5U',  // Episode 8
                'oxuUDgOdoRw',  // Episode 9
                '7GAuu0Ro9PM',  // Episode 10
                'Rqv6oiyddn8',  // Episode 11
                'hZcpRm80EBk',  // Episode 12
                '6c5Y47TYQWQ',  // Episode 13
                'Ap4dVD_CRm8',  // Episode 14
                'lt0r0JNDeeo',  // Episode 15
                'XTfaaoBRjvs',  // Episode 16
                'QwnqI4dyPI8',  // Episode 17
                'VBBMfHGMs7I',  // Episode 18
                'EWThDBgYj9U',  // Episode 19
                'Tf84L54lSTE',  // Episode 20
                're1sJCcYZy4',  // Episode 21
                '3Y-0TUj1amk',  // Episode 22
                'JeRZWJ7NMGU',  // Episode 23
                'ZC6kl6ohAjo',  // Episode 24
                '1kN6LAf_7eg',  // Episode 25
                'U6dbmuCfdyk',  // Episode 26
                'dlnQOB15Sq8',  // Episode 27
                'ZOhE4fUduUU',  // Episode 28
                '2JHSSISCVww',  // Episode 29
                'vtjdWxFcOc4',  // Episode 30
                'fP4SftKI4LQ',  // Episode 31
                'Z3FjhBuFKyM',  // Episode 32
                'p-GYLYqpTP8',  // Episode 33
                'PPS8RLQkw04',  // Episode 34
                'YPLX5YpSMfI',  // Episode 35
                'QaD5-e6hjmY',  // Episode 36
                '1XZJKKNopEw',  // Episode 37
                'eStSbs0PklY',  // Episode 38
                'dkcnYy_VjRc',  // Episode 39
                '4dMm3q1rldE',  // Episode 40
                '25ceuw4CuK8',  // Episode 41
                'wy6qazFc2FQ',  // Episode 42
                'oXI3ysg3s3s',  // Episode 43
                'UlIzq76NZJA',  // Episode 44
                'OBM1UVnsQQo',  // Episode 45
                'KSc0UuBLRhg',  // Episode 46
                'n1K9P5Dtph4',  // Episode 47
                '5yTm4j6KaBQ',  // Episode 48
                '1dfh0G8Ik1c',  // Episode 49
                '-pRhkKkM2Ms',  // Episode 50
                'mwWw-1t3hyw',  // Episode 51
                '3ZhcM7-bh4c',  // Episode 52
                'Js2Q8tJLgig',  // Episode 53
                'eX9uZQoXAdY',  // Episode 54
                'AYc7Q6CSeGE',  // Episode 55
                'Djm0fwEX9ls',  // Episode 56
                'UI2qbARbQEw',  // Episode 57
                'sfFpAz8ZHVg',  // Episode 58
                'CKnUOb6My5Y',  // Episode 59
                'BbcTwW_aKxI',  // Episode 60
                'I0ng6LIjAOg',  // Episode 61
                'g25N4i6leas',  // Episode 62
                'abuAR-yoWSU',  // Episode 63
                'izM7RQctoPc',  // Episode 64
                'BNC68gQluSE',  // Episode 65
                'TJk3eDFwiaY',  // Episode 66
                'FxLKfWt3Kq4',  // Episode 67
                'QaRkdWCTKkM',  // Episode 68
                'O9AxmMO9xKw',  // Episode 69
                'AO0yvg0pLiM',  // Episode 70
                'qQKgwgWzg58',  // Episode 71
                'xqCEjV48TWA',  // Episode 72
                'SnJpkJ0or5o',  // Episode 73
                '2kfaZHwzda8',  // Episode 74
                '4yeyJVkbX8Y',  // Episode 75
                'Xm8Z4bGH_Ok',  // Episode 76
                'yxb2mb4wkF4',  // Episode 77
                'NKtwLntS4Pg',  // Episode 78
                'MiU7GJYeTas',  // Episode 79
                'TwRATtm76cI',  // Episode 80
                'bt0DLDPVE1M',  // Episode 81
                '6Phbw1vg5Wc',  // Episode 82
                '16xwgMHig-A',  // Episode 83
                'REllMQ6EQi8',  // Episode 84
                '6mfIBMQMYTw',  // Episode 85
                'gBgJRYcIcWA',  // Episode 86
                'WG0ZmvMYVrM',  // Episode 87
                'cXKJ3uv_XIk',  // Episode 88
                '_SZbXNGBWGk',  // Episode 89 
                'uhiwj4ho4V4',  // Episode 90
                'qG37EIdryFo',  // Episode 91
                'hr6sqlk73AI',  // Episode 92
                'rjBtpTI0MAc',  // Episode 93
                'bJgAtUirT7I',  // Episode 94
                '1suTTTUn7iA',  // Episode 95
                'TFaKz7SQsgg',  // Episode 96
                'qlfHCE9nl34',  // Episode 97
                'vL4W6n--r5A',  // Episode 98
                '-70WqAfeEYE',  // Episode 99
                'ijVGIcVRIbk',  // Episode 100
                '6sYh6iuMUA8',  // Episode 101
                'elpFOcnxTZY',  // Episode 102
                'sfAjqVYDISQ',  // Episode 103
                'BXFq6Y1iW7k',  // Episode 104
                'E6dqj45rjlE',  // Episode 105
                '2bMkeJ6Vu2s',  // Episode 106
                'HuCyL-QEIhQ',  // Episode 107
                '6u8Yt12uZnk',  // Episode 108
                'dfAQMcKqxM0',  // Episode 109
                'jSZmrM-1qpw'   // Episode 110
            ];
            
            // Return the corresponding YouTube ID (episodeNumber - 1 because array is 0-indexed)
            const index = episodeNumber - 1;
            
            // If episode number is within our range, return the correct ID
            if (index >= 0 && index < youtubeIds.length) {
                return youtubeIds[index];
            }
            
            // Fallback for episodes beyond 113 (cycle through existing IDs)
            return youtubeIds[index % youtubeIds.length];
        }
        
      
        
        function generateSampleVideos() {
            const wordBank = [
                "pizza", "galaxy", "thunderstorm", "basketball", "dragon", "coffee",
                "telephone", "rainbow", "adventure", "elephant", "computer", "sunshine",
                "bicycle", "ocean", "chocolate", "butterfly", "mountain", "music",
                "spaceship", "burger", "lightning", "guitar", "forest", "diamond",
                "robot", "sunset", "library", "airplane", "wizard", "sandwich",
                "telescope", "volcano", "penguin", "keyboard", "tornado", "ice cream"
            ];

            const sampleVideos = [];
            
            for (let i = 1; i <= 100; i++) {
                const segments = [];
                const numSegments = Math.random() < 0.8 ? 3 : (Math.random() < 0.5 ? 2 : 4);
                
                for (let j = 0; j < numSegments; j++) {
                    const numWords = Math.random() < 0.7 ? 3 : (Math.random() < 0.5 ? 2 : 4);
                    const segmentWords = [];
                    
                    // Generate candidate words with vote counts
                    for (let k = 0; k < numWords; k++) {
                        const candidateWords = [];
                        
                        // Get a random word for the main candidate
                        const baseWordIndex = Math.floor(Math.random() * wordBank.length);
                        const baseWord = wordBank[baseWordIndex];
                        
                        // Add the main word with high votes
                        candidateWords.push({
                            word: baseWord,
                            votes: Math.floor(Math.random() * 15) + 10,
                            voters: []
                        });
                        
                        // Sometimes add 1-2 alternative words with fewer votes (but not too many)
                        const numAlternatives = Math.random() < 0.4 ? 1 : (Math.random() < 0.2 ? 2 : 0);
                        
                        for (let alt = 0; alt < numAlternatives; alt++) {
                            let altWordIndex;
                            let altWord;
                            
                            // Make sure alternative word is different from base word
                            do {
                                altWordIndex = Math.floor(Math.random() * wordBank.length);
                                altWord = wordBank[altWordIndex];
                            } while (altWord === baseWord);
                            
                            // Only add if this word isn't already in the candidates
                            const wordExists = candidateWords.some(candidate => candidate.word === altWord);
                            if (!wordExists) {
                                candidateWords.push({
                                    word: altWord,
                                    votes: Math.floor(Math.random() * 5) + 1,
                                    voters: []
                                });
                            }
                        }
                        
                        segmentWords.push(candidateWords);
                    }
                    
                    // Generate ratings for this segment
                    const lyrics = Math.random() * 2 + 3;
                    const beats = Math.random() * 2 + 3;
                    const reaction = Math.random() * 2 + 3;
                    const overall = (lyrics + beats + reaction) / 3 + (Math.random() * 0.6 - 0.3);
                    
                    const baseRatingCount = Math.floor(Math.random() * 50) + 5;
                    
                    segments.push({
                        id: `segment_${i}_${j + 1}`, // Make ID unique with video number
                        words: segmentWords,
                        ratings: {
                            lyrics: { 
                                average: Math.max(1, Math.min(5, lyrics)),
                                count: baseRatingCount + Math.floor(Math.random() * 10) 
                            },
                            beats: { 
                                average: Math.max(1, Math.min(5, beats)), 
                                count: baseRatingCount + Math.floor(Math.random() * 12) 
                            },
                            reaction: { 
                                average: Math.max(1, Math.min(5, reaction)), 
                                count: baseRatingCount + Math.floor(Math.random() * 15) 
                            },
                            overall: { 
                                average: Math.max(1, Math.min(5, overall)), 
                                count: baseRatingCount + Math.floor(Math.random() * 8) 
                            }
                        }
                    });
                }

                // Calculate overall video ratings from segment averages
                const videoLyrics = segments.reduce((sum, seg) => sum + seg.ratings.lyrics.average, 0) / segments.length;
                const videoBeats = segments.reduce((sum, seg) => sum + seg.ratings.beats.average, 0) / segments.length;
                const videoReaction = segments.reduce((sum, seg) => sum + seg.ratings.reaction.average, 0) / segments.length;
                const videoOverall = segments.reduce((sum, seg) => sum + seg.ratings.overall.average, 0) / segments.length;
                
                const totalSegmentRatings = segments.reduce((sum, seg) => 
                    sum + seg.ratings.lyrics.count + seg.ratings.beats.count + seg.ratings.reaction.count + seg.ratings.overall.count, 0);

                const video = {
                    episodeNumber: i,
                    title: `Omegle Bars Episode #${i}`,
                    youtubeId: getYouTubeId(i),
                    segments: segments,
                    ratings: {
                        lyrics: { 
                            average: videoLyrics,
                            count: Math.floor(totalSegmentRatings * 0.25) 
                        },
                        beats: { 
                            average: videoBeats, 
                            count: Math.floor(totalSegmentRatings * 0.25) 
                        },
                        reaction: { 
                            average: videoReaction, 
                            count: Math.floor(totalSegmentRatings * 0.25) 
                        },
                        overall: { 
                            average: videoOverall, 
                            count: Math.floor(totalSegmentRatings * 0.25) 
                        }
                    }
                };

                sampleVideos.push(video);
            }
            
            videos = sampleVideos;
            return sampleVideos;
        }

        async function loadUserRatings() {
            if (!currentUser || !db) return;

            try {
                const ratingsSnapshot = await db.collection('userRatings')
                    .where('userId', '==', currentUser.uid)
                    .get();
                
                userRatings = {};
                
                ratingsSnapshot.docs.forEach(doc => {
                    const data = doc.data();
                    if (data.segmentId) {
                        // Segment-level rating
                        if (!userRatings[data.videoId]) {
                            userRatings[data.videoId] = { segments: {} };
                        }
                        userRatings[data.videoId].segments[data.segmentId] = data.ratings;
                    } else {
                        // Video-level rating (legacy)
                        if (!userRatings[data.videoId]) {
                            userRatings[data.videoId] = {};
                        }
                        userRatings[data.videoId].video = data.ratings;
                    }
                });
                
                updateUserRatingDisplay();
                
            } catch (error) {
                console.error('Error loading user ratings:', error);
            }
        }

        async function loadUserWordVotes() {
            if (!currentUser || !db) return;

            try {
                const votesSnapshot = await db.collection('userWordVotes')
                    .where('userId', '==', currentUser.uid)
                    .get();
                
                userWordVotes = {};
                
                votesSnapshot.docs.forEach(doc => {
                    const data = doc.data();
                    const key = `${data.videoId}_${data.segmentId}_${data.wordIndex}_${data.word}`;
                    userWordVotes[key] = data.voteType; // 'up' or 'down'
                });
                
            } catch (error) {
                console.error('Error loading user word votes:', error);
            }
        }

        function updateUserRatingDisplay() {
            // This will be called after renderVideos to update the display
            setTimeout(() => {
                Object.keys(userRatings).forEach(videoId => {
                    if (userRatings[videoId].segments) {
                        Object.keys(userRatings[videoId].segments).forEach(segmentId => {
                            const segmentRatings = userRatings[videoId].segments[segmentId];
                            const categories = ['lyrics', 'beats', 'reaction', 'overall'];
                            
                            categories.forEach(category => {
                                const rating = segmentRatings[category];
                                if (rating > 0) {
                                    const starsContainer = document.querySelector(`[data-video="${videoId}"][data-segment="${segmentId}"][data-category="${category}"]`)?.closest('.stars');
                                    if (starsContainer) {
                                        updateStarDisplay(starsContainer, rating, true);
                                        
                                        const controls = starsContainer.closest('.rating-controls');
                                        if (controls && !controls.querySelector('.user-rating-indicator')) {
                                            const indicator = document.createElement('div');
                                            indicator.className = 'user-rating-indicator';
                                            indicator.textContent = `Your rating: ${rating}★`;
                                            controls.appendChild(indicator);
                                        }
                                    }
                                }
                            });
                        });
                    }
                    
                    // Handle video-level ratings (legacy)
                    if (userRatings[videoId].video) {
                        const videoRatings = userRatings[videoId].video;
                        const categories = ['lyrics', 'beats', 'reaction', 'overall'];
                        
                        categories.forEach(category => {
                            const rating = videoRatings[category];
                            if (rating > 0) {
                                const starsContainer = document.querySelector(`[data-video="${videoId}"][data-category="${category}"]:not([data-segment])`)?.closest('.stars');
                                if (starsContainer) {
                                    updateStarDisplay(starsContainer, rating, true);
                                    
                                    const controls = starsContainer.closest('.rating-controls');
                                    if (controls && !controls.querySelector('.user-rating-indicator')) {
                                        const indicator = document.createElement('div');
                                        indicator.className = 'user-rating-indicator';
                                        indicator.textContent = `Your rating: ${rating}★`;
                                        controls.appendChild(indicator);
                                    }
                                }
                            }
                        });
                    }
                });
            }, 100);
        }

        async function submitRating(videoId, category, rating, segmentId = null) {
            try {
                if (!userRatings[videoId]) {
                    userRatings[videoId] = { segments: {} };
                }
                
                if (segmentId) {
                    if (!userRatings[videoId].segments[segmentId]) {
                        userRatings[videoId].segments[segmentId] = { lyrics: 0, beats: 0, reaction: 0, overall: 0 };
                    }
                    userRatings[videoId].segments[segmentId][category] = rating;
                } else {
                    if (!userRatings[videoId].video) {
                        userRatings[videoId].video = { lyrics: 0, beats: 0, reaction: 0, overall: 0 };
                    }
                    userRatings[videoId].video[category] = rating;
                }

                if (db) {
                    const docId = segmentId ? 
                        `${currentUser.uid}_${videoId}_${segmentId}` : 
                        `${currentUser.uid}_${videoId}`;
                    
                    const ratingsData = {
                        userId: currentUser.uid,
                        videoId: videoId,
                        ratings: segmentId ? userRatings[videoId].segments[segmentId] : userRatings[videoId].video,
                        lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                    };
                    
                    if (segmentId) {
                        ratingsData.segmentId = segmentId;
                    }

                    await db.collection('userRatings').doc(docId).set(ratingsData);
                    await updateVideoRating(videoId, category, rating, segmentId);
                }

                const segmentText = segmentId ? ` (${segmentId})` : '';
                showNotification(`Rated ${category}${segmentText}: ${rating} stars! Thanks for contributing!`, 'success');
                
            } catch (error) {
                console.error('Error submitting rating:', error);
                showNotification('Failed to save rating. Please try again.', 'error');
            }
        }

        async function updateVideoRating(videoId, category, newRating, segmentId = null) {
            if (!db) return;

            try {
                const docId = segmentId ? `${videoId}_${segmentId}_${category}` : `${videoId}_${category}`;
                const ratingsRef = db.collection(segmentId ? 'segmentRatings' : 'ratings').doc(docId);
                
                await db.runTransaction(async (transaction) => {
                    const ratingsDoc = await transaction.get(ratingsRef);
                    
                    let totalRating = newRating;
                    let count = 1;
                    
                    if (ratingsDoc.exists) {
                        const data = ratingsDoc.data();
                        totalRating = data.totalRating + newRating;
                        count = data.count + 1;
                    }
                    
                    const average = totalRating / count;
                    
                    transaction.set(ratingsRef, {
                        totalRating: totalRating,
                        count: count,
                        average: average,
                        videoId: videoId,
                        category: category
                    });
                    
                    if (segmentId) {
                        transaction.set(ratingsRef, {
                            ...ratingsRef.data,
                            segmentId: segmentId
                        });
                    }
                    
                    // Update the video document
                    const videoRef = db.collection('videos').doc(`episode_${videoId}`);
                    if (segmentId) {
                        transaction.update(videoRef, {
                            [`segments.${segmentId}.ratings.${category}.average`]: average,
                            [`segments.${segmentId}.ratings.${category}.count`]: count
                        });
                    } else {
                        transaction.update(videoRef, {
                            [`ratings.${category}.average`]: average,
                            [`ratings.${category}.count`]: count
                        });
                    }
                });
                
                // Update local data
                const video = videos.find(v => v.episodeNumber.toString() === videoId);
                if (video) {
                    if (segmentId) {
                        const segment = video.segments.find(s => s.id === segmentId);
                        if (segment && segment.ratings) {
                            const currentData = segment.ratings[category];
                            const newTotal = (currentData.average * currentData.count) + newRating;
                            const newCount = currentData.count + 1;
                            segment.ratings[category] = { average: newTotal / newCount, count: newCount };
                        }
                    } else {
                        const currentData = video.ratings[category];
                        const newTotal = (currentData.average * currentData.count) + newRating;
                        const newCount = currentData.count + 1;
                        video.ratings[category] = { average: newTotal / newCount, count: newCount };
                    }
                    renderVideos();
                    updateStats();
                }
            } catch (error) {
                console.error('Error updating rating:', error);
            }
        }

        async function voteOnWord(videoId, segmentId, wordIndex, word, voteType) {
            if (!currentUser) {
                showSignInPrompt('word voting', 0);
                return;
            }
            try {
                const voteKey = `${videoId}_${segmentId}_${wordIndex}_${word}`;
                const currentVote = userWordVotes[voteKey];

                // Toggle vote or change vote type
                let newVoteType = null;
                if (currentVote === voteType) {
                    // Remove vote if clicking same type
                    newVoteType = null;
                } else {
                    // Set new vote type
                    newVoteType = voteType;
                }
                userWordVotes[voteKey] = newVoteType;

                if (db) {
                    const voteDocId = `${currentUser.uid}_${voteKey}`;
                    if (newVoteType) {
                        await db.collection('userWordVotes').doc(voteDocId).set({
                            userId: currentUser.uid,
                            videoId: videoId,
                            segmentId: segmentId,
                            wordIndex: wordIndex,
                            word: word,
                            voteType: newVoteType,
                            timestamp: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    } else {
                        await db.collection('userWordVotes').doc(voteDocId).delete();
                    }

                    await updateWordVotes(videoId, segmentId, wordIndex, word, currentVote, newVoteType);
                }

                renderVideos();
                showNotification(`${newVoteType ? (newVoteType === 'up' ? 'Upvoted' : 'Downvoted') : 'Removed vote on'} word: ${word}`, 'success');
                
            } catch (error) {
                console.error('Error voting on word:', error);
                showNotification('Failed to save vote. Please try again.', 'error');
            }
        }

        async function updateWordVotes(videoId, segmentId, wordIndex, word, oldVote, newVote) {
            if (!db) return;

            try {
                const video = videos.find(v => v.episodeNumber.toString() === videoId);
                if (!video) return;

                const segment = video.segments.find(s => s.id === segmentId);
                if (!segment || !segment.words[wordIndex]) return;

                const wordCandidate = segment.words[wordIndex].find(w => w.word === word);
                if (!wordCandidate) return;

                // Update vote counts
                if (oldVote === 'up') wordCandidate.votes--;
                if (oldVote === 'down') wordCandidate.votes++;
                if (newVote === 'up') wordCandidate.votes++;
                if (newVote === 'down') wordCandidate.votes--;

                // Ensure votes don't go below 0
                wordCandidate.votes = Math.max(0, wordCandidate.votes);

                // Update in Firebase
                const videoRef = db.collection('videos').doc(`episode_${videoId}`);
                await videoRef.update({
                    [`segments`]: video.segments
                });

            } catch (error) {
                console.error('Error updating word votes:', error);
            }
        }


        async function addNewWord(videoId, segmentId, wordIndex, newWord) {
            console.log('🔍 Adding word:', { videoId, segmentId, wordIndex, newWord });
            
            // Step 1: Check if user is signed in
            if (!currentUser) {
                console.log('❌ No user signed in');
                showSignInPrompt('add words', 0);
                return;
            }
        
            // Step 2: Validate the word
            if (!newWord || !newWord.trim()) {
                console.log('❌ Empty word provided');
                showNotification('Please enter a word', 'error');
                return;
            }
        
            const trimmedWord = newWord.trim();
            console.log('✅ User authenticated, word validated:', trimmedWord);
        
            try {
                // Step 3: Find the video and segment
                const video = videos.find(v => v.episodeNumber.toString() === videoId);
                if (!video) {
                    showNotification('Video not found', 'error');
                    return;
                }
        
                const segment = video.segments.find(s => s.id === segmentId);
                if (!segment || !segment.words || !segment.words[wordIndex]) {
                    showNotification('Invalid word position', 'error');
                    return;
                }
        
                // Step 4: Check if word already exists
                const existingWord = segment.words[wordIndex].find(w => 
                    w && w.word && w.word.toLowerCase() === trimmedWord.toLowerCase()
                );
        
                if (existingWord) {
                    showNotification('This word already exists for this position', 'info');
                    return;
                }
        
                // Step 5: Add word to local data first (this always works)
                const newWordObj = {
                    word: trimmedWord,
                    votes: 1,
                    voters: [currentUser.uid]
                };
                segment.words[wordIndex].push(newWordObj);
                console.log('✅ Word added to local data');

                // Step 6: Save to Firebase with better error handling
                if (db) {
                    console.log('💾 Saving to Firebase...');
                    
                    try {
                        // Create a safe copy for Firebase
                        const segmentsForFirebase = video.segments.map(seg => {
                            // Deep clone the segment to avoid modifying original data
                            const safeSeg = {
                                id: seg.id,
                                ratings: { ...seg.ratings }
                            };
                            
                            // Convert nested arrays to objects for Firebase
                            if (seg.words && Array.isArray(seg.words)) {
                                safeSeg.words = seg.words.map(wordCandidates => {
                                    if (Array.isArray(wordCandidates)) {
                                        const wordObj = {};
                                        wordCandidates.forEach((candidate, index) => {
                                            if (candidate && candidate.word) {
                                                wordObj[index.toString()] = {
                                                    word: candidate.word,
                                                    votes: candidate.votes || 1,
                                                    voters: candidate.voters || []
                                                };
                                            }
                                        });
                                        return wordObj;
                                    }
                                    return wordCandidates; // Already in object format
                                });
                            }
                            
                            return safeSeg;
                        });
                
                        console.log('🔍 Firebase data structure:', segmentsForFirebase[0]?.words?.[0]);
                        
                        const videoRef = db.collection('videos').doc(`episode_${videoId}`);
                        await videoRef.update({
                            segments: segmentsForFirebase
                        });
                        console.log('✅ Firebase update successful!');
                        
                    } catch (firebaseError) {
                        console.error('❌ Firebase save failed:', firebaseError);
                        console.log('⚠️ Word added locally but not synced to Firebase');
                        // Don't throw - local data still works
                    }
                
                    // Step 7: Save user vote (keep this part the same)
                    try {
                        const voteKey = `${videoId}_${segmentId}_${wordIndex}_${trimmedWord}`;
                        userWordVotes[voteKey] = 'up';
                        const voteDocId = `${currentUser.uid}_${voteKey}`;
                        await db.collection('userWordVotes').doc(voteDocId).set({
                            userId: currentUser.uid,
                            videoId: videoId,
                            segmentId: segmentId,
                            wordIndex: parseInt(wordIndex),
                            word: trimmedWord,
                            voteType: 'up',
                            timestamp: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        console.log('✅ Vote record saved');
                    } catch (voteError) {
                        console.log('⚠️ Vote record failed (non-critical):', voteError.message);
                    }
                }
                
                // Step 8: Update the display
                renderVideos();
                showNotification(`Added new word: ${trimmedWord}`, 'success');
                console.log('✅ Word addition completed successfully');
        
            } catch (error) {
                console.error('❌ Error adding word:', error);
                showNotification('Failed to add word. Please try again.', 'error');
            }
        }


    

        function createStarRating(category, videoId, currentRating, ratingCount, segmentId = null) {
            let starsHtml = '';
            const ratingKey = segmentId ? (userRatings[videoId]?.segments?.[segmentId]?.[category] || 0) : (userRatings[videoId]?.video?.[category] || 0);

            for (let i = 1; i <= 5; i++) {
                const activeClass = i <= Math.round(currentRating) ? 'active' : '';
                const userRatedClass = ratingKey > 0 && i <= ratingKey ? 'user-rated' : '';
                const dataAttrs = segmentId ? `data-rating="${i}" data-category="${category}" data-video="${videoId}" data-segment="${segmentId}"` : `data-rating="${i}" data-category="${category}" data-video="${videoId}"`;
                starsHtml += `<span class="star ${activeClass} ${userRatedClass}" ${dataAttrs}>★</span>`;
            }
            return starsHtml;
        }

        function createWordCandidatesHtml(wordCandidates, videoId, segmentId, wordIndex) {
            console.log(`🔍 Processing word candidates for ${videoId}-${segmentId}-${wordIndex}:`, wordCandidates);
            
            // Ensure we have a valid array of candidates
            let validCandidates = [];
            
            if (Array.isArray(wordCandidates)) {
                // It's already an array - filter out invalid entries
                validCandidates = wordCandidates.filter(candidate => 
                    candidate && 
                    candidate.word && 
                    typeof candidate.word === 'string' && 
                    candidate.word.trim() !== ''
                );
            } else {
                // Fallback - create a default word
                console.log(`⚠️ Unknown word candidates format, creating fallback`);
                validCandidates = [{
                    word: 'unknown',
                    votes: 1,
                    voters: []
                }];
            }
            
            // Sort by votes (highest first)
            const sortedCandidates = validCandidates.sort((a, b) => (b.votes || 0) - (a.votes || 0));
            
            return sortedCandidates.map(candidate => {
                const voteKey = `${videoId}_${segmentId}_${wordIndex}_${candidate.word}`;
                const userVote = userWordVotes[voteKey];
                return `
                    <div class="word-item">
                        <span>${candidate.word}</span>
                        <span class="word-votes">${candidate.votes || 0}</span>
                        <div class="vote-buttons">
                            <button class="vote-btn ${userVote === 'up' ? 'voted' : ''}" onclick="voteOnWord('${videoId}', '${segmentId}', ${wordIndex}, '${candidate.word}', 'up')">
                                ↑
                            </button>
                            <button class="vote-btn ${userVote === 'down' ? 'voted' : ''}" onclick="voteOnWord('${videoId}', '${segmentId}', ${wordIndex}, '${candidate.word}', 'down')">
                                ↓
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function createSegmentHtml(segment, videoId, segmentIndex) {
            console.log(`🔧 Creating segment HTML for ${videoId}-${segmentIndex}:`, segment);
            
            try {
                const segmentId = segment.id || `fallback_segment_${segmentIndex}`;
                
                // Debug Episode 2 specifically
                if (videoId === '2' && DEBUG_EPISODE_2) {
                    console.log('🔍 EPISODE 2 SEGMENT DEBUG:');
                    console.log('Segment ID:', segmentId);
                    console.log('Segment ratings:', segment.ratings);
                    console.log('Segment words:', segment.words);
                    console.log('Words is array:', Array.isArray(segment.words));
                }
                
                // Ensure segment has ratings - if not, use defaults
                const segmentRatings = segment.ratings || defaultRatings;
                
                //const avgRating = (segmentRatings.lyrics.average + segmentRatings.beats.average + segmentRatings.reaction.average + segmentRatings.overall.average) / 4;

                // Safe calculation with fallback values
                const avgRating = [
                    segmentRatings.lyrics?.average || 0,
                    segmentRatings.beats?.average || 0, 
                    segmentRatings.reaction?.average || 0,
                    segmentRatings.overall?.average || 0
                ].reduce((sum, val) => sum + val, 0) / 4;
                
                // Process words with extensive debugging
                let wordsHtml = '';
                if (segment.words && Array.isArray(segment.words)) {
                    wordsHtml = segment.words.map((wordCandidates, wordIndex) => {
                        try {
                            return `
                                <div style="margin-bottom: 15px;">
                                    <div class="segment-label">Word ${wordIndex + 1}</div>
                                    <div class="word-list">
                                        ${createWordCandidatesHtml(wordCandidates, videoId, segmentId, wordIndex)}
                                    </div>
                                    <div class="add-word-form">
                                        <input type="text" class="add-word-input" placeholder="Add alternative word..." id="newWord_${videoId}_${segmentId}_${wordIndex}">
                                        <button class="add-word-btn" onclick="addWordFromInput('${videoId}', '${segmentId}', ${wordIndex})">
                                            Add
                                        </button>
                                    </div>
                                </div>
                            `;
                        } catch (wordError) {
                            console.error(`❌ Error processing word ${wordIndex}:`, wordError);
                            return `<div class="word-error">Error loading word ${wordIndex + 1}</div>`;
                        }
                    }).join('');
                } else {
                    console.log(`⚠️ No valid words array found in segment`);
                    wordsHtml = '<div class="no-words">No words available</div>';
                }

                // Add debug info for Episode 2
                const debugHtml = (videoId === '2' && DEBUG_EPISODE_2) ? `
                    <div class="debug-info">
                        DEBUG: Episode 2, Segment ${segmentIndex + 1}<br>
                        ID: ${segmentId}<br>
                        Words count: ${segment.words ? segment.words.length : 0}<br>
                        Ratings: ${JSON.stringify(segmentRatings, null, 2)}
                    </div>
                ` : '';

                return `
                    <div class="segment" data-segment="${segmentId}">
                        <div class="segment-header" onclick="toggleSegment('${videoId}', '${segmentId}')">
                            <div class="segment-info">
                                <div class="segment-title">Segment ${segmentIndex + 1}</div>
                                <div class="segment-rating-summary">${avgRating.toFixed(1)}★ average</div>
                            </div>
                            <div class="segment-expand-icon">▶</div>
                        </div>
                        <div class="segment-content">
                            <div class="segment-details">
                                ${debugHtml}
                                <div class="words-management">
                                    <h5>Crowdsourced Words (vote on accuracy)</h5>
                                    ${wordsHtml}
                                </div>
                                <div class="segment-ratings">
                                    <h5 style="color: #2c3e50; margin-bottom: 15px; font-size: 0.85rem;">Rate This Segment</h5>
                                    ${['lyrics', 'beats', 'reaction', 'overall'].map(category => `
                                        <div class="rating-category">
                                            <div class="rating-info">
                                                <span class="rating-label">${category.charAt(0).toUpperCase() + category.slice(1)}</span>
                                                <span class="rating-stats">${(segmentRatings[category]?.average || 0).toFixed(1)}★ (${segmentRatings[category]?.count || 0} ratings)</span>
                                            </div>
                                            <div class="rating-controls">
                                                <div class="stars" data-category="${category}" data-video="${videoId}" data-segment="${segmentId}">                                                   
                                                    ${createStarRating(category, videoId, segmentRatings[category]?.average || 0, segmentRatings[category]?.count || 0, segmentId)}                                                    
                                                </div>
                                                ${userRatings[videoId]?.segments?.[segmentId]?.[category] ? `<div class="user-rating-indicator">Your rating: ${userRatings[videoId].segments[segmentId][category]}★</div>` : ''}
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
            } catch (error) {
                console.error(`❌ Error in createSegmentHtml for ${videoId}-${segmentIndex}:`, error);
                console.error(`❌ Error stack:`, error.stack);
                console.error(`❌ Segment data:`, segment);
                return `
                    <div class="segment segment-error">
                        <div class="segment-header">
                            <div class="segment-info">
                                <div class="segment-title">Segment ${segmentIndex + 1} (Error)</div>
                                <div class="segment-rating-summary">Unable to load</div>
                            </div>
                        </div>
                        ${(videoId === '2' && DEBUG_EPISODE_2) ? `
                            <div class="debug-info">
                                ERROR DEBUG: ${error.message}<br>
                                Segment data: ${JSON.stringify(segment, null, 2)}
                            </div>
                        ` : ''}
                    </div>
                `;
            }
        }

        function renderVideos() {
            console.log('🎨 Starting renderVideos function...');
            console.log(`📊 Videos to render: ${videos.length}`);
            
            const videoGrid = document.getElementById('videoGrid');
            videoGrid.innerHTML = ''; // Clear existing videos

            let filteredVideos = [...videos];
            console.log(`📋 Initial video count: ${filteredVideos.length}`);

            // Apply filters
            const sortFilter = document.getElementById('sortFilter').value;
            const ratingFilter = parseFloat(document.getElementById('ratingFilter').value);
            const searchFilter = document.getElementById('searchFilter').value.toLowerCase();

            console.log(`🔍 Filters - Sort: ${sortFilter}, Rating: ${ratingFilter}, Search: "${searchFilter}"`);

            // Filter by rating
            if (ratingFilter > 0) {
                const beforeCount = filteredVideos.length;
                filteredVideos = filteredVideos.filter(video => video.ratings.overall.average >= ratingFilter);
                console.log(`📊 Rating filter: ${beforeCount} → ${filteredVideos.length} videos`);
            }

            // Filter by search term
            if (searchFilter) {
                const beforeCount = filteredVideos.length;
                filteredVideos = filteredVideos.filter(video => {
                    try {
                        return video.title.toLowerCase().includes(searchFilter) ||
                               video.episodeNumber.toString().includes(searchFilter) ||
                               (video.segments && video.segments.some(segment =>
                                   segment.words && segment.words.some(wordCandidates => {
                                       if (Array.isArray(wordCandidates)) {
                                           return wordCandidates.some(candidate =>
                                               candidate && candidate.word && 
                                               candidate.word.toLowerCase().includes(searchFilter)
                                           );
                                       }
                                       return false;
                                   })
                               ));
                    } catch (searchError) {
                        console.error(`❌ Search error for video ${video.episodeNumber}:`, searchError);
                        return true; // Include video if search fails
                    }
                });
                console.log(`🔍 Search filter: ${beforeCount} → ${filteredVideos.length} videos`);
            }

            // Sort videos
            filteredVideos.sort((a, b) => {
                if (sortFilter === 'episode') {
                    return a.episodeNumber - b.episodeNumber;
                } else {
                    return b.ratings[sortFilter].average - a.ratings[sortFilter].average;
                }
            });
            console.log(`📊 Sorted ${filteredVideos.length} videos by ${sortFilter}`);

            // Render each video with error handling
            let successCount = 0;
            let errorCount = 0;
            
            filteredVideos.forEach((video, index) => {
                try {
                    console.log(`🎬 Rendering video ${index + 1}/${filteredVideos.length}: Episode ${video.episodeNumber}`);
                    
                    if (video.episodeNumber === 2 && DEBUG_EPISODE_2) {
                        console.log('🔍 EPISODE 2 RENDER DEBUG:');
                        console.log('Video object:', video);
                        console.log('Segments:', video.segments);
                        console.log('Segments count:', video.segments ? video.segments.length : 'No segments');
                    }
                    
                    const videoCard = document.createElement('div');
                    videoCard.className = 'video-card';
                    
                    // Create video card HTML with error handling for segments
                    let segmentsHtml = '';
                    if (video.segments && Array.isArray(video.segments)) {
                        console.log(`📦 Processing ${video.segments.length} segments for Episode ${video.episodeNumber}`);
                        try {
                            segmentsHtml = video.segments.map((segment, segIndex) => {
                                try {
                                    return createSegmentHtml(segment, video.episodeNumber, segIndex);
                                } catch (segmentError) {
                                    console.error(`❌ Error rendering segment ${segIndex} for Episode ${video.episodeNumber}:`, segmentError);
                                    return `<div class="segment-error">Error loading segment ${segIndex + 1}</div>`;
                                }
                            }).join('');
                        } catch (segmentsError) {
                            console.error(`❌ Error processing segments for Episode ${video.episodeNumber}:`, segmentsError);
                            segmentsHtml = '<div class="segments-error">Error loading segments</div>';
                        }
                    } else {
                        console.log(`⚠️ No valid segments for Episode ${video.episodeNumber}`);
                        segmentsHtml = '<div class="no-segments">No segments available</div>';
                    }
                    
                    videoCard.innerHTML = `
                        <div class="video-embed" style="position: relative; cursor: pointer; background-image: url('https://img.youtube.com/vi/${video.youtubeId}/maxresdefault.jpg'); background-size: cover; background-position: center;" onclick="window.open('https://www.youtube.com/watch?v=${video.youtubeId}', '_blank')">
                            <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center;">
                                <div style="text-align: center; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">
                                    <div style="font-size: 4rem; margin-bottom: 10px;">▶️</div>
                                    <div style="font-size: 1.1rem; font-weight: bold;">Episode #${video.episodeNumber}</div>
                                    <div style="font-size: 0.9rem; opacity: 0.9;">Click to watch on YouTube</div>
                                </div>
                            </div>
                        </div>
                        <div class="video-content">
                            <h3 class="video-title">${video.title}</h3>
                            <div class="overall-rating">
                                <h4>Overall Video Rating</h4>
                                <div class="rating-category">
                                    <div class="rating-info">
                                        <span class="rating-label">Overall</span>
                                        <span class="rating-stats">${video.ratings.overall.average.toFixed(1)}★ (${video.ratings.overall.count} ratings)</span>
                                    </div>
                                    <div class="rating-controls">
                                        <div class="stars" data-category="overall" data-video="${video.episodeNumber}">
                                            ${createStarRating('overall', video.episodeNumber, video.ratings.overall.average, video.ratings.overall.count)}
                                        </div>
                                        ${userRatings[video.episodeNumber]?.video?.overall ? `<div class="user-rating-indicator">Your rating: ${userRatings[video.episodeNumber].video.overall}★</div>` : ''}
                                    </div>
                                </div>
                            </div>

                            <div class="segments-section">
                                <div class="segments-header">
                                    <h4>Segments (${video.segments ? video.segments.length : 0})</h4>
                                    <button class="expand-toggle" onclick="toggleAllSegments('${video.episodeNumber}')">Expand All</button>
                                </div>
                                <div class="segments-container" data-video="${video.episodeNumber}">
                                    ${segmentsHtml}
                                </div>
                            </div>
                        </div>
                    `;
                    videoGrid.appendChild(videoCard);
                    successCount++;
                    
                } catch (videoError) {
                    console.error(`❌ Error rendering video ${video.episodeNumber}:`, videoError);
                    console.error(`❌ Video error details:`, videoError.message);
                    errorCount++;
                    
                    // Create a basic error card
                    const errorCard = document.createElement('div');
                    errorCard.className = 'video-card';
                    errorCard.innerHTML = `
                        <div class="video-content">
                            <h3 class="video-title">Episode #${video.episodeNumber} (Error)</h3>
                            <p>Error loading this episode. Please try refreshing.</p>
                        </div>
                    `;
                    videoGrid.appendChild(errorCard);
                }
            });

            console.log(`✅ Rendering complete: ${successCount} success, ${errorCount} errors`);

            // Attach star rating event listeners
            try {
                document.querySelectorAll('.star').forEach(star => {
                    star.onclick = function() {
                        const rating = parseInt(this.dataset.rating);
                        const category = this.dataset.category;
                        const videoId = this.dataset.video;
                        const segmentId = this.dataset.segment || null;
                        if (currentUser) {
                            submitRating(videoId, category, rating, segmentId);
                        } else {
                            showSignInPrompt('rate segments', 0);
                        }
                    };
                });
                console.log('✅ Star rating event listeners attached');
            } catch (eventError) {
                console.error('❌ Error attaching event listeners:', eventError);
            }

            // Update user rating display after rendering
            try {
                updateUserRatingDisplay();
                console.log('✅ User rating display updated');
            } catch (displayError) {
                console.error('❌ Error updating user rating display:', displayError);
            }
        }

        function updateStarDisplay(starsContainer, rating, userRated = false) {
            const stars = starsContainer.querySelectorAll('.star');
            stars.forEach((star, index) => {
                star.classList.remove('active', 'user-rated');
                if (index < rating) {
                    star.classList.add('active');
                }
                if (userRated && index < rating) {
                    star.classList.add('user-rated');
                }
            });
        }

        function toggleSegment(videoId, segmentId) {
            // Find the segment within the specific video container
            const videoContainer = document.querySelector(`.segments-container[data-video="${videoId}"]`);
            if (videoContainer) {
                const segmentElement = videoContainer.querySelector(`.segment[data-segment="${segmentId}"]`);
                if (segmentElement) {
                    segmentElement.classList.toggle('expanded');
                }
            }
        }

        function toggleAllSegments(videoId) {
            const container = document.querySelector(`.segments-container[data-video="${videoId}"]`);
            if (container) {
                const segments = container.querySelectorAll('.segment');
                let allExpanded = true;
                segments.forEach(segment => {
                    if (!segment.classList.contains('expanded')) {
                        allExpanded = false;
                    }
                });

                segments.forEach(segment => {
                    if (allExpanded) {
                        segment.classList.remove('expanded');
                    } else {
                        segment.classList.add('expanded');
                    }
                });
                
                // Update button text
                const button = container.closest('.video-card').querySelector('.expand-toggle');
                if (button) {
                    button.textContent = allExpanded ? 'Expand All' : 'Collapse All';
                }
            }
        }

        function addWordFromInput(videoId, segmentId, wordIndex) {
            const inputId = `newWord_${videoId}_${segmentId}_${wordIndex}`;
            const inputElement = document.getElementById(inputId);
            const newWord = inputElement.value;
            addNewWord(videoId, segmentId, wordIndex, newWord);
            inputElement.value = ''; // Clear input after adding
        }

        function updateStats() {
            let totalRatings = 0;
            let totalOverallRating = 0;
            let overallRatingCount = 0;
            let maxOverallRating = 0;
            let topEpisode = '#--';

            videos.forEach(video => {
                if (video.ratings.overall.count > 0) {
                    totalOverallRating += video.ratings.overall.average * video.ratings.overall.count;
                    overallRatingCount += video.ratings.overall.count;
                }

                if (video.segments) {
                    video.segments.forEach(segment => {
                        if (segment.ratings) {
                            Object.values(segment.ratings).forEach(rating => {
                                totalRatings += rating.count;
                            });
                        }
                    });
                }
                
                if (video.ratings.overall.average > maxOverallRating) {
                    maxOverallRating = video.ratings.overall.average;
                    topEpisode = `#${video.episodeNumber}`;
                }
            });

            document.getElementById('totalRatings').textContent = totalRatings;
            document.getElementById('avgOverall').textContent = overallRatingCount > 0 ? (totalOverallRating / overallRatingCount).toFixed(1) : '0.0';
            document.getElementById('activeUsers').textContent = Object.keys(userRatings).length;
            document.getElementById('topEpisode').textContent = topEpisode;
        }
        
        function showNotification(message, type) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        function showSignInPrompt(action, delay = 0) {
            setTimeout(() => {
                showNotification(`Please sign in to ${action}.`, 'info');
            }, delay);
        }

        function init() {
            updateConnectionStatus('connecting');
            
            initializeFirebase();
            
            // Setup filters
            document.getElementById('sortFilter').addEventListener('change', applyFilters);
            document.getElementById('ratingFilter').addEventListener('change', applyFilters);
            document.getElementById('searchFilter').addEventListener('input', applyFilters);
            
            setupRealtimeUpdates();
        
            document.getElementById('authButton').addEventListener('click', () => {
                if (currentUser) {
                    signOut();
                } else {
                    signIn();
                }
            });
        }

        function applyFilters() {
            renderVideos(); // Re-render videos based on current filter settings
        }

        function setupRealtimeUpdates() {
            if (!db) return; // Don't setup if in demo mode
            
            db.collection('videos').onSnapshot((snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === 'modified') {
                        const updatedVideo = { id: change.doc.id, ...change.doc.data() };
                        const index = videos.findIndex(v => v.episodeNumber === updatedVideo.episodeNumber);
                        if (index !== -1) {
                            videos[index] = updatedVideo;
                        }
                    }
                });
                
                if (snapshot.docChanges().length > 0) {
                    applyFilters();
                    updateStats();
                }
            });
        }

        // Make functions globally available for onclick handlers
        window.voteOnWord = voteOnWord;
        window.addWordFromInput = addWordFromInput;
        window.toggleSegment = toggleSegment;
        window.toggleAllSegments = toggleAllSegments;
 
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
